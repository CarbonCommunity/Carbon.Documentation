[
  {
    "name": "OnHorseLead",
    "fullName": "OnHorseLead [BaseRidableAnimal]",
    "category": "Animal",
    "parameters": [
      {
        "name": "baseRidableAnimal",
        "type": "BaseRidableAnimal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Lead(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!SH_LeadCheck())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && !AnyMounted() && !IsForSale())\r\n\t{\r\n\t\tbool num = IsLeading();\r\n\t\tbool flag = msg.read.Bit();\r\n\t\tif (num != flag)\r\n\t\t{\r\n\t\t\tSetLeading(flag ? player : null);\r\n\t\t\tLeadingChanged();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseRidableAnimal",
    "methodName": "RPC_Lead",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRidableAnimalClaim",
    "fullName": "OnRidableAnimalClaim [BaseRidableAnimal]",
    "category": "Animal",
    "parameters": [
      {
        "name": "baseRidableAnimal",
        "type": "BaseRidableAnimal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Claim(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && IsForSale())\r\n\t{\r\n\t\tint tokenItemID = msg.read.Int32();\r\n\t\tItem item = GetPurchaseToken(player, tokenItemID);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved2, b: false);\r\n\t\t\tOnClaimedWithToken(item);\r\n\t\t\titem.UseItem();\r\n\t\t\tFacepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);\r\n\t\t\tAttemptMount(player, doMountChecks: false);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseRidableAnimal",
    "methodName": "RPC_Claim",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRidableAnimalClaimed",
    "fullName": "OnRidableAnimalClaimed [BaseRidableAnimal]",
    "category": "Animal",
    "parameters": [
      {
        "name": "baseRidableAnimal",
        "type": "BaseRidableAnimal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Claim(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && IsForSale())\r\n\t{\r\n\t\tint tokenItemID = msg.read.Int32();\r\n\t\tItem item = GetPurchaseToken(player, tokenItemID);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved2, b: false);\r\n\t\t\tOnClaimedWithToken(item);\r\n\t\t\titem.UseItem();\r\n\t\t\tFacepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);\r\n\t\t\tAttemptMount(player, doMountChecks: false);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseRidableAnimal",
    "methodName": "RPC_Claim",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnAnimalDungProduce",
    "fullName": "OnAnimalDungProduce [BaseRidableAnimal]",
    "category": "Animal",
    "parameters": [
      {
        "name": "baseRidableAnimal",
        "type": "BaseRidableAnimal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoDung()\r\n{\r\n\tdungProduction -= 1f;\r\n\tItemManager.Create(Dung, 1, 0uL).Drop(base.transform.position + -base.transform.forward + UnityEngine.Vector3.up * 1.1f + UnityEngine.Random.insideUnitSphere * 0.1f, -base.transform.forward);\r\n}\r\n",
    "targetName": "BaseRidableAnimal",
    "methodName": "DoDung",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnAnimalDungProduced",
    "fullName": "OnAnimalDungProduced [BaseRidableAnimal]",
    "category": "Animal",
    "parameters": [
      {
        "name": "baseRidableAnimal",
        "type": "BaseRidableAnimal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoDung()\r\n{\r\n\tdungProduction -= 1f;\r\n\tItemManager.Create(Dung, 1, 0uL).Drop(base.transform.position + -base.transform.forward + UnityEngine.Vector3.up * 1.1f + UnityEngine.Random.insideUnitSphere * 0.1f, -base.transform.forward);\r\n}\r\n",
    "targetName": "BaseRidableAnimal",
    "methodName": "DoDung",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnHorseLead",
    "fullName": "OnHorseLead [RidableHorse2]",
    "category": "Animal",
    "parameters": [
      {
        "name": "ridableHorse2",
        "type": "RidableHorse2, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void SERVER_Lead(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = msg.read.Bool();\r\n\tif (flag)\r\n\t{\r\n\t\tif (!CanLead(player))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\telse if (!CanStopLead(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSetLeading(flag ? player : null);\r\n}\r\n",
    "targetName": "RidableHorse2",
    "methodName": "SERVER_Lead",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRidableAnimalClaim",
    "fullName": "OnRidableAnimalClaim [RidableHorse2]",
    "category": "Animal",
    "parameters": [
      {
        "name": "ridableHorse2",
        "type": "RidableHorse2, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_Claim(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && IsForSale)\r\n\t{\r\n\t\tint tokenItemID = msg.read.Int32();\r\n\t\tItem purchaseToken = GetPurchaseToken(player, tokenItemID);\r\n\t\tif (purchaseToken != null)\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved2, b: false);\r\n\t\t\tOnClaimedWithToken(purchaseToken);\r\n\t\t\tpurchaseToken.UseItem();\r\n\t\t\tFacepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);\r\n\t\t\tAttemptMount(player, doMountChecks: false);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "RidableHorse2",
    "methodName": "SERVER_Claim",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRidableAnimalClaimed",
    "fullName": "OnRidableAnimalClaimed [RidableHorse2]",
    "category": "Animal",
    "parameters": [
      {
        "name": "ridableHorse2",
        "type": "RidableHorse2, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_Claim(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && IsForSale)\r\n\t{\r\n\t\tint tokenItemID = msg.read.Int32();\r\n\t\tItem purchaseToken = GetPurchaseToken(player, tokenItemID);\r\n\t\tif (purchaseToken != null)\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved2, b: false);\r\n\t\t\tOnClaimedWithToken(purchaseToken);\r\n\t\t\tpurchaseToken.UseItem();\r\n\t\t\tFacepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);\r\n\t\t\tAttemptMount(player, doMountChecks: false);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "RidableHorse2",
    "methodName": "SERVER_Claim",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnAnimalDungProduce",
    "fullName": "OnAnimalDungProduce [RidableHorse2]",
    "category": "Animal",
    "parameters": [
      {
        "name": "ridableHorse2",
        "type": "RidableHorse2, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoDung()\r\n{\r\n\tdungProduction -= 1f;\r\n\tUnityEngine.Quaternion rotation = UnityEngine.Quaternion.Euler(UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f));\r\n\tUnityEngine.Vector3 vVelocity = new UnityEngine.Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-1f, -3f), UnityEngine.Random.Range(-0.5f, 0.5f));\r\n\tItem item = ItemManager.Create(dungItem, 1, 0uL);\r\n\titem.SetItemOwnership(currentBreed.breedName.english, ItemOwnershipPhrases.Pooped);\r\n\titem.Drop(dungSpawnPoint.position + UnityEngine.Random.insideUnitSphere * 0.1f, vVelocity, rotation);\r\n}\r\n",
    "targetName": "RidableHorse2",
    "methodName": "DoDung",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnAnimalDungProduced",
    "fullName": "OnAnimalDungProduced [RidableHorse2]",
    "category": "Animal",
    "parameters": [
      {
        "name": "ridableHorse2",
        "type": "RidableHorse2, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoDung()\r\n{\r\n\tdungProduction -= 1f;\r\n\tUnityEngine.Quaternion rotation = UnityEngine.Quaternion.Euler(UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f));\r\n\tUnityEngine.Vector3 vVelocity = new UnityEngine.Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-1f, -3f), UnityEngine.Random.Range(-0.5f, 0.5f));\r\n\tItem item = ItemManager.Create(dungItem, 1, 0uL);\r\n\titem.SetItemOwnership(currentBreed.breedName.english, ItemOwnershipPhrases.Pooped);\r\n\titem.Drop(dungSpawnPoint.position + UnityEngine.Random.insideUnitSphere * 0.1f, vVelocity, rotation);\r\n}\r\n",
    "targetName": "RidableHorse2",
    "methodName": "DoDung",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnHorseHitch",
    "fullName": "OnHorseHitch",
    "category": "Animal",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool AttemptToHitch(HitchTrough.IHitchable hitchable, HitchTrough.HitchSpot spot = null)\r\n{\r\n\tif (hitchable == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (spot == null)\r\n\t{\r\n\t\tBaseEntity baseEntity = hitchable as BaseEntity;\r\n\t\tif (baseEntity != null)\r\n\t\t{\r\n\t\t\tspot = GetClosestSpot(baseEntity.transform.position);\r\n\t\t}\r\n\t}\r\n\tif (spot != null)\r\n\t{\r\n\t\tspot.SetOccupiedBy(hitchable);\r\n\t\thitchable.SetHitch(this, spot);\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "HitchTrough",
    "methodName": "AttemptToHitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnHorseUnhitch",
    "fullName": "OnHorseUnhitch",
    "category": "Animal",
    "parameters": [
      {
        "name": "hitchable",
        "type": "HitchTrough+IHitchable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "HitchTrough+HitchSpot, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UnHitch(HitchTrough.IHitchable hitchable)\r\n{\r\n\tHitchTrough.HitchSpot[] array = hitchSpots;\r\n\tforeach (HitchTrough.HitchSpot hitchSpot in array)\r\n\t{\r\n\t\tif (hitchSpot.GetHitchable(base.isServer) == hitchable)\r\n\t\t{\r\n\t\t\thitchSpot.SetOccupiedBy(null);\r\n\t\t\thitchable.SetHitch(null, null);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "HitchTrough",
    "methodName": "UnHitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBookmarkControl",
    "fullName": "OnBookmarkControl",
    "category": "Bookmark",
    "parameters": [
      {
        "name": "computerStation",
        "type": "ComputerStation, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local2",
        "type": "IRemoteControllable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void BeginControllingBookmark(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!IsPlayerAdmin(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String();\r\n\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\r\n\tif (remoteControllable == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity ent = remoteControllable.GetEnt();\r\n\tif (ent == null)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"RC identifier \" + text + \" was found but has a null or destroyed entity, this should never happen\");\r\n\t}\r\n\telse if (remoteControllable.CanControl(player.userID) && !(UnityEngine.Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange))\r\n\t{\r\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.GetComponent<IRemoteControllable>()?.StopControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t\t}\r\n\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\r\n\t\tplayer.SetRcEntityPosition(ent.transform.position);\r\n\t\tcurrentlyControllingEnt.uid = ent.net.ID;\r\n\t\tcurrentPlayerID = player.userID;\r\n\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t\tSetFlag(BaseEntity.Flags.Reserved2, b, recursive: false, networkupdate: false);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tSendControlBookmarks(player);\r\n\t\tif (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)\r\n\t\t{\r\n\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\r\n\t\t}\r\n\t\tInvokeRepeating(ControlCheck, 0f, 0f);\r\n\t}\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "BeginControllingBookmark",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBookmarkDelete",
    "fullName": "OnBookmarkDelete",
    "category": "Bookmark",
    "parameters": [
      {
        "name": "computerStation",
        "type": "ComputerStation, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void DeleteBookmark(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!IsPlayerAdmin(player) || isStatic)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String();\r\n\tif (IsValidIdentifier(text) && controlBookmarks.Contains(text))\r\n\t{\r\n\t\tcontrolBookmarks.Remove(text);\r\n\t\tSendControlBookmarks(player);\r\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\r\n\t\tif (baseEntity != null && baseEntity.TryGetComponent<IRemoteControllable>(out var component) && component.GetIdentifier() == text)\r\n\t\t{\r\n\t\t\tStopControl(player);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "DeleteBookmark",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBookmarkAdd",
    "fullName": "OnBookmarkAdd",
    "category": "Bookmark",
    "parameters": [
      {
        "name": "computerStation",
        "type": "ComputerStation, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void AddBookmark(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (IsPlayerAdmin(player) && !isStatic)\r\n\t{\r\n\t\tif (UnityEngine.Time.realtimeSinceStartup < nextAddTime)\r\n\t\t{\r\n\t\t\tplayer.ChatMessage(\"Slow down...\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (controlBookmarks.Count >= 128)\r\n\t\t{\r\n\t\t\tplayer.ChatMessage(\"Too many bookmarks, delete some\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tnextAddTime = UnityEngine.Time.realtimeSinceStartup + 1f;\r\n\t\tstring identifier = msg.read.String();\r\n\t\tForceAddBookmark(identifier);\r\n\t\tSendControlBookmarks(player);\r\n\t}\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "AddBookmark",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBookmarksSendControl",
    "fullName": "OnBookmarksSendControl",
    "category": "Bookmark",
    "parameters": [
      {
        "name": "computerStation",
        "type": "ComputerStation, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendControlBookmarks(BasePlayer player)\r\n{\r\n\tif (!(player == null))\r\n\t{\r\n\t\tstring arg = GenerateControlBookmarkString();\r\n\t\tClientRPC(RpcTarget.Player(\"ReceiveBookmarks\", player), arg);\r\n\t}\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "SendControlBookmarks",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBookmarkControlEnd",
    "fullName": "OnBookmarkControlEnd",
    "category": "Bookmark",
    "parameters": [
      {
        "name": "computerStation",
        "type": "ComputerStation, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "ply",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StopControl(BasePlayer ply)\r\n{\r\n\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\r\n\tif ((bool)baseEntity)\r\n\t{\r\n\t\tbaseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t}\r\n\tif ((bool)ply)\r\n\t{\r\n\t\tply.net.SwitchSecondaryGroup(null);\r\n\t\tply.SetRcEntityPosition(null);\r\n\t}\r\n\tcurrentlyControllingEnt.uid = default(NetworkableId);\r\n\tcurrentPlayerID = 0uL;\r\n\tSetFlag(BaseEntity.Flags.Reserved2, b: false, recursive: false, networkupdate: false);\r\n\tSendNetworkUpdate();\r\n\tSendControlBookmarks(ply);\r\n\tCancelInvoke(ControlCheck);\r\n\tCancelInvoke(CheckCCTVAchievement);\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "StopControl",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBookmarkInput",
    "fullName": "OnBookmarkInput",
    "category": "Bookmark",
    "parameters": [
      {
        "name": "computerStation",
        "type": "ComputerStation, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "inputState",
        "type": "InputState, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void PlayerServerInput(InputState inputState, BasePlayer player)\r\n{\r\n\tbase.PlayerServerInput(inputState, player);\r\n\tif (HasFlag(BaseEntity.Flags.Reserved2) && currentlyControllingEnt.IsValid(serverside: true))\r\n\t{\r\n\t\tcurrentlyControllingEnt.Get(serverside: true).GetComponent<IRemoteControllable>().UserInput(inputState, new CameraViewerId(player.userID, 0L));\r\n\t}\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "PlayerServerInput",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBookmarkControlStarted",
    "fullName": "OnBookmarkControlStarted",
    "category": "Bookmark",
    "parameters": [
      {
        "name": "computerStation",
        "type": "ComputerStation, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local2",
        "type": "IRemoteControllable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void BeginControllingBookmark(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!IsPlayerAdmin(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String();\r\n\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\r\n\tif (remoteControllable == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity ent = remoteControllable.GetEnt();\r\n\tif (ent == null)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"RC identifier \" + text + \" was found but has a null or destroyed entity, this should never happen\");\r\n\t}\r\n\telse if (remoteControllable.CanControl(player.userID) && !(UnityEngine.Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange))\r\n\t{\r\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.GetComponent<IRemoteControllable>()?.StopControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t\t}\r\n\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\r\n\t\tplayer.SetRcEntityPosition(ent.transform.position);\r\n\t\tcurrentlyControllingEnt.uid = ent.net.ID;\r\n\t\tcurrentPlayerID = player.userID;\r\n\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t\tSetFlag(BaseEntity.Flags.Reserved2, b, recursive: false, networkupdate: false);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tSendControlBookmarks(player);\r\n\t\tif (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)\r\n\t\t{\r\n\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\r\n\t\t}\r\n\t\tInvokeRepeating(ControlCheck, 0f, 0f);\r\n\t}\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "BeginControllingBookmark",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnBookmarkControlEnded",
    "fullName": "OnBookmarkControlEnded",
    "category": "Bookmark",
    "parameters": [
      {
        "name": "computerStation",
        "type": "ComputerStation, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "ply",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StopControl(BasePlayer ply)\r\n{\r\n\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\r\n\tif ((bool)baseEntity)\r\n\t{\r\n\t\tbaseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t}\r\n\tif ((bool)ply)\r\n\t{\r\n\t\tply.net.SwitchSecondaryGroup(null);\r\n\t\tply.SetRcEntityPosition(null);\r\n\t}\r\n\tcurrentlyControllingEnt.uid = default(NetworkableId);\r\n\tcurrentPlayerID = 0uL;\r\n\tSetFlag(BaseEntity.Flags.Reserved2, b: false, recursive: false, networkupdate: false);\r\n\tSendNetworkUpdate();\r\n\tSendControlBookmarks(ply);\r\n\tCancelInvoke(ControlCheck);\r\n\tCancelInvoke(CheckCCTVAchievement);\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "StopControl",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnBookmarkControlEnded",
    "fullName": "OnBookmarkControlEnded [2]",
    "category": "Bookmark",
    "parameters": [
      {
        "name": "computerStation",
        "type": "ComputerStation, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local6",
        "type": "IRemoteControllable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void BeginControllingBookmark(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!IsPlayerAdmin(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String();\r\n\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\r\n\tif (remoteControllable == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity ent = remoteControllable.GetEnt();\r\n\tif (ent == null)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"RC identifier \" + text + \" was found but has a null or destroyed entity, this should never happen\");\r\n\t}\r\n\telse if (remoteControllable.CanControl(player.userID) && !(UnityEngine.Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange))\r\n\t{\r\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.GetComponent<IRemoteControllable>()?.StopControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t\t}\r\n\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\r\n\t\tplayer.SetRcEntityPosition(ent.transform.position);\r\n\t\tcurrentlyControllingEnt.uid = ent.net.ID;\r\n\t\tcurrentPlayerID = player.userID;\r\n\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t\tSetFlag(BaseEntity.Flags.Reserved2, b, recursive: false, networkupdate: false);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tSendControlBookmarks(player);\r\n\t\tif (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)\r\n\t\t{\r\n\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\r\n\t\t}\r\n\t\tInvokeRepeating(ControlCheck, 0f, 0f);\r\n\t}\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "BeginControllingBookmark",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnBookmarkControlEnded [2] [patch]",
    "fullName": "OnBookmarkControlEnded [2] [patch]",
    "category": "Bookmark",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void BeginControllingBookmark(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!IsPlayerAdmin(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String();\r\n\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\r\n\tif (remoteControllable == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity ent = remoteControllable.GetEnt();\r\n\tif (ent == null)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"RC identifier \" + text + \" was found but has a null or destroyed entity, this should never happen\");\r\n\t}\r\n\telse if (remoteControllable.CanControl(player.userID) && !(UnityEngine.Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange))\r\n\t{\r\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.GetComponent<IRemoteControllable>()?.StopControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t\t}\r\n\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\r\n\t\tplayer.SetRcEntityPosition(ent.transform.position);\r\n\t\tcurrentlyControllingEnt.uid = ent.net.ID;\r\n\t\tcurrentPlayerID = player.userID;\r\n\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\r\n\t\tSetFlag(BaseEntity.Flags.Reserved2, b, recursive: false, networkupdate: false);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tSendControlBookmarks(player);\r\n\t\tif (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)\r\n\t\t{\r\n\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\r\n\t\t}\r\n\t\tInvokeRepeating(ControlCheck, 0f, 0f);\r\n\t}\r\n}\r\n",
    "targetName": "ComputerStation",
    "methodName": "BeginControllingBookmark",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnClanMemberAdded",
    "fullName": "OnClanMemberAdded",
    "category": "Clan",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool AcceptInvite(long clanId, ulong steamId)\r\n{\r\n\tBeginTransaction();\r\n\ttry\r\n\t{\r\n\t\tif (DeleteInvite(clanId, steamId) && CreateMember(clanId, steamId))\r\n\t\t{\r\n\t\t\tCommit();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tRollback();\r\n\t\treturn false;\r\n\t}\r\n\tcatch\r\n\t{\r\n\t\tRollback();\r\n\t\tthrow;\r\n\t}\r\n}\r\n",
    "targetName": "LocalClanDatabase",
    "methodName": "AcceptInvite",
    "assemblyName": "Rust.Clans.Local",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanRecycle",
    "fullName": "CanRecycle",
    "category": "Crafting",
    "parameters": [
      {
        "name": "recycler",
        "type": "Recycler, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool HasRecyclable()\r\n{\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tItem slot = base.inventory.GetSlot(i);\r\n\t\tif (slot != null && slot.info.Blueprint != null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "Recycler",
    "methodName": "HasRecyclable",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeRecycled",
    "fullName": "CanBeRecycled",
    "category": "Crafting",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "recycler",
        "type": "Recycler, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanBeRecycled(Item item)\r\n{\r\n\tif (item != null)\r\n\t{\r\n\t\treturn item.info.Blueprint != null;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "Recycler",
    "methodName": "CanBeRecycled",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanCraft",
    "fullName": "CanCraft [ItemCrafter]",
    "category": "Crafting",
    "parameters": [
      {
        "name": "itemCrafter",
        "type": "ItemCrafter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)\r\n{\r\n\tif (!bp.targetItem.IsAllowedInEra(Rust.EraRestriction.Craft))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (base.baseEntity != null && base.baseEntity.IsRestrained)\r\n\t{\r\n\t\tHandcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();\r\n\t\tif (restraintItem != null && restraintItem.BlockCrafting)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\tfloat num = (float)amount / (float)bp.targetItem.craftingStackable;\r\n\tforeach (ItemCraftTask item in queue)\r\n\t{\r\n\t\tif (!item.cancelled)\r\n\t\t{\r\n\t\t\tnum += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;\r\n\t\t}\r\n\t}\r\n\tif (num > 8f)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (amount < 1 || amount > bp.targetItem.craftingStackable)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tforeach (ItemAmount ingredient in bp.GetIngredients())\r\n\t{\r\n\t\tif (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (ingredient.itemDef.condition.enabled && !DoesHaveOKConditionItem(ingredient.itemid, (int)ingredient.amount * amount))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "ItemCrafter",
    "methodName": "CanCraft",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnIngredientsCollect",
    "fullName": "OnIngredientsCollect",
    "category": "Crafting",
    "parameters": [
      {
        "name": "itemCrafter",
        "type": "ItemCrafter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null)\r\n{\r\n\tSystem.Collections.Generic.List<Item> list = new System.Collections.Generic.List<Item>();\r\n\tforeach (ItemAmount ingredient in bp.GetIngredients())\r\n\t{\r\n\t\tCollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list);\r\n\t}\r\n\tforeach (Item item in list)\r\n\t{\r\n\t\titem.CollectedForCrafting(player);\r\n\t}\r\n\ttask.takenItems = list;\r\n}\r\n",
    "targetName": "ItemCrafter",
    "methodName": "CollectIngredients",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanCraft",
    "fullName": "CanCraft [PlayerBlueprints]",
    "category": "Crafting",
    "parameters": [
      {
        "name": "playerBlueprints",
        "type": "PlayerBlueprints, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "skinItemId",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanCraft(int itemid, int skinItemId, ulong playerId)\r\n{\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemid);\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (skinItemId != 0 && !base.baseEntity.UnlockAllSkins && !CheckSkinOwnership(skinItemId, playerId))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (base.baseEntity.currentCraftLevel < (float)itemDefinition.Blueprint.GetWorkbenchLevel())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (HasUnlocked(itemDefinition))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "PlayerBlueprints",
    "methodName": "CanCraft",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEntityReskin",
    "fullName": "OnEntityReskin",
    "category": "Crafting",
    "parameters": [
      {
        "name": "local3",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local7",
        "type": "ItemSkinDirectory+Skin, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\n[BaseEntity.RPC_Server.CallsPerSecond(2uL)]\r\npublic void ChangeItemSkin(BaseEntity.RPCMessage msg)\r\n{\r\n\tNetworkableId uid = msg.read.EntityID();\r\n\tint targetSkin = msg.read.Int32();\r\n\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\r\n\tif (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (baseNetworkable != null)\r\n\t{\r\n\t\tBaseEntity baseEntity2 = baseNetworkable as BaseEntity;\r\n\t\tif ((object)baseEntity2 != null)\r\n\t\t{\r\n\t\t\tif (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))\r\n\t\t\t{\r\n\t\t\t\tFailResponse(SprayCan.SprayFailReason.InvalidItem);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tItemDefinition itemDefinition = null;\r\n\t\t\tulong num = ItemDefinition.FindSkin((def.isRedirectOf != null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);\r\n\t\t\tItemSkinDirectory.Skin skin = System.Linq.Enumerable.FirstOrDefault(((def.isRedirectOf != null) ? def.isRedirectOf : def).skins, (ItemSkinDirectory.Skin x) => x.id == targetSkin);\r\n\t\t\tif (skin.invItem != null && skin.invItem is ItemSkin itemSkin)\r\n\t\t\t{\r\n\t\t\t\tif (itemSkin.Redirect != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titemDefinition = itemSkin.Redirect;\r\n\t\t\t\t}\r\n\t\t\t\telse if ((bool)def && def.isRedirectOf != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titemDefinition = def.isRedirectOf;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (def.isRedirectOf != null || ((bool)def && def.isRedirectOf != null))\r\n\t\t\t{\r\n\t\t\t\titemDefinition = def.isRedirectOf;\r\n\t\t\t}\r\n\t\t\tif (itemDefinition == null)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity2.skinID = num;\r\n\t\t\t\tbaseEntity2.SendNetworkUpdate();\r\n\t\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (!CanEntityBeRespawned(baseEntity2, out var reason2))\r\n\t\t\t\t{\r\n\t\t\t\t\tFailResponse(reason2);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (!GetEntityPrefabPath(itemDefinition, out var resourcePath))\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\"Cannot find resource path of redirect entity to spawn! \" + itemDefinition.gameObject.name);\r\n\t\t\t\t\tFailResponse(SprayCan.SprayFailReason.InvalidItem);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tUnityEngine.Vector3 localPosition = baseEntity2.transform.localPosition;\r\n\t\t\t\tUnityEngine.Quaternion localRotation = baseEntity2.transform.localRotation;\r\n\t\t\t\tBaseEntity baseEntity3 = baseEntity2.GetParentEntity();\r\n\t\t\t\tfloat health = baseEntity2.Health();\r\n\t\t\t\tEntityRef[] slots = baseEntity2.GetSlots();\r\n\t\t\t\tulong ownerID = baseEntity2.OwnerID;\r\n\t\t\t\tfloat lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);\r\n\t\t\t\tint soilSaturation = ((baseEntity2 is PlanterBox planterBox) ? planterBox.soilSaturation : 0);\r\n\t\t\t\tSystem.Collections.Generic.HashSet<ProtoBuf.PlayerNameID> hashSet = null;\r\n\t\t\t\tif (baseEntity2 is BuildingPrivlidge buildingPrivlidge)\r\n\t\t\t\t{\r\n\t\t\t\t\thashSet = new System.Collections.Generic.HashSet<ProtoBuf.PlayerNameID>(buildingPrivlidge.authorizedPlayers);\r\n\t\t\t\t}\r\n\t\t\t\tbool flag = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge || baseEntity2 is BoxStorage || baseEntity2 is PlanterBox;\r\n\t\t\t\tSystem.Collections.Generic.Dictionary<SprayCan.ContainerSet, System.Collections.Generic.List<Item>> dictionary2 = new System.Collections.Generic.Dictionary<SprayCan.ContainerSet, System.Collections.Generic.List<Item>>();\r\n\t\t\t\tSaveEntityStorage(baseEntity2, dictionary2, 0);\r\n\t\t\t\tSystem.Collections.Generic.List<SprayCan.ChildPreserveInfo> obj = Facepunch.Pool.Get<System.Collections.Generic.List<SprayCan.ChildPreserveInfo>>();\r\n\t\t\t\tif (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (BaseEntity child in baseEntity2.children)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tobj.Add(new SprayCan.ChildPreserveInfo\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tTargetEntity = child,\r\n\t\t\t\t\t\t\tTargetBone = child.parentBone,\r\n\t\t\t\t\t\t\tLocalPosition = child.transform.localPosition,\r\n\t\t\t\t\t\t\tLocalRotation = child.transform.localRotation\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tforeach (SprayCan.ChildPreserveInfo item in obj)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem.TargetEntity.SetParent(null, worldPositionStays: true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int i = 0; i < baseEntity2.children.Count; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSaveEntityStorage(baseEntity2.children[i], dictionary2, -1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tSprayCan.IOPreserveInfo[] array = null;\r\n\t\t\t\tSprayCan.IOPreserveInfo[] array2 = null;\r\n\t\t\t\tSystem.Collections.Generic.List<SprayCan.OtherEntityPreserveInfo> list = new System.Collections.Generic.List<SprayCan.OtherEntityPreserveInfo>();\r\n\t\t\t\tif (baseEntity2 is IOEntity iOEntity)\r\n\t\t\t\t{\r\n\t\t\t\t\tarray = new SprayCan.IOPreserveInfo[iOEntity.outputs.Length];\r\n\t\t\t\t\tfor (int j = 0; j < iOEntity.outputs.Length; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tIOEntity.IOSlot iOSlot = iOEntity.outputs[j];\r\n\t\t\t\t\t\tIOEntity iOEntity2 = iOSlot.connectedTo.Get();\r\n\t\t\t\t\t\tif (iOEntity2 != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tiOSlot.Preserve(ref array[j]);\r\n\t\t\t\t\t\t\tSprayCan.IOPreserveInfo target = default(SprayCan.IOPreserveInfo);\r\n\t\t\t\t\t\t\tiOEntity2.inputs[iOSlot.connectedToSlot].Preserve(ref target);\r\n\t\t\t\t\t\t\tlist.Add(new SprayCan.OtherEntityPreserveInfo\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tinfo = target,\r\n\t\t\t\t\t\t\t\tconnectedEntity = iOEntity2,\r\n\t\t\t\t\t\t\t\tindex = iOSlot.connectedToSlot,\r\n\t\t\t\t\t\t\t\tisOutput = false\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tarray2 = new SprayCan.IOPreserveInfo[iOEntity.inputs.Length];\r\n\t\t\t\t\tfor (int k = 0; k < iOEntity.inputs.Length; k++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tIOEntity.IOSlot iOSlot2 = iOEntity.inputs[k];\r\n\t\t\t\t\t\tIOEntity iOEntity3 = iOSlot2.connectedTo.Get();\r\n\t\t\t\t\t\tif (iOEntity3 != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tiOSlot2.Preserve(ref array2[k]);\r\n\t\t\t\t\t\t\tSprayCan.IOPreserveInfo target2 = default(SprayCan.IOPreserveInfo);\r\n\t\t\t\t\t\t\tiOEntity3.outputs[iOSlot2.connectedToSlot].Preserve(ref target2);\r\n\t\t\t\t\t\t\tlist.Add(new SprayCan.OtherEntityPreserveInfo\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tinfo = target2,\r\n\t\t\t\t\t\t\t\tconnectedEntity = iOEntity3,\r\n\t\t\t\t\t\t\t\tindex = iOSlot2.connectedToSlot,\r\n\t\t\t\t\t\t\t\tisOutput = true\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbaseEntity2.Kill();\r\n\t\t\t\tbaseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);\r\n\t\t\t\tbaseEntity2.SetParent(baseEntity3);\r\n\t\t\t\tbaseEntity2.transform.localPosition = localPosition;\r\n\t\t\t\tbaseEntity2.transform.localRotation = localRotation;\r\n\t\t\t\tbaseEntity2.OwnerID = ownerID;\r\n\t\t\t\tif (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tbaseEntity2.skinID = 0uL;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbaseEntity2.skinID = num;\r\n\t\t\t\t}\r\n\t\t\t\tif (baseEntity2 is DecayEntity decayEntity)\r\n\t\t\t\t{\r\n\t\t\t\t\tdecayEntity.AttachToBuilding(null);\r\n\t\t\t\t}\r\n\t\t\t\tif (baseEntity2 is PlanterBox planterBox2)\r\n\t\t\t\t{\r\n\t\t\t\t\tplanterBox2.soilSaturation = soilSaturation;\r\n\t\t\t\t}\r\n\t\t\t\tbaseEntity2.Spawn();\r\n\t\t\t\tif (baseEntity2 is IOEntity iOEntity4)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (array != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int l = 0; l < iOEntity4.outputs.Length; l++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tiOEntity4.outputs[l].Restore(array[l]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (array2 != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int m = 0; m < iOEntity4.inputs.Length; m++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (array2[m].connectedTo != null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tiOEntity4.inputs[m].Restore(array2[m]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tusing PooledList<IOEntity> pooledList = Facepunch.Pool.Get<PooledList<IOEntity>>();\r\n\t\t\t\t\tforeach (SprayCan.OtherEntityPreserveInfo item2 in list)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSprayCan.IOPreserveInfo info = item2.info;\r\n\t\t\t\t\t\tinfo.connectedTo = iOEntity4;\r\n\t\t\t\t\t\tif (item2.connectedEntity != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (item2.isOutput)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\titem2.connectedEntity.outputs[item2.index].Restore(info);\r\n\t\t\t\t\t\t\t\tpooledList.Add(item2.connectedEntity);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\titem2.connectedEntity.inputs[item2.index].Restore(info);\r\n\t\t\t\t\t\t\t\tpooledList.Add(item2.connectedEntity);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tforeach (IOEntity item3 in pooledList)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem3.SendNetworkUpdate();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (baseEntity2 is BaseCombatEntity baseCombatEntity2)\r\n\t\t\t\t{\r\n\t\t\t\t\tbaseCombatEntity2.SetHealth(health);\r\n\t\t\t\t\tbaseCombatEntity2.lastAttackedTime = lastAttackedTime;\r\n\t\t\t\t}\r\n\t\t\t\tif (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuildingPrivlidge2.authorizedPlayers = hashSet;\r\n\t\t\t\t}\r\n\t\t\t\tif (dictionary2.Count > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tRestoreEntityStorage(baseEntity2, 0, dictionary2);\r\n\t\t\t\t\tif (!flag)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int n = 0; n < baseEntity2.children.Count; n++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tRestoreEntityStorage(baseEntity2.children[n], -1, dictionary2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tforeach (System.Collections.Generic.KeyValuePair<SprayCan.ContainerSet, System.Collections.Generic.List<Item>> item4 in dictionary2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tforeach (Item item5 in item4.Value)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tUnityEngine.Debug.Log($\"Deleting {item5} as it has no new container\");\r\n\t\t\t\t\t\t\titem5.Remove();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);\r\n\t\t\t\t}\r\n\t\t\t\tif (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (SprayCan.ChildPreserveInfo item6 in obj)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem6.TargetEntity.SetParent(baseEntity2, item6.TargetBone, worldPositionStays: true);\r\n\t\t\t\t\t\titem6.TargetEntity.transform.localPosition = item6.LocalPosition;\r\n\t\t\t\t\t\titem6.TargetEntity.transform.localRotation = item6.LocalRotation;\r\n\t\t\t\t\t\titem6.TargetEntity.SendNetworkUpdate();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbaseEntity2.SetSlots(slots);\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\t\t}\r\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_ReskinResult\"), 1, baseEntity2.net.ID);\r\n\t\t}\r\n\t}\r\n\tLoseCondition(ConditionLossPerReskin);\r\n\tClientRPC(RpcTarget.NetworkGroup(\"Client_ChangeSprayColour\"), -1);\r\n\tSetFlag(BaseEntity.Flags.Busy, b: true);\r\n\tInvoke(ClearBusy, SprayCooldown);\r\n\tvoid FailResponse(SprayCan.SprayFailReason reason)\r\n\t{\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_ReskinResult\"), 0, (int)reason);\r\n\t}\r\n\tstatic void RestoreEntityStorage(BaseEntity baseEntity, int index, System.Collections.Generic.Dictionary<SprayCan.ContainerSet, System.Collections.Generic.List<Item>> copy)\r\n\t{\r\n\t\tif (baseEntity is IItemContainerEntity itemContainerEntity2)\r\n\t\t{\r\n\t\t\tSprayCan.ContainerSet containerSet2 = default(SprayCan.ContainerSet);\r\n\t\t\tcontainerSet2.ContainerIndex = index;\r\n\t\t\tcontainerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\r\n\t\t\tSprayCan.ContainerSet key2 = containerSet2;\r\n\t\t\tif (copy.ContainsKey(key2))\r\n\t\t\t{\r\n\t\t\t\tforeach (Item item7 in copy[key2])\r\n\t\t\t\t{\r\n\t\t\t\t\titem7.MoveToContainer(itemContainerEntity2.inventory);\r\n\t\t\t\t}\r\n\t\t\t\tcopy.Remove(key2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tstatic void SaveEntityStorage(BaseEntity baseEntity, System.Collections.Generic.Dictionary<SprayCan.ContainerSet, System.Collections.Generic.List<Item>> dictionary, int index)\r\n\t{\r\n\t\tif (baseEntity is IItemContainerEntity itemContainerEntity)\r\n\t\t{\r\n\t\t\tSprayCan.ContainerSet containerSet = default(SprayCan.ContainerSet);\r\n\t\t\tcontainerSet.ContainerIndex = index;\r\n\t\t\tcontainerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\r\n\t\t\tSprayCan.ContainerSet key = containerSet;\r\n\t\t\tif (!dictionary.ContainsKey(key))\r\n\t\t\t{\r\n\t\t\t\tdictionary.Add(key, new System.Collections.Generic.List<Item>());\r\n\t\t\t\tforeach (Item item8 in itemContainerEntity.inventory.itemList)\r\n\t\t\t\t{\r\n\t\t\t\t\tdictionary[key].Add(item8);\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (Item item9 in dictionary[key])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem9.RemoveFromContainer();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tUnityEngine.Debug.Log(\"Multiple containers with the same prefab id being added during vehicle reskin\");\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "SprayCan",
    "methodName": "ChangeItemSkin",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityReskinned",
    "fullName": "OnEntityReskinned",
    "category": "Crafting",
    "parameters": [
      {
        "name": "local3",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local7",
        "type": "ItemSkinDirectory+Skin, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\n[BaseEntity.RPC_Server.CallsPerSecond(2uL)]\r\npublic void ChangeItemSkin(BaseEntity.RPCMessage msg)\r\n{\r\n\tNetworkableId uid = msg.read.EntityID();\r\n\tint targetSkin = msg.read.Int32();\r\n\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\r\n\tif (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (baseNetworkable != null)\r\n\t{\r\n\t\tBaseEntity baseEntity2 = baseNetworkable as BaseEntity;\r\n\t\tif ((object)baseEntity2 != null)\r\n\t\t{\r\n\t\t\tif (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))\r\n\t\t\t{\r\n\t\t\t\tFailResponse(SprayCan.SprayFailReason.InvalidItem);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tItemDefinition itemDefinition = null;\r\n\t\t\tulong num = ItemDefinition.FindSkin((def.isRedirectOf != null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);\r\n\t\t\tItemSkinDirectory.Skin skin = System.Linq.Enumerable.FirstOrDefault(((def.isRedirectOf != null) ? def.isRedirectOf : def).skins, (ItemSkinDirectory.Skin x) => x.id == targetSkin);\r\n\t\t\tif (skin.invItem != null && skin.invItem is ItemSkin itemSkin)\r\n\t\t\t{\r\n\t\t\t\tif (itemSkin.Redirect != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titemDefinition = itemSkin.Redirect;\r\n\t\t\t\t}\r\n\t\t\t\telse if ((bool)def && def.isRedirectOf != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titemDefinition = def.isRedirectOf;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (def.isRedirectOf != null || ((bool)def && def.isRedirectOf != null))\r\n\t\t\t{\r\n\t\t\t\titemDefinition = def.isRedirectOf;\r\n\t\t\t}\r\n\t\t\tif (itemDefinition == null)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity2.skinID = num;\r\n\t\t\t\tbaseEntity2.SendNetworkUpdate();\r\n\t\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (!CanEntityBeRespawned(baseEntity2, out var reason2))\r\n\t\t\t\t{\r\n\t\t\t\t\tFailResponse(reason2);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (!GetEntityPrefabPath(itemDefinition, out var resourcePath))\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\"Cannot find resource path of redirect entity to spawn! \" + itemDefinition.gameObject.name);\r\n\t\t\t\t\tFailResponse(SprayCan.SprayFailReason.InvalidItem);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tUnityEngine.Vector3 localPosition = baseEntity2.transform.localPosition;\r\n\t\t\t\tUnityEngine.Quaternion localRotation = baseEntity2.transform.localRotation;\r\n\t\t\t\tBaseEntity baseEntity3 = baseEntity2.GetParentEntity();\r\n\t\t\t\tfloat health = baseEntity2.Health();\r\n\t\t\t\tEntityRef[] slots = baseEntity2.GetSlots();\r\n\t\t\t\tulong ownerID = baseEntity2.OwnerID;\r\n\t\t\t\tfloat lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);\r\n\t\t\t\tint soilSaturation = ((baseEntity2 is PlanterBox planterBox) ? planterBox.soilSaturation : 0);\r\n\t\t\t\tSystem.Collections.Generic.HashSet<ProtoBuf.PlayerNameID> hashSet = null;\r\n\t\t\t\tif (baseEntity2 is BuildingPrivlidge buildingPrivlidge)\r\n\t\t\t\t{\r\n\t\t\t\t\thashSet = new System.Collections.Generic.HashSet<ProtoBuf.PlayerNameID>(buildingPrivlidge.authorizedPlayers);\r\n\t\t\t\t}\r\n\t\t\t\tbool flag = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge || baseEntity2 is BoxStorage || baseEntity2 is PlanterBox;\r\n\t\t\t\tSystem.Collections.Generic.Dictionary<SprayCan.ContainerSet, System.Collections.Generic.List<Item>> dictionary2 = new System.Collections.Generic.Dictionary<SprayCan.ContainerSet, System.Collections.Generic.List<Item>>();\r\n\t\t\t\tSaveEntityStorage(baseEntity2, dictionary2, 0);\r\n\t\t\t\tSystem.Collections.Generic.List<SprayCan.ChildPreserveInfo> obj = Facepunch.Pool.Get<System.Collections.Generic.List<SprayCan.ChildPreserveInfo>>();\r\n\t\t\t\tif (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (BaseEntity child in baseEntity2.children)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tobj.Add(new SprayCan.ChildPreserveInfo\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tTargetEntity = child,\r\n\t\t\t\t\t\t\tTargetBone = child.parentBone,\r\n\t\t\t\t\t\t\tLocalPosition = child.transform.localPosition,\r\n\t\t\t\t\t\t\tLocalRotation = child.transform.localRotation\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tforeach (SprayCan.ChildPreserveInfo item in obj)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem.TargetEntity.SetParent(null, worldPositionStays: true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int i = 0; i < baseEntity2.children.Count; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSaveEntityStorage(baseEntity2.children[i], dictionary2, -1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tSprayCan.IOPreserveInfo[] array = null;\r\n\t\t\t\tSprayCan.IOPreserveInfo[] array2 = null;\r\n\t\t\t\tSystem.Collections.Generic.List<SprayCan.OtherEntityPreserveInfo> list = new System.Collections.Generic.List<SprayCan.OtherEntityPreserveInfo>();\r\n\t\t\t\tif (baseEntity2 is IOEntity iOEntity)\r\n\t\t\t\t{\r\n\t\t\t\t\tarray = new SprayCan.IOPreserveInfo[iOEntity.outputs.Length];\r\n\t\t\t\t\tfor (int j = 0; j < iOEntity.outputs.Length; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tIOEntity.IOSlot iOSlot = iOEntity.outputs[j];\r\n\t\t\t\t\t\tIOEntity iOEntity2 = iOSlot.connectedTo.Get();\r\n\t\t\t\t\t\tif (iOEntity2 != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tiOSlot.Preserve(ref array[j]);\r\n\t\t\t\t\t\t\tSprayCan.IOPreserveInfo target = default(SprayCan.IOPreserveInfo);\r\n\t\t\t\t\t\t\tiOEntity2.inputs[iOSlot.connectedToSlot].Preserve(ref target);\r\n\t\t\t\t\t\t\tlist.Add(new SprayCan.OtherEntityPreserveInfo\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tinfo = target,\r\n\t\t\t\t\t\t\t\tconnectedEntity = iOEntity2,\r\n\t\t\t\t\t\t\t\tindex = iOSlot.connectedToSlot,\r\n\t\t\t\t\t\t\t\tisOutput = false\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tarray2 = new SprayCan.IOPreserveInfo[iOEntity.inputs.Length];\r\n\t\t\t\t\tfor (int k = 0; k < iOEntity.inputs.Length; k++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tIOEntity.IOSlot iOSlot2 = iOEntity.inputs[k];\r\n\t\t\t\t\t\tIOEntity iOEntity3 = iOSlot2.connectedTo.Get();\r\n\t\t\t\t\t\tif (iOEntity3 != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tiOSlot2.Preserve(ref array2[k]);\r\n\t\t\t\t\t\t\tSprayCan.IOPreserveInfo target2 = default(SprayCan.IOPreserveInfo);\r\n\t\t\t\t\t\t\tiOEntity3.outputs[iOSlot2.connectedToSlot].Preserve(ref target2);\r\n\t\t\t\t\t\t\tlist.Add(new SprayCan.OtherEntityPreserveInfo\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tinfo = target2,\r\n\t\t\t\t\t\t\t\tconnectedEntity = iOEntity3,\r\n\t\t\t\t\t\t\t\tindex = iOSlot2.connectedToSlot,\r\n\t\t\t\t\t\t\t\tisOutput = true\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbaseEntity2.Kill();\r\n\t\t\t\tbaseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);\r\n\t\t\t\tbaseEntity2.SetParent(baseEntity3);\r\n\t\t\t\tbaseEntity2.transform.localPosition = localPosition;\r\n\t\t\t\tbaseEntity2.transform.localRotation = localRotation;\r\n\t\t\t\tbaseEntity2.OwnerID = ownerID;\r\n\t\t\t\tif (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tbaseEntity2.skinID = 0uL;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbaseEntity2.skinID = num;\r\n\t\t\t\t}\r\n\t\t\t\tif (baseEntity2 is DecayEntity decayEntity)\r\n\t\t\t\t{\r\n\t\t\t\t\tdecayEntity.AttachToBuilding(null);\r\n\t\t\t\t}\r\n\t\t\t\tif (baseEntity2 is PlanterBox planterBox2)\r\n\t\t\t\t{\r\n\t\t\t\t\tplanterBox2.soilSaturation = soilSaturation;\r\n\t\t\t\t}\r\n\t\t\t\tbaseEntity2.Spawn();\r\n\t\t\t\tif (baseEntity2 is IOEntity iOEntity4)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (array != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int l = 0; l < iOEntity4.outputs.Length; l++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tiOEntity4.outputs[l].Restore(array[l]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (array2 != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int m = 0; m < iOEntity4.inputs.Length; m++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (array2[m].connectedTo != null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tiOEntity4.inputs[m].Restore(array2[m]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tusing PooledList<IOEntity> pooledList = Facepunch.Pool.Get<PooledList<IOEntity>>();\r\n\t\t\t\t\tforeach (SprayCan.OtherEntityPreserveInfo item2 in list)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSprayCan.IOPreserveInfo info = item2.info;\r\n\t\t\t\t\t\tinfo.connectedTo = iOEntity4;\r\n\t\t\t\t\t\tif (item2.connectedEntity != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (item2.isOutput)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\titem2.connectedEntity.outputs[item2.index].Restore(info);\r\n\t\t\t\t\t\t\t\tpooledList.Add(item2.connectedEntity);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\titem2.connectedEntity.inputs[item2.index].Restore(info);\r\n\t\t\t\t\t\t\t\tpooledList.Add(item2.connectedEntity);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tforeach (IOEntity item3 in pooledList)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem3.SendNetworkUpdate();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (baseEntity2 is BaseCombatEntity baseCombatEntity2)\r\n\t\t\t\t{\r\n\t\t\t\t\tbaseCombatEntity2.SetHealth(health);\r\n\t\t\t\t\tbaseCombatEntity2.lastAttackedTime = lastAttackedTime;\r\n\t\t\t\t}\r\n\t\t\t\tif (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuildingPrivlidge2.authorizedPlayers = hashSet;\r\n\t\t\t\t}\r\n\t\t\t\tif (dictionary2.Count > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tRestoreEntityStorage(baseEntity2, 0, dictionary2);\r\n\t\t\t\t\tif (!flag)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int n = 0; n < baseEntity2.children.Count; n++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tRestoreEntityStorage(baseEntity2.children[n], -1, dictionary2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tforeach (System.Collections.Generic.KeyValuePair<SprayCan.ContainerSet, System.Collections.Generic.List<Item>> item4 in dictionary2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tforeach (Item item5 in item4.Value)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tUnityEngine.Debug.Log($\"Deleting {item5} as it has no new container\");\r\n\t\t\t\t\t\t\titem5.Remove();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);\r\n\t\t\t\t}\r\n\t\t\t\tif (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (SprayCan.ChildPreserveInfo item6 in obj)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem6.TargetEntity.SetParent(baseEntity2, item6.TargetBone, worldPositionStays: true);\r\n\t\t\t\t\t\titem6.TargetEntity.transform.localPosition = item6.LocalPosition;\r\n\t\t\t\t\t\titem6.TargetEntity.transform.localRotation = item6.LocalRotation;\r\n\t\t\t\t\t\titem6.TargetEntity.SendNetworkUpdate();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbaseEntity2.SetSlots(slots);\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\t\t}\r\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_ReskinResult\"), 1, baseEntity2.net.ID);\r\n\t\t}\r\n\t}\r\n\tLoseCondition(ConditionLossPerReskin);\r\n\tClientRPC(RpcTarget.NetworkGroup(\"Client_ChangeSprayColour\"), -1);\r\n\tSetFlag(BaseEntity.Flags.Busy, b: true);\r\n\tInvoke(ClearBusy, SprayCooldown);\r\n\tvoid FailResponse(SprayCan.SprayFailReason reason)\r\n\t{\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_ReskinResult\"), 0, (int)reason);\r\n\t}\r\n\tstatic void RestoreEntityStorage(BaseEntity baseEntity, int index, System.Collections.Generic.Dictionary<SprayCan.ContainerSet, System.Collections.Generic.List<Item>> copy)\r\n\t{\r\n\t\tif (baseEntity is IItemContainerEntity itemContainerEntity2)\r\n\t\t{\r\n\t\t\tSprayCan.ContainerSet containerSet2 = default(SprayCan.ContainerSet);\r\n\t\t\tcontainerSet2.ContainerIndex = index;\r\n\t\t\tcontainerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\r\n\t\t\tSprayCan.ContainerSet key2 = containerSet2;\r\n\t\t\tif (copy.ContainsKey(key2))\r\n\t\t\t{\r\n\t\t\t\tforeach (Item item7 in copy[key2])\r\n\t\t\t\t{\r\n\t\t\t\t\titem7.MoveToContainer(itemContainerEntity2.inventory);\r\n\t\t\t\t}\r\n\t\t\t\tcopy.Remove(key2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tstatic void SaveEntityStorage(BaseEntity baseEntity, System.Collections.Generic.Dictionary<SprayCan.ContainerSet, System.Collections.Generic.List<Item>> dictionary, int index)\r\n\t{\r\n\t\tif (baseEntity is IItemContainerEntity itemContainerEntity)\r\n\t\t{\r\n\t\t\tSprayCan.ContainerSet containerSet = default(SprayCan.ContainerSet);\r\n\t\t\tcontainerSet.ContainerIndex = index;\r\n\t\t\tcontainerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\r\n\t\t\tSprayCan.ContainerSet key = containerSet;\r\n\t\t\tif (!dictionary.ContainsKey(key))\r\n\t\t\t{\r\n\t\t\t\tdictionary.Add(key, new System.Collections.Generic.List<Item>());\r\n\t\t\t\tforeach (Item item8 in itemContainerEntity.inventory.itemList)\r\n\t\t\t\t{\r\n\t\t\t\t\tdictionary[key].Add(item8);\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (Item item9 in dictionary[key])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem9.RemoveFromContainer();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tUnityEngine.Debug.Log(\"Multiple containers with the same prefab id being added during vehicle reskin\");\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "SprayCan",
    "methodName": "ChangeItemSkin",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSprayCreate",
    "fullName": "OnSprayCreate",
    "category": "Crafting",
    "parameters": [
      {
        "name": "sprayCan",
        "type": "SprayCan, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local5",
        "type": "UnityEngine.Quaternion, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void CreateSpray(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (IsBusy())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tClientRPC(RpcTarget.NetworkGroup(\"Client_ChangeSprayColour\"), -1);\r\n\tSetFlag(BaseEntity.Flags.Busy, b: true);\r\n\tInvoke(ClearBusy, SprayCooldown);\r\n\tUnityEngine.Vector3 vector = msg.read.Vector3();\r\n\tUnityEngine.Vector3 vector2 = msg.read.Vector3();\r\n\tUnityEngine.Vector3 point = msg.read.Vector3();\r\n\tint num = msg.read.Int32();\r\n\tif (!(UnityEngine.Vector3.Distance(vector, base.transform.position) > 4.5f))\r\n\t{\r\n\t\tUnityEngine.Quaternion rot = UnityEngine.Quaternion.LookRotation((new UnityEngine.Plane(vector2, vector).ClosestPointOnPlane(point) - vector).normalized, vector2);\r\n\t\trot *= UnityEngine.Quaternion.Euler(0f, 0f, 90f);\r\n\t\tbool flag = false;\r\n\t\tif (msg.player.IsDeveloper)\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t}\r\n\t\tif (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.Log($\"SprayCan.ChangeItemSkin player does not have item :{num}:\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, vector, rot);\r\n\t\tbaseEntity.skinID = num2;\r\n\t\tbaseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());\r\n\t\tbaseEntity.Spawn();\r\n\t\tCheckAchievementPosition(vector);\r\n\t\tLoseCondition(ConditionLossPerSpray);\r\n\t}\r\n}\r\n",
    "targetName": "SprayCan",
    "methodName": "CreateSpray",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnOutputUpdate",
    "fullName": "OnOutputUpdate",
    "category": "Electronic",
    "parameters": [
      {
        "name": "iOEntity",
        "type": "IOEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void UpdateOutputs()\r\n{\r\n\tif (!ShouldUpdateOutputs() || !ensureOutputsUpdated)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tensureOutputsUpdated = false;\r\n\tusing (TimeWarning.New(\"ProcessIOOutputs\"))\r\n\t{\r\n\t\tfor (int i = 0; i < outputs.Length; i++)\r\n\t\t{\r\n\t\t\tIOEntity.IOSlot iOSlot = outputs[i];\r\n\t\t\tbool flag = true;\r\n\t\t\tIOEntity iOEntity = iOSlot.connectedTo.Get();\r\n\t\t\tif (!(iOEntity != null))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (ioType == IOEntity.IOType.Fluidic && !DisregardGravityRestrictionsOnLiquid && !iOEntity.DisregardGravityRestrictionsOnLiquid)\r\n\t\t\t{\r\n\t\t\t\tusing (TimeWarning.New(\"FluidOutputProcessing\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!iOEntity.AllowLiquidPassthrough(this, base.transform.TransformPoint(iOSlot.handlePosition)))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tflag = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint passthroughAmount = GetPassthroughAmount(i);\r\n\t\t\tiOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "IOEntity",
    "methodName": "UpdateOutputs",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnInputUpdate",
    "fullName": "OnInputUpdate",
    "category": "Electronic",
    "parameters": [
      {
        "name": "iOEntity",
        "type": "IOEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void UpdateFromInput(int inputAmount, int inputSlot)\r\n{\r\n\tif (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOEntity.IOType.Industrial)\r\n\t{\r\n\t\tIOStateChanged(inputAmount, inputSlot);\r\n\t\treturn;\r\n\t}\r\n\tUpdateHasPower(inputAmount, inputSlot);\r\n\tlastEnergy = currentEnergy;\r\n\tcurrentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);\r\n\tint num = GetPassthroughAmount();\r\n\tif (infiniteIoPower && GetQueueType() == IOEntity.QueueType.ElectricLowPriority)\r\n\t{\r\n\t\tnum = 999;\r\n\t}\r\n\tbool flag = lastPassthroughEnergy != num;\r\n\tlastPassthroughEnergy = num;\r\n\tif (currentEnergy != lastEnergy || flag)\r\n\t{\r\n\t\tIOStateChanged(inputAmount, inputSlot);\r\n\t\tensureOutputsUpdated = true;\r\n\t}\r\n\t_processQueues[GetQueueType()].Enqueue(this);\r\n}\r\n",
    "targetName": "IOEntity",
    "methodName": "UpdateFromInput",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCardSwipe",
    "fullName": "OnCardSwipe",
    "category": "Electronic",
    "parameters": [
      {
        "name": "cardReader",
        "type": "CardReader, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Keycard, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ServerCardSwiped(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!IsPowered() || UnityEngine.Vector3Ex.Distance2D(msg.player.transform.position, base.transform.position) > 1f || IsInvoking(GrantCard) || IsInvoking(FailCard) || HasFlag(BaseEntity.Flags.On))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetworkableId uid = msg.read.EntityID();\r\n\tKeycard keycard = BaseNetworkable.serverEntities.Find(uid) as Keycard;\r\n\tEffect.server.Run(swipeEffect.resourcePath, audioPosition.position, UnityEngine.Vector3.up, msg.player.net.connection);\r\n\tif (keycard == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem item = keycard.GetItem();\r\n\tif (item != null && !(item.parent.playerOwner != msg.player))\r\n\t{\r\n\t\tif (keycard.accessLevel == accessLevel && item.conditionNormalized > 0f)\r\n\t\t{\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnKeycardSwiped(msg.player, this);\r\n\t\t\tInvoke(GrantCard, 0.5f);\r\n\t\t\titem.LoseCondition(1f);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tInvoke(FailCard, 0.5f);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "CardReader",
    "methodName": "ServerCardSwiped",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDigitalClockRing",
    "fullName": "OnDigitalClockRing",
    "category": "Electronic",
    "parameters": [
      {
        "name": "digitalClock",
        "type": "DigitalClock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Ring()\r\n{\r\n\tisRinging = true;\r\n\tClientRPC(RpcTarget.NetworkGroup(\"RPC_StartRinging\"));\r\n\tInvoke(StopRinging, 5f);\r\n\tMarkDirty();\r\n}\r\n",
    "targetName": "DigitalClock",
    "methodName": "Ring",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDigitalClockRingStop",
    "fullName": "OnDigitalClockRingStop",
    "category": "Electronic",
    "parameters": [
      {
        "name": "digitalClock",
        "type": "DigitalClock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StopRinging()\r\n{\r\n\tisRinging = false;\r\n\tClientRPC(RpcTarget.NetworkGroup(\"RPC_StopRinging\"));\r\n\tMarkDirty();\r\n}\r\n",
    "targetName": "DigitalClock",
    "methodName": "StopRinging",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDigitalClockAlarmsSet",
    "fullName": "OnDigitalClockAlarmsSet",
    "category": "Electronic",
    "parameters": [
      {
        "name": "digitalClock",
        "type": "DigitalClock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ProtoBuf.DigitalClockMessage, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void RPC_SetAlarms(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!CanPlayerAdmin(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.DigitalClockMessage digitalClockMessage = ProtoBuf.DigitalClockMessage.Deserialize(msg.read);\r\n\tSystem.Collections.Generic.List<ProtoBuf.DigitalClockAlarm> list = digitalClockMessage.alarms;\r\n\talarms.Clear();\r\n\tforeach (ProtoBuf.DigitalClockAlarm item2 in list)\r\n\t{\r\n\t\tDigitalClock.Alarm item = new DigitalClock.Alarm(item2.time.ToTimeSpan(), item2.active);\r\n\t\talarms.Add(item);\r\n\t}\r\n\tmuted = digitalClockMessage.muted;\r\n\tMarkDirty();\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "DigitalClock",
    "methodName": "RPC_SetAlarms",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnButtonPress",
    "fullName": "OnButtonPress",
    "category": "Electronic",
    "parameters": [
      {
        "name": "pressButton",
        "type": "PressButton, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Press(BaseEntity.RPCMessage msg)\r\n{\r\n\tPress();\r\n}\r\n",
    "targetName": "PressButton",
    "methodName": "RPC_Press",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPhoneNameUpdate",
    "fullName": "OnPhoneNameUpdate",
    "category": "Electronic",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdatePhoneName(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!(msg.player != currentPlayer))\r\n\t{\r\n\t\tstring text = msg.read.String();\r\n\t\tif (text.Length > 30)\r\n\t\t{\r\n\t\t\ttext = text.Substring(0, 30);\r\n\t\t}\r\n\t\tPhoneName = text;\r\n\t\tbase.baseEntity.SendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "UpdatePhoneName",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPhoneNameUpdated",
    "fullName": "OnPhoneNameUpdated",
    "category": "Electronic",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdatePhoneName(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!(msg.player != currentPlayer))\r\n\t{\r\n\t\tstring text = msg.read.String();\r\n\t\tif (text.Length > 30)\r\n\t\t{\r\n\t\t\ttext = text.Substring(0, 30);\r\n\t\t}\r\n\t\tPhoneName = text;\r\n\t\tbase.baseEntity.SendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "UpdatePhoneName",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSolarPanelSunUpdate",
    "fullName": "OnSolarPanelSunUpdate",
    "category": "Electronic",
    "parameters": [
      {
        "name": "solarPanel",
        "type": "SolarPanel, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SunUpdate()\r\n{\r\n\tint num = currentEnergy;\r\n\tif (TOD_Sky.Instance.IsNight)\r\n\t{\r\n\t\tnum = 0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tUnityEngine.Vector3 sunDirection = TOD_Sky.Instance.SunDirection;\r\n\t\tfloat value = UnityEngine.Vector3.Dot(sunSampler.forward, sunDirection);\r\n\t\tfloat num2 = UnityEngine.Mathf.InverseLerp(dot_minimum, dot_maximum, value);\r\n\t\tif (num2 > 0f && !IsVisible(sunSampler.position + sunDirection * 100f, 101f))\r\n\t\t{\r\n\t\t\tnum2 = 0f;\r\n\t\t}\r\n\t\tnum = UnityEngine.Mathf.FloorToInt((float)maximalPowerOutput * num2 * base.healthFraction);\r\n\t}\r\n\tbool num3 = currentEnergy != num;\r\n\tcurrentEnergy = num;\r\n\tif (num3)\r\n\t{\r\n\t\tMarkDirty();\r\n\t}\r\n}\r\n",
    "targetName": "SolarPanel",
    "methodName": "SunUpdate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityControl",
    "fullName": "OnEntityControl [AutoTurret]",
    "category": "Electronic",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tif (booting)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (IsPowered())\r\n\t{\r\n\t\treturn !PeacekeeperMode();\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "CanControl",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEntityControl",
    "fullName": "OnEntityControl [PoweredRemoteControl]",
    "category": "Electronic",
    "parameters": [
      {
        "name": "poweredRemoteControlEntity",
        "type": "PoweredRemoteControlEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tif (!IsPowered())\r\n\t{\r\n\t\treturn IsStatic();\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "PoweredRemoteControlEntity",
    "methodName": "CanControl",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEntityControl",
    "fullName": "OnEntityControl [RemoteControlEntity]",
    "category": "Electronic",
    "parameters": [
      {
        "name": "remoteControlEntity",
        "type": "RemoteControlEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\treturn true;\r\n}\r\n",
    "targetName": "RemoteControlEntity",
    "methodName": "CanControl",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnIORefCleared",
    "fullName": "OnIORefCleared",
    "category": "Electronic",
    "parameters": [
      {
        "name": "iORef",
        "type": "IOEntity+IORef, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "IOEntity+IORef",
    "methodName": "Clear",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnIORefCleared [patch]",
    "fullName": "OnIORefCleared [patch]",
    "category": "Electronic",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "IOEntity+IORef",
    "methodName": "Clear",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCCTVDirectionChange",
    "fullName": "OnCCTVDirectionChange",
    "category": "Electronic",
    "parameters": [
      {
        "name": "cCTV_RC",
        "type": "CCTV_RC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void Server_SetDir(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!IsStatic())\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (player.CanBuild() && player.IsBuildingAuthed())\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 direction = UnityEngine.Vector3Ex.Direction(player.eyes.position, yaw.transform.position);\r\n\t\t\tdirection = base.transform.InverseTransformDirection(direction);\r\n\t\t\tUnityEngine.Vector3 vector = BaseMountable.ConvertVector(UnityEngine.Quaternion.LookRotation(direction).eulerAngles);\r\n\t\t\tpitchAmount = UnityEngine.Mathf.Clamp(vector.x, pitchClamp.x, pitchClamp.y);\r\n\t\t\tyawAmount = UnityEngine.Mathf.Clamp(vector.y, yawClamp.x, yawClamp.y);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "CCTV_RC",
    "methodName": "Server_SetDir",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnExcavatorSuppliesRequest",
    "fullName": "OnExcavatorSuppliesRequest",
    "category": "Electronic",
    "parameters": [
      {
        "name": "excavatorSignalComputer",
        "type": "ExcavatorSignalComputer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void RequestSupplies(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (HasFlag(BaseEntity.Flags.Reserved7) && IsPowered() && chargePower >= chargeNeededForSupplies)\r\n\t{\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(supplyPlanePrefab.resourcePath);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 position = dropPoints[UnityEngine.Random.Range(0, dropPoints.Length)].position;\r\n\t\t\tUnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-3f, 3f), 0f, UnityEngine.Random.Range(-3f, 3f));\r\n\t\t\tbaseEntity.SendMessage(\"InitDropPosition\", position + vector, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t\tchargePower -= chargeNeededForSupplies;\r\n\t\tSetFlag(BaseEntity.Flags.Reserved7, b: false);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "ExcavatorSignalComputer",
    "methodName": "RequestSupplies",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnExcavatorSuppliesRequested",
    "fullName": "OnExcavatorSuppliesRequested",
    "category": "Electronic",
    "parameters": [
      {
        "name": "excavatorSignalComputer",
        "type": "ExcavatorSignalComputer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void RequestSupplies(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (HasFlag(BaseEntity.Flags.Reserved7) && IsPowered() && chargePower >= chargeNeededForSupplies)\r\n\t{\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(supplyPlanePrefab.resourcePath);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 position = dropPoints[UnityEngine.Random.Range(0, dropPoints.Length)].position;\r\n\t\t\tUnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-3f, 3f), 0f, UnityEngine.Random.Range(-3f, 3f));\r\n\t\t\tbaseEntity.SendMessage(\"InitDropPosition\", position + vector, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t\tchargePower -= chargeNeededForSupplies;\r\n\t\tSetFlag(BaseEntity.Flags.Reserved7, b: false);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "ExcavatorSignalComputer",
    "methodName": "RequestSupplies",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSensorDetect",
    "fullName": "OnSensorDetect",
    "category": "Electronic",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdatePassthroughAmount()\r\n{\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = detectedPlayers;\r\n\tdetectedPlayers = 0;\r\n\tif (myTrigger.entityContents != null && myTrigger.entityContents.Count > 0)\r\n\t{\r\n\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\r\n\t\tforeach (BaseEntity entityContent in myTrigger.entityContents)\r\n\t\t{\r\n\t\t\tif (entityContent is BasePlayer basePlayer)\r\n\t\t\t{\r\n\t\t\t\tbool flag = buildingPrivilege != null && buildingPrivilege.IsAuthed(basePlayer);\r\n\t\t\t\tif ((!flag || ShouldIncludeAuthorized()) && (flag || ShouldIncludeOthers()) && entityContent.IsVisible(base.transform.position + base.transform.forward * 0.1f, 10f) && basePlayer != null && basePlayer.IsAlive() && !basePlayer.IsSleeping() && basePlayer.isServer)\r\n\t\t\t\t{\r\n\t\t\t\t\tdetectedPlayers++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (num != detectedPlayers && IsPowered())\r\n\t{\r\n\t\tMarkDirty();\r\n\t\tif (detectedPlayers > num)\r\n\t\t{\r\n\t\t\tEffect.server.Run(detectUp.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\telse if (detectedPlayers < num)\r\n\t\t{\r\n\t\t\tEffect.server.Run(detectDown.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "HBHFSensor",
    "methodName": "UpdatePassthroughAmount",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCounterTargetChange",
    "fullName": "OnCounterTargetChange",
    "category": "Electronic",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_SetTarget(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (CanPlayerAdmin(msg.player))\r\n\t{\r\n\t\ttargetCounterNumber = msg.read.Int32();\r\n\t\tMarkDirty();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "PowerCounter",
    "methodName": "SERVER_SetTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCounterTargetChange [patch]",
    "fullName": "OnCounterTargetChange [patch]",
    "category": "Electronic",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_SetTarget(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (CanPlayerAdmin(msg.player))\r\n\t{\r\n\t\ttargetCounterNumber = msg.read.Int32();\r\n\t\tMarkDirty();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "PowerCounter",
    "methodName": "SERVER_SetTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCounterModeToggle",
    "fullName": "OnCounterModeToggle",
    "category": "Electronic",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ToggleDisplayMode(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanBuild())\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Reserved2, msg.read.Bit(), recursive: false, networkupdate: false);\r\n\t\tMarkDirty();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "PowerCounter",
    "methodName": "ToggleDisplayMode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCounterModeToggle [patch]",
    "fullName": "OnCounterModeToggle [patch]",
    "category": "Electronic",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ToggleDisplayMode(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanBuild())\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Reserved2, msg.read.Bit(), recursive: false, networkupdate: false);\r\n\t\tMarkDirty();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "PowerCounter",
    "methodName": "ToggleDisplayMode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLiftUse",
    "fullName": "OnLiftUse",
    "category": "Elevator",
    "parameters": [
      {
        "name": "lift",
        "type": "Lift, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_UseLift(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract())\r\n\t{\r\n\t\tMoveUp();\r\n\t}\r\n}\r\n",
    "targetName": "Lift",
    "methodName": "RPC_UseLift",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLiftUse",
    "fullName": "OnLiftUse [ProceduralLift]",
    "category": "Elevator",
    "parameters": [
      {
        "name": "proceduralLift",
        "type": "ProceduralLift, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_UseLift(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && !IsBusy())\r\n\t{\r\n\t\tMoveToFloor((floorIndex + 1) % stops.Length);\r\n\t}\r\n}\r\n",
    "targetName": "ProceduralLift",
    "methodName": "RPC_UseLift",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnElevatorCall",
    "fullName": "OnElevatorCall",
    "category": "Elevator",
    "parameters": [
      {
        "name": "elevator",
        "type": "Elevator, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "elevatorEnt",
        "type": "Elevator, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[System.Runtime.CompilerServices.CompilerGenerated]\r\npublic void <CallElevator>b__26_0(Elevator elevatorEnt)\r\n{\r\n\tif (elevatorEnt.IsTop)\r\n\t{\r\n\t\televatorEnt.RequestMoveLiftTo(Floor, out var _, this);\r\n\t}\r\n}\r\n",
    "targetName": "Elevator",
    "methodName": "<CallElevator>b__26_0",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnElevatorMove",
    "fullName": "OnElevatorMove",
    "category": "Elevator",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)\r\n{\r\n\ttimeToTravel = 0f;\r\n\tif (IsBusy())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!IsStatic && ioEntity != null && !ioEntity.IsPowered())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!IsValidFloor(targetFloor))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tint num = LiftPositionToFloor();\r\n\tif (num == targetFloor)\r\n\t{\r\n\t\tOpenDoorsAtFloor(num);\r\n\t\treturn false;\r\n\t}\r\n\tif (!liftEntity.IsValid(base.isServer))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tElevatorLift elevatorLift = liftEntity.Get(base.isServer);\r\n\tif (!elevatorLift.CanMove())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tUnityEngine.Vector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);\r\n\tif (!GamePhysics.LineOfSight(elevatorLift.transform.position, worldSpaceFloorPosition, 2097152))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tOnMoveBegin();\r\n\ttimeToTravel = TimeToTravelDistance(UnityEngine.Mathf.Abs(elevatorLift.transform.position.y - worldSpaceFloorPosition.y));\r\n\tLeanTween.moveY(elevatorLift.gameObject, worldSpaceFloorPosition.y, timeToTravel).delay = LiftMoveDelay;\r\n\ttimeToTravel += LiftMoveDelay;\r\n\tSetFlag(BaseEntity.Flags.Busy, b: true);\r\n\tif (targetFloor < Floor)\r\n\t{\r\n\t\televatorLift.ToggleHurtTrigger(state: true);\r\n\t}\r\n\televatorLift.SetFlag(BaseEntity.Flags.Busy, b: true);\r\n\tInvoke(ClearBusy, timeToTravel + 1f);\r\n\televatorLift.NotifyNewFloor(targetFloor, Floor);\r\n\tEntityLinkBroadcast(delegate(Elevator elevatorEnt)\r\n\t{\r\n\t\televatorEnt.SetFlag(BaseEntity.Flags.Busy, b: true);\r\n\t}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);\r\n\tif (ioEntity != null)\r\n\t{\r\n\t\tioEntity.SetFlag(BaseEntity.Flags.Busy, b: true);\r\n\t\tioEntity.SendChangedToRoot(forceUpdate: true);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "Elevator",
    "methodName": "RequestMoveLiftTo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanElevatorLiftMove",
    "fullName": "CanElevatorLiftMove",
    "category": "Elevator",
    "parameters": [
      {
        "name": "elevatorLift",
        "type": "ElevatorLift, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanMove()\r\n{\r\n\tif (VehicleTrigger.HasContents && VehicleTrigger.entityContents != null)\r\n\t{\r\n\t\tforeach (BaseEntity entityContent in VehicleTrigger.entityContents)\r\n\t\t{\r\n\t\t\tif (!vehiclePrefabWhitelist.Contains(entityContent.prefabID))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "ElevatorLift",
    "methodName": "CanMove",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnElevatorButtonPress",
    "fullName": "OnElevatorButtonPress",
    "category": "Elevator",
    "parameters": [
      {
        "name": "elevatorLift",
        "type": "ElevatorLift, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Elevator+Direction, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void Server_RaiseLowerFloor(BaseEntity.RPCMessage msg)\r\n{\r\n\tElevator.Direction direction = (Elevator.Direction)msg.read.Int32();\r\n\tbool flag = msg.read.Bit();\r\n\tSetFlag((direction == Elevator.Direction.Up) ? BaseEntity.Flags.Reserved1 : BaseEntity.Flags.Reserved2, b: true);\r\n\tSetFlag(BaseEntity.Flags.Reserved6, flag);\r\n\towner.Server_RaiseLowerElevator(direction, flag);\r\n\tInvoke(ClearDirection, 0.7f);\r\n\tif (liftButtonPressedEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(liftButtonPressedEffect.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t}\r\n}\r\n",
    "targetName": "ElevatorLift",
    "methodName": "Server_RaiseLowerFloor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntitySpawned",
    "fullName": "OnEntitySpawned",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseNetworkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void Spawn()\r\n{\r\n\tFacepunch.Rust.Profiling.EntityProfiler.spawned++;\r\n\tif (Facepunch.Rust.Profiling.EntityProfiler.mode >= 2)\r\n\t{\r\n\t\tFacepunch.Rust.Profiling.EntityProfiler.OnSpawned(this);\r\n\t}\r\n\tSpawnShared();\r\n\tif (net == null)\r\n\t{\r\n\t\tnet = Network.Net.sv.CreateNetworkable();\r\n\t}\r\n\tcreationFrame = UnityEngine.Time.frameCount;\r\n\tPreInitShared();\r\n\tInitShared();\r\n\tServerInit();\r\n\tPostInitShared();\r\n\tUpdateNetworkGroup();\r\n\tServerInitPostNetworkGroupAssign();\r\n\tisSpawned = true;\r\n\tSendNetworkUpdateImmediate(justCreated: true);\r\n\tInvoke(SendGlobalNetworkUpdate, 0f);\r\n\tif (Rust.Application.isLoading && !Rust.Application.isLoadingSave)\r\n\t{\r\n\t\tbase.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);\r\n\t}\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "Spawn",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityKill",
    "fullName": "OnEntityKill",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseNetworkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Kill(BaseNetworkable.DestroyMode mode = BaseNetworkable.DestroyMode.None)\r\n{\r\n\tif (IsDestroyed)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Calling kill - but already IsDestroyed!? \" + this);\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Profiling.EntityProfiler.killed++;\r\n\tif (Facepunch.Rust.Profiling.EntityProfiler.mode >= 2)\r\n\t{\r\n\t\tFacepunch.Rust.Profiling.EntityProfiler.OnKilled(this);\r\n\t}\r\n\tbase.gameObject.BroadcastOnParentDestroying();\r\n\tOnKilled();\r\n\tDoEntityDestroy();\r\n\tTerminateOnClient(mode);\r\n\tTerminateOnServer();\r\n\tEntityDestroy();\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "Kill",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "IOnEntitySaved",
    "fullName": "IOnEntitySaved",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseNetworkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "saveInfo",
        "type": "BaseNetworkable+SaveInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ToStream(System.IO.Stream stream, BaseNetworkable.SaveInfo saveInfo)\r\n{\r\n\tusing (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())\r\n\t{\r\n\t\tSave(saveInfo);\r\n\t\tif (saveInfo.msg.baseEntity == null)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(this?.ToString() + \": ToStream - no BaseEntity!?\");\r\n\t\t}\r\n\t\tif (saveInfo.msg.baseNetworkable == null)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(this?.ToString() + \": ToStream - no baseNetworkable!?\");\r\n\t\t}\r\n\t\tsaveInfo.msg.ToProto(stream);\r\n\t\tPostSave(saveInfo);\r\n\t}\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "ToStream",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntitySnapshot",
    "fullName": "OnEntitySnapshot",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseNetworkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "connection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendAsSnapshot(Network.Connection connection, bool justCreated = false)\r\n{\r\n\tNetwork.NetWrite netWrite = Network.Net.sv.StartWrite();\r\n\tconnection.validate.entityUpdates++;\r\n\tBaseNetworkable.SaveInfo saveInfo = default(BaseNetworkable.SaveInfo);\r\n\tsaveInfo.forConnection = connection;\r\n\tsaveInfo.forDisk = false;\r\n\tBaseNetworkable.SaveInfo saveInfo2 = saveInfo;\r\n\tnetWrite.PacketID(Network.Message.Type.Entities);\r\n\tnetWrite.UInt32(connection.validate.entityUpdates);\r\n\tToStreamForNetwork(netWrite, saveInfo2);\r\n\tnetWrite.Send(new Network.SendInfo(connection));\r\n\tif (Network.DemoConVars.ServerDemosEnabled)\r\n\t{\r\n\t\tlastDemoIndex = Network.Net.sv.serverDemos.DemoCount;\r\n\t}\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "SendAsSnapshot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityLoaded",
    "fullName": "OnEntityLoaded",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseNetworkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void Load(BaseNetworkable.LoadInfo info)\r\n{\r\n\tif (info.msg.baseNetworkable != null)\r\n\t{\r\n\t\tProtoBuf.BaseNetworkable baseNetworkable = info.msg.baseNetworkable;\r\n\t\tif (prefabID != baseNetworkable.prefabID)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(\"Prefab IDs don't match! \" + prefabID + \"/\" + baseNetworkable.prefabID + \" -> \" + base.gameObject, base.gameObject);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "Load",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityEnter",
    "fullName": "OnEntityEnter",
    "category": "Entity",
    "parameters": [
      {
        "name": "triggerBase",
        "type": "TriggerBase, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnEntityEnter(BaseEntity ent)\r\n{\r\n\tif (!(ent == null))\r\n\t{\r\n\t\tif (entityContents == null)\r\n\t\t{\r\n\t\t\tentityContents = new System.Collections.Generic.HashSet<BaseEntity>();\r\n\t\t}\r\n\t\tentityContents.Add(ent);\r\n\t\tOnEntityEnterTrigger?.Invoke(ent);\r\n\t}\r\n}\r\n",
    "targetName": "TriggerBase",
    "methodName": "OnEntityEnter",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityLeave",
    "fullName": "OnEntityLeave",
    "category": "Entity",
    "parameters": [
      {
        "name": "triggerBase",
        "type": "TriggerBase, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnEntityLeave(BaseEntity ent)\r\n{\r\n\tif (entityContents != null)\r\n\t{\r\n\t\tentityContents.Remove(ent);\r\n\t\tOnEntityLeaveTrigger?.Invoke(ent);\r\n\t}\r\n}\r\n",
    "targetName": "TriggerBase",
    "methodName": "OnEntityLeave",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "IOnBaseCombatEntityHurt",
    "fullName": "IOnBaseCombatEntityHurt",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseCombatEntity",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Hurt(float amount)\r\n{\r\n\tHurt(UnityEngine.Mathf.Abs(amount), Rust.DamageType.Generic);\r\n}\r\n",
    "targetName": "BaseCombatEntity",
    "methodName": "Hurt",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityMarkHostile",
    "fullName": "OnEntityMarkHostile",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseCombatEntity",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void MarkHostileFor(float duration = 60f)\r\n{\r\n\tfloat b = UnityEngine.Time.realtimeSinceStartup + duration;\r\n\tunHostileTime = UnityEngine.Mathf.Max(unHostileTime, b);\r\n}\r\n",
    "targetName": "BaseCombatEntity",
    "methodName": "MarkHostileFor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanEntityBeHostile",
    "fullName": "CanEntityBeHostile",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseCombatEntity",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool IsHostile()\r\n{\r\n\treturn unHostileTime > UnityEngine.Time.realtimeSinceStartup;\r\n}\r\n",
    "targetName": "BaseCombatEntity",
    "methodName": "IsHostile",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEntityDeath",
    "fullName": "OnEntityDeath [BaseCombatEntity]",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseCombatEntity",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void Die(HitInfo info = null)\r\n{\r\n\tif (IsDead())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tLogEntry(RustLog.EntryType.Combat, 2, \"died\");\r\n\thealth = 0f;\r\n\tlifestate = BaseCombatEntity.LifeState.Dead;\r\n\tif (info != null && (bool)info.InitiatorPlayer)\r\n\t{\r\n\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\r\n\t\tif (initiatorPlayer != null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)\r\n\t\t{\r\n\t\t\tinitiatorPlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, prefabID, 1f);\r\n\t\t}\r\n\t}\r\n\tusing (TimeWarning.New(\"OnDied\"))\r\n\t{\r\n\t\tOnDied(info);\r\n\t}\r\n}\r\n",
    "targetName": "BaseCombatEntity",
    "methodName": "Die",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityPickedUp",
    "fullName": "OnEntityPickedUp",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseCombatEntity",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnPickedUp(Item createdItem, BasePlayer player)\r\n{\r\n}\r\n",
    "targetName": "BaseCombatEntity",
    "methodName": "OnPickedUp",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityGroundMissing",
    "fullName": "OnEntityGroundMissing",
    "category": "Entity",
    "parameters": [
      {
        "name": "local0",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnGroundMissing()\r\n{\r\n\tBaseEntity baseEntity = UnityEngine.GameObjectEx.ToBaseEntity(base.gameObject);\r\n\tif (baseEntity != null)\r\n\t{\r\n\t\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\r\n\t\tif (baseCombatEntity != null)\r\n\t\t{\r\n\t\t\tbaseCombatEntity.Die();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "DestroyOnGroundMissing",
    "methodName": "OnGroundMissing",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnAirdrop",
    "fullName": "OnAirdrop",
    "category": "Entity",
    "parameters": [
      {
        "name": "cargoPlane",
        "type": "CargoPlane, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateDropPosition(UnityEngine.Vector3 newDropPosition)\r\n{\r\n\tfloat x = TerrainMeta.Size.x;\r\n\tfloat y = TerrainMeta.HighestPoint.y + 250f;\r\n\tstartPos = UnityEngine.Vector3Ex.Range(-1f, 1f);\r\n\tstartPos.y = 0f;\r\n\tstartPos.Normalize();\r\n\tstartPos *= x * 2f;\r\n\tstartPos.y = y;\r\n\tendPos = startPos * -1f;\r\n\tendPos.y = startPos.y;\r\n\tstartPos += newDropPosition;\r\n\tendPos += newDropPosition;\r\n\tsecondsToTake = UnityEngine.Vector3.Distance(startPos, endPos) / 50f;\r\n\tsecondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);\r\n\tbase.transform.position = startPos;\r\n\tbase.transform.rotation = UnityEngine.Quaternion.LookRotation(endPos - startPos);\r\n\tdropPosition = newDropPosition;\r\n}\r\n",
    "targetName": "CargoPlane",
    "methodName": "UpdateDropPosition",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSupplyDropDropped",
    "fullName": "OnSupplyDropDropped",
    "category": "Entity",
    "parameters": [
      {
        "name": "local1",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "cargoPlane",
        "type": "CargoPlane, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Update()\r\n{\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tsecondsTaken += UnityEngine.Time.deltaTime;\r\n\tfloat num = UnityEngine.Mathf.InverseLerp(0f, secondsToTake, secondsTaken);\r\n\tif (!dropped && num >= 0.5f)\r\n\t{\r\n\t\tdropped = true;\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t}\r\n\tbase.transform.position = UnityEngine.Vector3.Lerp(startPos, endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n\tif (num >= 1f)\r\n\t{\r\n\t\tKill();\r\n\t}\r\n}\r\n",
    "targetName": "CargoPlane",
    "methodName": "Update",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnOvenToggle",
    "fullName": "OnOvenToggle",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseOven",
        "type": "BaseOven, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic virtual void SVSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == IsOn() || (needsBuildingPrivilegeToUse && !msg.player.CanBuild()))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tStartCooking();\r\n\t\tif (msg.player != null)\r\n\t\t{\r\n\t\t\tmsg.player.ProcessMissionEvent(BaseMission.MissionEventType.STARTOVEN, new BaseMission.MissionEventPayload\r\n\t\t\t{\r\n\t\t\t\tUintIdentifier = prefabID,\r\n\t\t\t\tNetworkIdentifier = net.ID\r\n\t\t\t}, 1f);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tStopCooking();\r\n\t}\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "SVSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnOvenCook",
    "fullName": "OnOvenCook",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseOven",
        "type": "BaseOven, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Cook()\r\n{\r\n\tif (HasFlag(BaseEntity.Flags.Reserved8))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem item = FindBurnable();\r\n\tif (item == null && !CanRunWithNoFuel)\r\n\t{\r\n\t\tStopCooking();\r\n\t\treturn;\r\n\t}\r\n\tforeach (Item item2 in base.inventory.itemList)\r\n\t{\r\n\t\tif (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))\r\n\t\t{\r\n\t\t\titem2.SetFlag(Item.Flag.Cooking, b: true);\r\n\t\t\titem2.MarkDirty();\r\n\t\t}\r\n\t}\r\n\tIncreaseCookTime(0.5f * GetSmeltingSpeed());\r\n\tBaseEntity slot = GetSlot(BaseEntity.Slot.FireMod);\r\n\tif ((bool)slot)\r\n\t{\r\n\t\tslot.SendMessage(\"Cook\", 0.5f, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t}\r\n\tif (item != null)\r\n\t{\r\n\t\tItemModBurnable itemModBurnable = item.info.ItemModBurnable;\r\n\t\titem.fuel -= 0.5f * (cookingTemperature / 200f);\r\n\t\tif (!item.HasFlag(Item.Flag.OnFire))\r\n\t\t{\r\n\t\t\titem.SetFlag(Item.Flag.OnFire, b: true);\r\n\t\t\titem.MarkDirty();\r\n\t\t}\r\n\t\tif (item.fuel <= 0f)\r\n\t\t{\r\n\t\t\tConsumeFuel(item, itemModBurnable);\r\n\t\t}\r\n\t}\r\n\tOnCooked();\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "Cook",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnOvenCooked",
    "fullName": "OnOvenCooked",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseOven",
        "type": "BaseOven, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Cook()\r\n{\r\n\tif (HasFlag(BaseEntity.Flags.Reserved8))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem item = FindBurnable();\r\n\tif (item == null && !CanRunWithNoFuel)\r\n\t{\r\n\t\tStopCooking();\r\n\t\treturn;\r\n\t}\r\n\tforeach (Item item2 in base.inventory.itemList)\r\n\t{\r\n\t\tif (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))\r\n\t\t{\r\n\t\t\titem2.SetFlag(Item.Flag.Cooking, b: true);\r\n\t\t\titem2.MarkDirty();\r\n\t\t}\r\n\t}\r\n\tIncreaseCookTime(0.5f * GetSmeltingSpeed());\r\n\tBaseEntity slot = GetSlot(BaseEntity.Slot.FireMod);\r\n\tif ((bool)slot)\r\n\t{\r\n\t\tslot.SendMessage(\"Cook\", 0.5f, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t}\r\n\tif (item != null)\r\n\t{\r\n\t\tItemModBurnable itemModBurnable = item.info.ItemModBurnable;\r\n\t\titem.fuel -= 0.5f * (cookingTemperature / 200f);\r\n\t\tif (!item.HasFlag(Item.Flag.OnFire))\r\n\t\t{\r\n\t\t\titem.SetFlag(Item.Flag.OnFire, b: true);\r\n\t\t\titem.MarkDirty();\r\n\t\t}\r\n\t\tif (item.fuel <= 0f)\r\n\t\t{\r\n\t\t\tConsumeFuel(item, itemModBurnable);\r\n\t\t}\r\n\t}\r\n\tOnCooked();\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "Cook",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnOvenStart",
    "fullName": "OnOvenStart",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseOven",
        "type": "BaseOven, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void StartCooking()\r\n{\r\n\tif (FindBurnable() != null || CanRunWithNoFuel)\r\n\t{\r\n\t\tbase.inventory.temperature = cookingTemperature;\r\n\t\tUpdateAttachmentTemperature();\r\n\t\tInvokeRepeating(Cook, 0.5f, 0.5f);\r\n\t\tif (visualFood)\r\n\t\t{\r\n\t\t\tInvokeRepeating(CookVisuals, 0f, 0.05f);\r\n\t\t}\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\tif (hasOpenFlame)\r\n\t\t{\r\n\t\t\tSingletonComponent<NpcFireManager>.Instance.Add(this);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "StartCooking",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnOvenStarted",
    "fullName": "OnOvenStarted",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseOven",
        "type": "BaseOven, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void StartCooking()\r\n{\r\n\tif (FindBurnable() != null || CanRunWithNoFuel)\r\n\t{\r\n\t\tbase.inventory.temperature = cookingTemperature;\r\n\t\tUpdateAttachmentTemperature();\r\n\t\tInvokeRepeating(Cook, 0.5f, 0.5f);\r\n\t\tif (visualFood)\r\n\t\t{\r\n\t\t\tInvokeRepeating(CookVisuals, 0f, 0.05f);\r\n\t\t}\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\tif (hasOpenFlame)\r\n\t\t{\r\n\t\t\tSingletonComponent<NpcFireManager>.Instance.Add(this);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "StartCooking",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnOvenTemperature",
    "fullName": "OnOvenTemperature",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseOven",
        "type": "BaseOven, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public float GetTemperature(int slot)\r\n{\r\n\tif (!HasFlag(BaseEntity.Flags.On))\r\n\t{\r\n\t\treturn 15f;\r\n\t}\r\n\treturn cookingTemperature;\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "GetTemperature",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Single"
  },
  {
    "name": "OnRecyclerToggle",
    "fullName": "OnRecyclerToggle",
    "category": "Entity",
    "parameters": [
      {
        "name": "recycler",
        "type": "Recycler, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void SVSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == IsOn() || msg.player == null || (!flag && onlyOneUser && msg.player.inventory.loot.entitySource != this) || (flag && !HasRecyclable()))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tforeach (Item item in base.inventory.itemList)\r\n\t\t{\r\n\t\t\titem.CollectedForCrafting(msg.player);\r\n\t\t}\r\n\t\tStartRecycling();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tStopRecycling();\r\n\t}\r\n}\r\n",
    "targetName": "Recycler",
    "methodName": "SVSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnContainerDropItems",
    "fullName": "OnContainerDropItems",
    "category": "Entity",
    "parameters": [
      {
        "name": "container",
        "type": "ItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void DropItems(ItemContainer container, UnityEngine.Vector3 position)\r\n{\r\n\tif (!ConVar.Server.dropitems || container == null || container.itemList == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 0.25f;\r\n\tItem[] array = container.itemList.ToArray();\r\n\tforeach (Item item in array)\r\n\t{\r\n\t\tfloat num2 = UnityEngine.Random.Range(0f, 2f);\r\n\t\titem.RemoveFromContainer();\r\n\t\tBaseEntity baseEntity = item.CreateWorldObject(position + new UnityEngine.Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));\r\n\t\tif (baseEntity == null)\r\n\t\t{\r\n\t\t\titem.Remove();\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (baseEntity is DroppedItem droppedItem && container.entityOwner is LootContainer)\r\n\t\t{\r\n\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;\r\n\t\t}\r\n\t\tif (num2 > 0f)\r\n\t\t{\r\n\t\t\tbaseEntity.SetVelocity(new UnityEngine.Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);\r\n\t\t\tbaseEntity.SetAngularVelocity(new UnityEngine.Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "DropUtil",
    "methodName": "DropItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityDismounted",
    "fullName": "OnEntityDismounted",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseMountable",
        "type": "BaseMountable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DismountPlayer(BasePlayer player, bool lite = false)\r\n{\r\n\tif (_mounted == null || _mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseVehicle baseVehicle = VehicleParent();\r\n\tif (lite)\r\n\t{\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PrePlayerDismount(player, this);\r\n\t\t}\r\n\t\t_mounted.DismountObject();\r\n\t\t_mounted = null;\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t\t}\r\n\t\tOnPlayerDismounted(player);\r\n\t\treturn;\r\n\t}\r\n\tif (!GetDismountPosition(player, out var res) || Distance(res) > 10f)\r\n\t{\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PrePlayerDismount(player, this);\r\n\t\t}\r\n\t\tres = player.transform.position;\r\n\t\t_mounted.DismountObject();\r\n\t\t_mounted.MovePosition(res);\r\n\t\t_mounted.transform.rotation = UnityEngine.Quaternion.identity;\r\n\t\t_mounted.ClientRPC(RpcTarget.Player(\"ForcePositionTo\", _mounted), res);\r\n\t\tBasePlayer mounted = _mounted;\r\n\t\t_mounted = null;\r\n\t\tUnityEngine.Debug.LogWarning(\"Killing player due to invalid dismount point :\" + player.displayName + \" / \" + player.userID.Get() + \" on obj : \" + base.gameObject.name);\r\n\t\tmounted.Hurt(1000f, Rust.DamageType.Suicide, mounted, useProtection: false);\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t\t}\r\n\t\tOnPlayerDismounted(player);\r\n\t\treturn;\r\n\t}\r\n\tif (baseVehicle != null)\r\n\t{\r\n\t\tbaseVehicle.PrePlayerDismount(player, this);\r\n\t}\r\n\tif (AntiHack.TestNoClipping(_mounted, res, res, _mounted.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _, vehicleLayer: true))\r\n\t{\r\n\t\t_mounted.PauseVehicleNoClipDetection(5f);\r\n\t}\r\n\t_mounted.DismountObject();\r\n\t_mounted.transform.rotation = UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3.forward, UnityEngine.Vector3.up);\r\n\t_mounted.OverrideViewAngles(UnityEngine.Vector3.zero);\r\n\t_mounted.MovePosition(res);\r\n\t_mounted.SendNetworkUpdateImmediate();\r\n\t_mounted.SendModelState(force: true);\r\n\t_mounted = null;\r\n\tif (baseVehicle != null)\r\n\t{\r\n\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t}\r\n\tplayer.ForceUpdateTriggers();\r\n\tif ((bool)player.GetParentEntity())\r\n\t{\r\n\t\tBaseEntity baseEntity = player.GetParentEntity();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"ForcePositionToParentOffset\", player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"ForcePositionTo\", player), res);\r\n\t\tplayer.ClientRPC(RpcTarget.NetworkGroup(\"ForceResetRotation\", player));\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);\r\n\tOnPlayerDismounted(player);\r\n}\r\n",
    "targetName": "BaseMountable",
    "methodName": "DismountPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityDismounted",
    "fullName": "OnEntityDismounted [lite]",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseMountable",
        "type": "BaseMountable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DismountPlayer(BasePlayer player, bool lite = false)\r\n{\r\n\tif (_mounted == null || _mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseVehicle baseVehicle = VehicleParent();\r\n\tif (lite)\r\n\t{\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PrePlayerDismount(player, this);\r\n\t\t}\r\n\t\t_mounted.DismountObject();\r\n\t\t_mounted = null;\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t\t}\r\n\t\tOnPlayerDismounted(player);\r\n\t\treturn;\r\n\t}\r\n\tif (!GetDismountPosition(player, out var res) || Distance(res) > 10f)\r\n\t{\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PrePlayerDismount(player, this);\r\n\t\t}\r\n\t\tres = player.transform.position;\r\n\t\t_mounted.DismountObject();\r\n\t\t_mounted.MovePosition(res);\r\n\t\t_mounted.transform.rotation = UnityEngine.Quaternion.identity;\r\n\t\t_mounted.ClientRPC(RpcTarget.Player(\"ForcePositionTo\", _mounted), res);\r\n\t\tBasePlayer mounted = _mounted;\r\n\t\t_mounted = null;\r\n\t\tUnityEngine.Debug.LogWarning(\"Killing player due to invalid dismount point :\" + player.displayName + \" / \" + player.userID.Get() + \" on obj : \" + base.gameObject.name);\r\n\t\tmounted.Hurt(1000f, Rust.DamageType.Suicide, mounted, useProtection: false);\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t\t}\r\n\t\tOnPlayerDismounted(player);\r\n\t\treturn;\r\n\t}\r\n\tif (baseVehicle != null)\r\n\t{\r\n\t\tbaseVehicle.PrePlayerDismount(player, this);\r\n\t}\r\n\tif (AntiHack.TestNoClipping(_mounted, res, res, _mounted.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _, vehicleLayer: true))\r\n\t{\r\n\t\t_mounted.PauseVehicleNoClipDetection(5f);\r\n\t}\r\n\t_mounted.DismountObject();\r\n\t_mounted.transform.rotation = UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3.forward, UnityEngine.Vector3.up);\r\n\t_mounted.OverrideViewAngles(UnityEngine.Vector3.zero);\r\n\t_mounted.MovePosition(res);\r\n\t_mounted.SendNetworkUpdateImmediate();\r\n\t_mounted.SendModelState(force: true);\r\n\t_mounted = null;\r\n\tif (baseVehicle != null)\r\n\t{\r\n\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t}\r\n\tplayer.ForceUpdateTriggers();\r\n\tif ((bool)player.GetParentEntity())\r\n\t{\r\n\t\tBaseEntity baseEntity = player.GetParentEntity();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"ForcePositionToParentOffset\", player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"ForcePositionTo\", player), res);\r\n\t\tplayer.ClientRPC(RpcTarget.NetworkGroup(\"ForceResetRotation\", player));\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);\r\n\tOnPlayerDismounted(player);\r\n}\r\n",
    "targetName": "BaseMountable",
    "methodName": "DismountPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCrateHack",
    "fullName": "OnCrateHack",
    "category": "Entity",
    "parameters": [
      {
        "name": "hackableLockedCrate",
        "type": "HackableLockedCrate, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartHacking()\r\n{\r\n\tBroadcastEntityMessage(\"HackingStarted\", 20f, 256);\r\n\tSetFlag(BaseEntity.Flags.Reserved1, b: true);\r\n\tInvokeRepeating(HackProgress, 1f, 1f);\r\n\tClientRPC(RpcTarget.NetworkGroup(\"UpdateHackProgress\"), 0, (int)requiredHackSeconds);\r\n\tRefreshDecay();\r\n}\r\n",
    "targetName": "HackableLockedCrate",
    "methodName": "StartHacking",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCrateHackEnd",
    "fullName": "OnCrateHackEnd",
    "category": "Entity",
    "parameters": [
      {
        "name": "hackableLockedCrate",
        "type": "HackableLockedCrate, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void HackProgress()\r\n{\r\n\thackSeconds += 1f;\r\n\tif (hackSeconds > requiredHackSeconds)\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnLockedCrateFinished(originalHackerPlayerId, this);\r\n\t\tif (originalHackerPlayer != null && originalHackerPlayer.serverClan != null)\r\n\t\t{\r\n\t\t\toriginalHackerPlayer.AddClanScore(ClanScoreEventType.HackedCrate);\r\n\t\t}\r\n\t\tRefreshDecay();\r\n\t\tSetFlag(BaseEntity.Flags.Reserved2, b: true);\r\n\t\tisLootable = true;\r\n\t\tCancelInvoke(HackProgress);\r\n\t}\r\n\tClientRPC(RpcTarget.NetworkGroup(\"UpdateHackProgress\"), (int)hackSeconds, (int)requiredHackSeconds);\r\n}\r\n",
    "targetName": "HackableLockedCrate",
    "methodName": "HackProgress",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCrateLanded",
    "fullName": "OnCrateLanded",
    "category": "Entity",
    "parameters": [
      {
        "name": "hackableLockedCrate",
        "type": "HackableLockedCrate, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void LandCheck()\r\n{\r\n\tif (!hasLanded && UnityEngine.Physics.Raycast(new UnityEngine.Ray(base.transform.position + UnityEngine.Vector3.up * 0.5f, UnityEngine.Vector3.down), out var hitInfo, 1f, 1084293377))\r\n\t{\r\n\t\tEffect.server.Run(landEffect.resourcePath, hitInfo.point, UnityEngine.Vector3.up);\r\n\t\thasLanded = true;\r\n\t\tCancelInvoke(LandCheck);\r\n\t}\r\n}\r\n",
    "targetName": "HackableLockedCrate",
    "methodName": "LandCheck",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCrateDropped",
    "fullName": "OnCrateDropped",
    "category": "Entity",
    "parameters": [
      {
        "name": "hackableLockedCrate",
        "type": "HackableLockedCrate, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetWasDropped()\r\n{\r\n\twasDropped = true;\r\n}\r\n",
    "targetName": "HackableLockedCrate",
    "methodName": "SetWasDropped",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCrateLaptopAttack",
    "fullName": "OnCrateLaptopAttack",
    "category": "Entity",
    "parameters": [
      {
        "name": "hackableLockedCrate",
        "type": "HackableLockedCrate, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnAttacked(HitInfo info)\r\n{\r\n\tif (base.isServer)\r\n\t{\r\n\t\tif (StringPool.Get(info.HitBone) == \"laptopcollision\")\r\n\t\t{\r\n\t\t\tEffect.server.Run(shockEffect.resourcePath, info.HitPositionWorld, UnityEngine.Vector3.up);\r\n\t\t\thackSeconds -= 8f * (info.damageTypes.Total() / 50f);\r\n\t\t\tif (hackSeconds < 0f)\r\n\t\t\t{\r\n\t\t\t\thackSeconds = 0f;\r\n\t\t\t}\r\n\t\t}\r\n\t\tRefreshDecay();\r\n\t}\r\n\tbase.OnAttacked(info);\r\n}\r\n",
    "targetName": "HackableLockedCrate",
    "methodName": "OnAttacked",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityDestroy",
    "fullName": "OnEntityDestroy [CH47Helicopter]",
    "category": "Entity",
    "parameters": [
      {
        "name": "cH47HelicopterAIController",
        "type": "CH47HelicopterAIController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnDied(HitInfo info)\r\n{\r\n\tif (!OutOfCrates())\r\n\t{\r\n\t\tDropCrate();\r\n\t}\r\n\tbase.OnDied(info);\r\n}\r\n",
    "targetName": "CH47HelicopterAIController",
    "methodName": "OnDied",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnArcadeScoreAdded",
    "fullName": "OnArcadeScoreAdded",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseArcadeMachine",
        "type": "BaseArcadeMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "score",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void AddScore(BasePlayer player, int score)\r\n{\r\n\tBaseArcadeMachine.ScoreEntry scoreEntry = new BaseArcadeMachine.ScoreEntry();\r\n\tscoreEntry.displayName = player.displayName;\r\n\tscoreEntry.score = score;\r\n\tscoreEntry.playerID = player.userID;\r\n\tscores.Add(scoreEntry);\r\n\tscores.Sort((BaseArcadeMachine.ScoreEntry a, BaseArcadeMachine.ScoreEntry b) => b.score.CompareTo(a.score));\r\n\tscores.TrimExcess();\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "BaseArcadeMachine",
    "methodName": "AddScore",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanEntityBeHostile",
    "fullName": "CanEntityBeHostile [BasePlayer]",
    "category": "Entity",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool IsHostile()\r\n{\r\n\treturn State.unHostileTimestamp > Network.TimeEx.currentTimestamp;\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "IsHostile",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEntityMarkHostile",
    "fullName": "OnEntityMarkHostile [BasePlayer]",
    "category": "Entity",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void MarkHostileFor(float duration = 60f)\r\n{\r\n\tdouble currentTimestamp = Network.TimeEx.currentTimestamp;\r\n\tdouble val = currentTimestamp + (double)duration;\r\n\tState.unHostileTimestamp = System.Math.Max(State.unHostileTimestamp, val);\r\n\tDirtyPlayerState();\r\n\tdouble num = System.Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);\r\n\tClientRPC(RpcTarget.Player(\"SetHostileLength\", this), (float)num);\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "MarkHostileFor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntitySnapshot",
    "fullName": "OnEntitySnapshot [BasePlayer]",
    "category": "Entity",
    "parameters": [
      {
        "name": "ent",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendEntitySnapshot(BaseNetworkable ent)\r\n{\r\n\tusing (TimeWarning.New(\"SendEntitySnapshot\"))\r\n\t{\r\n\t\tif (!(ent == null) && ent.net != null && ent.ShouldNetworkTo(this))\r\n\t\t{\r\n\t\t\tNetwork.NetWrite netWrite = Network.Net.sv.StartWrite();\r\n\t\t\tnet.connection.validate.entityUpdates++;\r\n\t\t\tBaseNetworkable.SaveInfo saveInfo = default(BaseNetworkable.SaveInfo);\r\n\t\t\tsaveInfo.forConnection = net.connection;\r\n\t\t\tsaveInfo.forDisk = false;\r\n\t\t\tBaseNetworkable.SaveInfo saveInfo2 = saveInfo;\r\n\t\t\tnetWrite.PacketID(Network.Message.Type.Entities);\r\n\t\t\tnetWrite.UInt32(net.connection.validate.entityUpdates);\r\n\t\t\tent.ToStreamForNetwork(netWrite, saveInfo2);\r\n\t\t\tnetWrite.Send(new Network.SendInfo(net.connection));\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "SendEntitySnapshot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanSeeStash",
    "fullName": "CanSeeStash",
    "category": "Entity",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "entity",
        "type": "StashContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CheckStashRevealInvoke()\r\n{\r\n\tfor (int i = 0; i < nearbyStashes.Count; i++)\r\n\t{\r\n\t\tBasePlayer.NearbyStash nearbyStash = nearbyStashes[i];\r\n\t\tif (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)\r\n\t\t{\r\n\t\t\tnearbyStashes.RemoveAt(i);\r\n\t\t}\r\n\t\telse if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))\r\n\t\t{\r\n\t\t\tnearbyStash.LookingAtTime += StashContainer.PlayerDetectionTickRate;\r\n\t\t\tif (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)\r\n\t\t\t{\r\n\t\t\t\tnearbyStash.Entity.SetHidden(isHidden: false);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnearbyStash.LookingAtTime = 0f;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "CheckStashRevealInvoke",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnStashExposed",
    "fullName": "OnStashExposed",
    "category": "Entity",
    "parameters": [
      {
        "name": "entity",
        "type": "StashContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CheckStashRevealInvoke()\r\n{\r\n\tfor (int i = 0; i < nearbyStashes.Count; i++)\r\n\t{\r\n\t\tBasePlayer.NearbyStash nearbyStash = nearbyStashes[i];\r\n\t\tif (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)\r\n\t\t{\r\n\t\t\tnearbyStashes.RemoveAt(i);\r\n\t\t}\r\n\t\telse if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))\r\n\t\t{\r\n\t\t\tnearbyStash.LookingAtTime += StashContainer.PlayerDetectionTickRate;\r\n\t\t\tif (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)\r\n\t\t\t{\r\n\t\t\t\tnearbyStash.Entity.SetHidden(isHidden: false);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnearbyStash.LookingAtTime = 0f;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "CheckStashRevealInvoke",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanSamSiteShoot",
    "fullName": "CanSamSiteShoot",
    "category": "Entity",
    "parameters": [
      {
        "name": "samSite",
        "type": "SamSite, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void WeaponTick()\r\n{\r\n\tif (IsDead() || UnityEngine.Time.time < lockOnTime || UnityEngine.Time.time < nextBurstTime)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!IsPowered())\r\n\t{\r\n\t\tfiredCount = 0;\r\n\t\treturn;\r\n\t}\r\n\tif (firedCount >= 6)\r\n\t{\r\n\t\tfloat timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;\r\n\t\tnextBurstTime = UnityEngine.Time.time + timeBetweenBursts;\r\n\t\tfiredCount = 0;\r\n\t\treturn;\r\n\t}\r\n\tEnsureReloaded();\r\n\tif (HasAmmo())\r\n\t{\r\n\t\tbool num = ammoItem != null && ammoItem.amount == lowAmmoThreshold;\r\n\t\tif (!staticRespawn && ammoItem != null)\r\n\t\t{\r\n\t\t\tammoItem.UseItem();\r\n\t\t}\r\n\t\tfiredCount++;\r\n\t\tfloat speedMultiplier = 1f;\r\n\t\tif (!currentTarget.IsUnityNull())\r\n\t\t{\r\n\t\t\tspeedMultiplier = currentTarget.SAMTargetType.speedMultiplier;\r\n\t\t}\r\n\t\tFireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);\r\n\t\tEffect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get(\"Tube \" + (currentTubeIndex + 1)), UnityEngine.Vector3.zero, UnityEngine.Vector3.up);\r\n\t\tcurrentTubeIndex++;\r\n\t\tif (currentTubeIndex >= tubes.Length)\r\n\t\t{\r\n\t\t\tcurrentTubeIndex = 0;\r\n\t\t}\r\n\t\tif (num)\r\n\t\t{\r\n\t\t\tMarkIODirty();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "SamSite",
    "methodName": "WeaponTick",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSamSiteModeToggle",
    "fullName": "OnSamSiteModeToggle",
    "category": "Entity",
    "parameters": [
      {
        "name": "samSite",
        "type": "SamSite, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void ToggleDefenderMode(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (staticRespawn)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && player.CanBuild())\r\n\t{\r\n\t\tbool flag = msg.read.Bit();\r\n\t\tif (flag != IsInDefenderMode())\r\n\t\t{\r\n\t\t\tSetFlag(Flag_ManuallySetMode, flag);\r\n\t\t\tSetFlag(Flag_TargetMode, flag);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "SamSite",
    "methodName": "ToggleDefenderMode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSamSiteTarget",
    "fullName": "OnSamSiteTarget",
    "category": "Entity",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TargetScan()\r\n{\r\n\tif (!IsPowered())\r\n\t{\r\n\t\tlastTargetVisibleTime = 0f;\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Time.time > lastTargetVisibleTime + 3f)\r\n\t{\r\n\t\tClearTarget();\r\n\t}\r\n\tif (!staticRespawn)\r\n\t{\r\n\t\tint num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);\r\n\t\tbool flag = lastAmmoCount < lowAmmoThreshold;\r\n\t\tbool flag2 = num < lowAmmoThreshold;\r\n\t\tif (num != lastAmmoCount && flag != flag2)\r\n\t\t{\r\n\t\t\tMarkIODirty();\r\n\t\t}\r\n\t\tlastAmmoCount = num;\r\n\t}\r\n\tif (HasValidTarget() || IsDead())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<SamSite.ISamSiteTarget> obj = Facepunch.Pool.Get<System.Collections.Generic.List<SamSite.ISamSiteTarget>>();\r\n\tif (!IsInDefenderMode())\r\n\t{\r\n\t\tAddTargetSet(obj, targetTypeVehicle.scanRadius);\r\n\t}\r\n\tAddMLRSRockets(obj, targetTypeMissile.scanRadius);\r\n\tSamSite.ISamSiteTarget samSiteTarget = null;\r\n\tforeach (SamSite.ISamSiteTarget item in obj)\r\n\t{\r\n\t\tif (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn))\r\n\t\t{\r\n\t\t\tsamSiteTarget = item;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (!samSiteTarget.IsUnityNull() && currentTarget != samSiteTarget)\r\n\t{\r\n\t\tlockOnTime = UnityEngine.Time.time + 0.5f;\r\n\t}\r\n\tSetTarget(samSiteTarget);\r\n\tif (!currentTarget.IsUnityNull())\r\n\t{\r\n\t\tlastTargetVisibleTime = UnityEngine.Time.time;\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\tif (currentTarget.IsUnityNull())\r\n\t{\r\n\t\tCancelInvoke(WeaponTick);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tInvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);\r\n\t}\r\n}\r\n",
    "targetName": "SamSite",
    "methodName": "TargetScan",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSamSiteTargetScan",
    "fullName": "OnSamSiteTargetScan",
    "category": "Entity",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TargetScan()\r\n{\r\n\tif (!IsPowered())\r\n\t{\r\n\t\tlastTargetVisibleTime = 0f;\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Time.time > lastTargetVisibleTime + 3f)\r\n\t{\r\n\t\tClearTarget();\r\n\t}\r\n\tif (!staticRespawn)\r\n\t{\r\n\t\tint num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);\r\n\t\tbool flag = lastAmmoCount < lowAmmoThreshold;\r\n\t\tbool flag2 = num < lowAmmoThreshold;\r\n\t\tif (num != lastAmmoCount && flag != flag2)\r\n\t\t{\r\n\t\t\tMarkIODirty();\r\n\t\t}\r\n\t\tlastAmmoCount = num;\r\n\t}\r\n\tif (HasValidTarget() || IsDead())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<SamSite.ISamSiteTarget> obj = Facepunch.Pool.Get<System.Collections.Generic.List<SamSite.ISamSiteTarget>>();\r\n\tif (!IsInDefenderMode())\r\n\t{\r\n\t\tAddTargetSet(obj, targetTypeVehicle.scanRadius);\r\n\t}\r\n\tAddMLRSRockets(obj, targetTypeMissile.scanRadius);\r\n\tSamSite.ISamSiteTarget samSiteTarget = null;\r\n\tforeach (SamSite.ISamSiteTarget item in obj)\r\n\t{\r\n\t\tif (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn))\r\n\t\t{\r\n\t\t\tsamSiteTarget = item;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (!samSiteTarget.IsUnityNull() && currentTarget != samSiteTarget)\r\n\t{\r\n\t\tlockOnTime = UnityEngine.Time.time + 0.5f;\r\n\t}\r\n\tSetTarget(samSiteTarget);\r\n\tif (!currentTarget.IsUnityNull())\r\n\t{\r\n\t\tlastTargetVisibleTime = UnityEngine.Time.time;\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\tif (currentTarget.IsUnityNull())\r\n\t{\r\n\t\tCancelInvoke(WeaponTick);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tInvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);\r\n\t}\r\n}\r\n",
    "targetName": "SamSite",
    "methodName": "TargetScan",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSwitchToggle",
    "fullName": "OnSwitchToggle [ElectricSwitch]",
    "category": "Entity",
    "parameters": [
      {
        "name": "electricSwitch",
        "type": "ElectricSwitch, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Switch(BaseEntity.RPCMessage msg)\r\n{\r\n\tbool @switch = msg.read.Bool();\r\n\tSetSwitch(@switch);\r\n}\r\n",
    "targetName": "ElectricSwitch",
    "methodName": "RPC_Switch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSwitchToggled",
    "fullName": "OnSwitchToggled [ElectricSwitch]",
    "category": "Entity",
    "parameters": [
      {
        "name": "electricSwitch",
        "type": "ElectricSwitch, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Switch(BaseEntity.RPCMessage msg)\r\n{\r\n\tbool @switch = msg.read.Bool();\r\n\tSetSwitch(@switch);\r\n}\r\n",
    "targetName": "ElectricSwitch",
    "methodName": "RPC_Switch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityTakeDamage",
    "fullName": "OnEntityTakeDamage [ResourceEntity]",
    "category": "Entity",
    "parameters": [
      {
        "name": "resourceEntity",
        "type": "ResourceEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnAttacked(HitInfo info)\r\n{\r\n\tif (!base.isServer || isKilled)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (resourceDispenser != null)\r\n\t{\r\n\t\tresourceDispenser.OnAttacked(info);\r\n\t}\r\n\tif (!info.DidGather)\r\n\t{\r\n\t\tif ((bool)baseProtection)\r\n\t\t{\r\n\t\t\tbaseProtection.Scale(info.damageTypes);\r\n\t\t}\r\n\t\tfloat num = info.damageTypes.Total();\r\n\t\thealth -= num;\r\n\t\tif (health <= 0f)\r\n\t\t{\r\n\t\t\tOnDied(info);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tOnHealthChanged();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ResourceEntity",
    "methodName": "OnAttacked",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityDeath",
    "fullName": "OnEntityDeath [ResourceEntity]",
    "category": "Entity",
    "parameters": [
      {
        "name": "resourceEntity",
        "type": "ResourceEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnDied(HitInfo info)\r\n{\r\n\tisKilled = true;\r\n\tKill();\r\n}\r\n",
    "targetName": "ResourceEntity",
    "methodName": "OnDied",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSupplyDropLanded",
    "fullName": "OnSupplyDropLanded",
    "category": "Entity",
    "parameters": [
      {
        "name": "supplyDrop",
        "type": "SupplyDrop, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnCollisionEnter(UnityEngine.Collision collision)\r\n{\r\n\tbool flag = ((1 << collision.collider.gameObject.layer) & 0x40A10111) > 0;\r\n\tif (((1 << collision.collider.gameObject.layer) & 0x8000000) > 0 && UnityEngine.CollisionEx.GetEntity(collision) is Tugboat)\r\n\t{\r\n\t\tflag = true;\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tRemoveParachute();\r\n\t\tMakeLootable();\r\n\t}\r\n}\r\n",
    "targetName": "SupplyDrop",
    "methodName": "OnCollisionEnter",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityEnter",
    "fullName": "OnEntityEnter [TriggerComfort]",
    "category": "Entity",
    "parameters": [
      {
        "name": "triggerComfort",
        "type": "TriggerComfort, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnEntityEnter(BaseEntity ent)\r\n{\r\n\tif (ent is BasePlayer || ent is RidableHorse || ent is RidableHorse2)\r\n\t{\r\n\t\t_entities.Add(ent);\r\n\t}\r\n}\r\n",
    "targetName": "TriggerComfort",
    "methodName": "OnEntityEnter",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityLeave",
    "fullName": "OnEntityLeave [TriggerComfort]",
    "category": "Entity",
    "parameters": [
      {
        "name": "triggerComfort",
        "type": "TriggerComfort, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnEntityLeave(BaseEntity ent)\r\n{\r\n\tif (ent is BasePlayer || ent is RidableHorse || ent is RidableHorse2)\r\n\t{\r\n\t\t_entities.Remove(ent);\r\n\t}\r\n}\r\n",
    "targetName": "TriggerComfort",
    "methodName": "OnEntityLeave",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityStabilityCheck",
    "fullName": "OnEntityStabilityCheck",
    "category": "Entity",
    "parameters": [
      {
        "name": "stabilityEntity",
        "type": "StabilityEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void StabilityCheck()\r\n{\r\n\tif (base.IsDestroyed)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (supports == null)\r\n\t{\r\n\t\tInitializeSupports();\r\n\t}\r\n\tbool flag = false;\r\n\tint num = DistanceFromGround();\r\n\tif (num != cachedDistanceFromGround)\r\n\t{\r\n\t\tcachedDistanceFromGround = num;\r\n\t\tflag = true;\r\n\t}\r\n\tfloat num2 = SupportValue();\r\n\tif (UnityEngine.Mathf.Abs(cachedStability - num2) > ConVar.Stability.accuracy)\r\n\t{\r\n\t\tcachedStability = num2;\r\n\t\tflag = true;\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tdirty = true;\r\n\t\tUpdateConnectedEntities();\r\n\t\tUpdateStability();\r\n\t}\r\n\telse if (dirty)\r\n\t{\r\n\t\tdirty = false;\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n\tif (num2 < ConVar.Stability.collapse)\r\n\t{\r\n\t\tif (stabilityStrikes < ConVar.Stability.strikes)\r\n\t\t{\r\n\t\t\tUpdateStability();\r\n\t\t\tstabilityStrikes++;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tKill(BaseNetworkable.DestroyMode.Gib);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstabilityStrikes = 0;\r\n\t}\r\n}\r\n",
    "targetName": "StabilityEntity",
    "methodName": "StabilityCheck",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDieselEngineToggled",
    "fullName": "OnDieselEngineToggled [off]",
    "category": "Entity",
    "parameters": [
      {
        "name": "dieselEngine",
        "type": "DieselEngine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void EngineOff()\r\n{\r\n\tSetFlag(BaseEntity.Flags.On, b: false);\r\n\tBroadcastEntityMessage(\"DieselEngineOff\");\r\n}\r\n",
    "targetName": "DieselEngine",
    "methodName": "EngineOff",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDieselEngineToggled",
    "fullName": "OnDieselEngineToggled [on]",
    "category": "Entity",
    "parameters": [
      {
        "name": "dieselEngine",
        "type": "DieselEngine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void EngineOn()\r\n{\r\n\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\tBroadcastEntityMessage(\"DieselEngineOn\");\r\n}\r\n",
    "targetName": "DieselEngine",
    "methodName": "EngineOn",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDieselEngineToggle",
    "fullName": "OnDieselEngineToggle",
    "category": "Entity",
    "parameters": [
      {
        "name": "dieselEngine",
        "type": "DieselEngine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(6f)]\r\npublic void EngineSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.read.Bit())\r\n\t{\r\n\t\tif (GetFuelAmount() > 0)\r\n\t\t{\r\n\t\t\tEngineOn();\r\n\t\t\tstartedByPlayer = msg.player;\r\n\t\t\tif (Rust.GameInfo.HasAchievements && msg.player != null)\r\n\t\t\t{\r\n\t\t\t\tmsg.player.stats.Add(\"excavator_activated\", 1, Stats.All);\r\n\t\t\t\tmsg.player.stats.Save(forceSteamSave: true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tEngineOff();\r\n\t}\r\n}\r\n",
    "targetName": "DieselEngine",
    "methodName": "EngineSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBuildingPrivilege",
    "fullName": "OnBuildingPrivilege",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseEntity",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual BuildingPrivlidge GetBuildingPrivilege()\r\n{\r\n\treturn GetNearestBuildingPrivilege(PrivilegeCacheDefaultValue());\r\n}\r\n",
    "targetName": "BaseEntity",
    "methodName": "GetBuildingPrivilege",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "BuildingPrivlidge"
  },
  {
    "name": "OnEntityFlagsNetworkUpdate",
    "fullName": "OnEntityFlagsNetworkUpdate",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseEntity",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendNetworkUpdate_Flags()\r\n{\r\n\tif (Rust.Application.isLoading || Rust.Application.isLoadingSave || base.IsDestroyed || net == null || !isSpawned)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"SendNetworkUpdate_Flags\"))\r\n\t{\r\n\t\tLogEntry(RustLog.EntryType.Network, 3, \"SendNetworkUpdate_Flags\");\r\n\t\tSystem.Collections.Generic.List<Network.Connection> subscribers = GetSubscribers();\r\n\t\tif (subscribers != null && subscribers.Count > 0)\r\n\t\t{\r\n\t\t\tSendDemoTransientEntity();\r\n\t\t\tNetwork.NetWrite netWrite = Network.Net.sv.StartWrite();\r\n\t\t\tnetWrite.PacketID(Network.Message.Type.EntityFlags);\r\n\t\t\tnetWrite.EntityID(net.ID);\r\n\t\t\tnetWrite.Int32((int)flags);\r\n\t\t\tNetwork.SendInfo info = new Network.SendInfo(subscribers);\r\n\t\t\tnetWrite.Send(info);\r\n\t\t}\r\n\t\tbase.gameObject.SendOnSendNetworkUpdate(this);\r\n\t}\r\n}\r\n",
    "targetName": "BaseEntity",
    "methodName": "SendNetworkUpdate_Flags",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCargoShipEgress",
    "fullName": "OnCargoShipEgress",
    "category": "Entity",
    "parameters": [
      {
        "name": "cargoShip",
        "type": "CargoShip, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartEgress()\r\n{\r\n\tif (!isDoingHarborApproach && !egressing)\r\n\t{\r\n\t\tegressing = true;\r\n\t\tCancelInvoke(PlayHorn);\r\n\t\tradiation.SetActive(value: true);\r\n\t\tSetFlag(BaseEntity.Flags.Reserved8, b: true);\r\n\t\tInvokeRepeating(UpdateRadiation, 10f, 1f);\r\n\t\tInvoke(DelayedDestroy, 60f * egress_duration_minutes);\r\n\t}\r\n}\r\n",
    "targetName": "CargoShip",
    "methodName": "StartEgress",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCargoShipSpawnCrate",
    "fullName": "OnCargoShipSpawnCrate",
    "category": "Entity",
    "parameters": [
      {
        "name": "cargoShip",
        "type": "CargoShip, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RespawnLoot()\r\n{\r\n\tInvokeRepeating(PlayHorn, 0f, 8f);\r\n\tSpawnCrate(lockedCratePrefab.resourcePath);\r\n\tSpawnCrate(eliteCratePrefab.resourcePath);\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tSpawnCrate(militaryCratePrefab.resourcePath);\r\n\t}\r\n\tfor (int j = 0; j < 4; j++)\r\n\t{\r\n\t\tSpawnCrate(junkCratePrefab.resourcePath);\r\n\t}\r\n\tlootRoundsPassed++;\r\n\tif (lootRoundsPassed >= loot_rounds)\r\n\t{\r\n\t\tCancelInvoke(RespawnLoot);\r\n\t}\r\n}\r\n",
    "targetName": "CargoShip",
    "methodName": "RespawnLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCargoShipHarborApproach",
    "fullName": "OnCargoShipHarborApproach",
    "category": "Entity",
    "parameters": [
      {
        "name": "cargoShip",
        "type": "CargoShip, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartHarborApproach(CargoNotifier cn)\r\n{\r\n\tPlayHorn();\r\n\tisDoingHarborApproach = true;\r\n\tdockCount++;\r\n\tshouldLookAhead = false;\r\n\tif (proxManager != null)\r\n\t{\r\n\t\tproxManager.StartMovement();\r\n\t}\r\n\tClearAllHarborEntitiesOnShip();\r\n\tforeach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)\r\n\t{\r\n\t\tif (!(allCrane == null) && !allCrane.isClient && !(allCrane.Distance2D(harborApproachPath.nodes[harborApproachPath.nodes.Count / 2].Position) > 150f))\r\n\t\t{\r\n\t\t\tallCrane.ReplenishContainers();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "CargoShip",
    "methodName": "StartHarborApproach",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCargoShipHarborArrived",
    "fullName": "OnCargoShipHarborArrived",
    "category": "Entity",
    "parameters": [
      {
        "name": "cargoShip",
        "type": "CargoShip, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnArrivedAtHarbor()\r\n{\r\n\tSetFlag(BaseEntity.Flags.Reserved1, b: true);\r\n\tSystem.Collections.Generic.List<UnityEngine.Transform> obj = Facepunch.Pool.Get<System.Collections.Generic.List<UnityEngine.Transform>>();\r\n\tfloat num = UnityEngine.Random.Range(dock_time * 0.05f, dock_time * 0.1f);\r\n\tforeach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)\r\n\t{\r\n\t\tif (allCrane == null || allCrane.isClient || allCrane.Distance2D(this) > 150f)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tobj.Clear();\r\n\t\tCargoShipContainerDestination[] array = containerDestinations;\r\n\t\tforeach (CargoShipContainerDestination cargoShipContainerDestination in array)\r\n\t\t{\r\n\t\t\tif (allCrane.IsDestinationValidForCrane(cargoShipContainerDestination))\r\n\t\t\t{\r\n\t\t\t\tobj.Add(cargoShipContainerDestination.transform);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (obj.Count > 0)\r\n\t\t{\r\n\t\t\tallCrane.AssignDestination(obj, this, num);\r\n\t\t\tnum += dock_time * UnityEngine.Random.Range(0.1f, 0.15f);\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\tInvoke(PreHarborLeaveHorn, dock_time - 60f);\r\n\tif (refresh_loot_on_dock)\r\n\t{\r\n\t\tRespawnLoot();\r\n\t}\r\n\tif (harborIndex == 0)\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Reserved3, b: true);\r\n\t}\r\n\telse if (harborIndex == 1)\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Reserved4, b: true);\r\n\t}\r\n\tInvoke(LeaveHarbor, dock_time);\r\n}\r\n",
    "targetName": "CargoShip",
    "methodName": "OnArrivedAtHarbor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCargoShipHarborLeave",
    "fullName": "OnCargoShipHarborLeave",
    "category": "Entity",
    "parameters": [
      {
        "name": "cargoShip",
        "type": "CargoShip, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void LeaveHarbor()\r\n{\r\n\tif (docking_debug)\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"Cargo is leaving harbor.\");\r\n\t}\r\n\tPlayHorn();\r\n\tSetFlag(BaseEntity.Flags.Reserved1, b: false);\r\n\tSetFlag(BaseEntity.Flags.Reserved2, b: true);\r\n\tcurrentHarborApproachNode++;\r\n}\r\n",
    "targetName": "CargoShip",
    "methodName": "LeaveHarbor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityDestroy",
    "fullName": "OnEntityDestroy [BradleyAPC]",
    "category": "Entity",
    "parameters": [
      {
        "name": "bradleyAPC",
        "type": "BradleyAPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnDied(HitInfo info)\r\n{\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tCreateExplosionMarker(10f);\r\n\tEffect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, UnityEngine.Vector3.up, null, broadcast: true);\r\n\tUnityEngine.Vector3 zero = UnityEngine.Vector3.zero;\r\n\tUnityEngine.GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;\r\n\tSystem.Collections.Generic.List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);\r\n\tfor (int i = 0; i < 12 - maxCratesToSpawn; i++)\r\n\t{\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);\r\n\t\tif (!baseEntity)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tfloat minInclusive = 3f;\r\n\t\tfloat maxInclusive = 10f;\r\n\t\tUnityEngine.Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;\r\n\t\tbaseEntity.transform.position = base.transform.position + new UnityEngine.Vector3(0f, 1.5f, 0f) + onUnitSphere * UnityEngine.Random.Range(-4f, 4f);\r\n\t\tUnityEngine.Collider component = baseEntity.GetComponent<UnityEngine.Collider>();\r\n\t\tbaseEntity.Spawn();\r\n\t\tbaseEntity.SetVelocity(zero + onUnitSphere * UnityEngine.Random.Range(minInclusive, maxInclusive));\r\n\t\tforeach (ServerGib item in list)\r\n\t\t{\r\n\t\t\tUnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);\r\n\t\t}\r\n\t}\r\n\tfor (int j = 0; j < maxCratesToSpawn; j++)\r\n\t{\r\n\t\tUnityEngine.Vector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;\r\n\t\tonUnitSphere2.y = 0f;\r\n\t\tonUnitSphere2.Normalize();\r\n\t\tUnityEngine.Vector3 pos = base.transform.position + new UnityEngine.Vector3(0f, 1.5f, 0f) + onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);\r\n\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, UnityEngine.Quaternion.LookRotation(onUnitSphere2));\r\n\t\tbaseEntity2.Spawn();\r\n\t\tLootContainer lootContainer = baseEntity2 as LootContainer;\r\n\t\tif ((bool)lootContainer)\r\n\t\t{\r\n\t\t\tlootContainer.Invoke(lootContainer.RemoveMe, 1800f);\r\n\t\t}\r\n\t\tUnityEngine.Collider component2 = baseEntity2.GetComponent<UnityEngine.Collider>();\r\n\t\tUnityEngine.Rigidbody rigidbody = baseEntity2.gameObject.AddComponent<UnityEngine.Rigidbody>();\r\n\t\trigidbody.useGravity = true;\r\n\t\trigidbody.collisionDetectionMode = UnityEngine.CollisionDetectionMode.ContinuousDynamic;\r\n\t\trigidbody.mass = 2f;\r\n\t\trigidbody.interpolation = UnityEngine.RigidbodyInterpolation.Interpolate;\r\n\t\trigidbody.velocity = zero + onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);\r\n\t\trigidbody.angularVelocity = UnityEngine.Vector3Ex.Range(-1.75f, 1.75f);\r\n\t\trigidbody.drag = 0.5f * (rigidbody.mass / 5f);\r\n\t\trigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);\r\n\t\tFireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;\r\n\t\tif ((bool)fireBall)\r\n\t\t{\r\n\t\t\tfireBall.SetParent(baseEntity2);\r\n\t\t\tfireBall.Spawn();\r\n\t\t\tfireBall.GetComponent<UnityEngine.Rigidbody>().isKinematic = true;\r\n\t\t\tfireBall.GetComponent<UnityEngine.Collider>().enabled = false;\r\n\t\t}\r\n\t\tbaseEntity2.SendMessage(\"SetLockingEnt\", fireBall.gameObject, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t\tforeach (ServerGib item2 in list)\r\n\t\t{\r\n\t\t\tUnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);\r\n\t\t}\r\n\t}\r\n\tKillSpawnedScientists();\r\n\tif (info != null && info.InitiatorPlayer != null && info.InitiatorPlayer.serverClan != null)\r\n\t{\r\n\t\tinfo.InitiatorPlayer.AddClanScore(ClanScoreEventType.DestroyedBradley);\r\n\t}\r\n\tbase.OnDied(info);\r\n}\r\n",
    "targetName": "BradleyAPC",
    "methodName": "OnDied",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSwitchToggle",
    "fullName": "OnSwitchToggle [FuelGenerator]",
    "category": "Entity",
    "parameters": [
      {
        "name": "fuelGenerator",
        "type": "FuelGenerator, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_EngineSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tbool generatorState = msg.read.Bit();\r\n\tSetGeneratorState(generatorState);\r\n}\r\n",
    "targetName": "FuelGenerator",
    "methodName": "RPC_EngineSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSwitchToggled",
    "fullName": "OnSwitchToggled [FuelGenerator]",
    "category": "Entity",
    "parameters": [
      {
        "name": "fuelGenerator",
        "type": "FuelGenerator, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_EngineSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tbool generatorState = msg.read.Bit();\r\n\tSetGeneratorState(generatorState);\r\n}\r\n",
    "targetName": "FuelGenerator",
    "methodName": "RPC_EngineSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityActiveCheck",
    "fullName": "OnEntityActiveCheck",
    "category": "Entity",
    "parameters": [
      {
        "name": "ent",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "id",
        "type": "System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "debugName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "BaseEntity+RPC_Server+IsActiveItem",
    "methodName": "Test",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEntityFromOwnerCheck",
    "fullName": "OnEntityFromOwnerCheck",
    "category": "Entity",
    "parameters": [
      {
        "name": "ent",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "id",
        "type": "System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "debugName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "includeMounted",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "BaseEntity+RPC_Server+FromOwner",
    "methodName": "Test",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEntityVisibilityCheck",
    "fullName": "OnEntityVisibilityCheck",
    "category": "Entity",
    "parameters": [
      {
        "name": "ent",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "id",
        "type": "System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "debugName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "maximumDistance",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "BaseEntity+RPC_Server+IsVisible",
    "methodName": "Test",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEntityDistanceCheck",
    "fullName": "OnEntityDistanceCheck",
    "category": "Entity",
    "parameters": [
      {
        "name": "ent",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "id",
        "type": "System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "debugName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "maximumDistance",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "checkParent",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "BaseEntity+RPC_Server+MaxDistance",
    "methodName": "Test",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnStashHidden",
    "fullName": "OnStashHidden",
    "category": "Entity",
    "parameters": [
      {
        "name": "stashContainer",
        "type": "StashContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_HideStash(BaseEntity.RPCMessage rpc)\r\n{\r\n\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\r\n\tSetHidden(isHidden: true);\r\n}\r\n",
    "targetName": "StashContainer",
    "methodName": "RPC_HideStash",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnStashOcclude",
    "fullName": "OnStashOcclude",
    "category": "Entity",
    "parameters": [
      {
        "name": "stashContainer",
        "type": "StashContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoOccludedCheck()\r\n{\r\n\tif (UnityEngine.Physics.SphereCast(new UnityEngine.Ray(base.transform.position + UnityEngine.Vector3.up * 5f, UnityEngine.Vector3.down), 0.25f, 5f, 2097152))\r\n\t{\r\n\t\tDropItems();\r\n\t\tKill();\r\n\t}\r\n}\r\n",
    "targetName": "StashContainer",
    "methodName": "DoOccludedCheck",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMixingTableToggle",
    "fullName": "OnMixingTableToggle",
    "category": "Entity",
    "parameters": [
      {
        "name": "mixingTable",
        "type": "MixingTable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void SVSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag != IsOn() && !(msg.player == null))\r\n\t{\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tStartMixing(msg.player);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tStopMixing();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "MixingTable",
    "methodName": "SVSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSleepingBagDestroyed",
    "fullName": "OnSleepingBagDestroyed",
    "category": "Entity",
    "parameters": [
      {
        "name": "local1",
        "type": "SleepingBag, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "userID",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)\r\n{\r\n\tSleepingBag sleepingBag2 = System.Linq.Enumerable.FirstOrDefault(FindForPlayer(userID, ignoreTimers: true), (SleepingBag x) => x.net.ID == sleepingBag);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tRemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);\r\n\tsleepingBag2.deployerUserID = 0uL;\r\n\tsleepingBag2.SendNetworkUpdate();\r\n\tBasePlayer basePlayer = BasePlayer.FindByID(userID);\r\n\tif (basePlayer != null)\r\n\t{\r\n\t\tbasePlayer.SendRespawnOptions();\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "SleepingBag",
    "methodName": "DestroyBag",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSleepingBagValidCheck",
    "fullName": "OnSleepingBagValidCheck",
    "category": "Entity",
    "parameters": [
      {
        "name": "sleepingBag",
        "type": "SleepingBag, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "playerID",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "ignoreTimers",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)\r\n{\r\n\tif (deployerUserID == playerID)\r\n\t{\r\n\t\tif (!ignoreTimers)\r\n\t\t{\r\n\t\t\treturn unlockTime < UnityEngine.Time.realtimeSinceStartup;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "SleepingBag",
    "methodName": "ValidForPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnBedMade",
    "fullName": "OnBedMade",
    "category": "Entity",
    "parameters": [
      {
        "name": "sleepingBag",
        "type": "SleepingBag, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_MakeBed(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!canBePublic || !IsPublic() || !msg.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (ConVar.Server.max_sleeping_bags > 0)\r\n\t{\r\n\t\tSleepingBag.CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);\r\n\t\tif (canAssignBedResult.HasValue)\r\n\t\t{\r\n\t\t\tif (canAssignBedResult.Value.Result != 0)\r\n\t\t\t{\r\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Red_Normal, cannotMakeBedPhrase, false);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\r\n\t\t\t}\r\n\t\t\tif (canAssignBedResult.Value.Result != 0)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tulong num = deployerUserID;\r\n\tdeployerUserID = msg.player.userID;\r\n\tNotifyPlayer(num);\r\n\tNotifyPlayer(deployerUserID);\r\n\tOnBagChangedOwnership(this, num);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "SleepingBag",
    "methodName": "RPC_MakeBed",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSleepingBagDestroy",
    "fullName": "OnSleepingBagDestroy",
    "category": "Entity",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)\r\n{\r\n\tSleepingBag sleepingBag2 = System.Linq.Enumerable.FirstOrDefault(FindForPlayer(userID, ignoreTimers: true), (SleepingBag x) => x.net.ID == sleepingBag);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tRemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);\r\n\tsleepingBag2.deployerUserID = 0uL;\r\n\tsleepingBag2.SendNetworkUpdate();\r\n\tBasePlayer basePlayer = BasePlayer.FindByID(userID);\r\n\tif (basePlayer != null)\r\n\t{\r\n\t\tbasePlayer.SendRespawnOptions();\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "SleepingBag",
    "methodName": "DestroyBag",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnAnalysisComplete",
    "fullName": "OnAnalysisComplete",
    "category": "Entity",
    "parameters": [
      {
        "name": "surveyCrater",
        "type": "SurveyCrater, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void AnalysisComplete(BaseEntity.RPCMessage msg)\r\n{\r\n}\r\n",
    "targetName": "SurveyCrater",
    "methodName": "AnalysisComplete",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnHotAirBalloonToggle",
    "fullName": "OnHotAirBalloonToggle",
    "category": "Entity",
    "parameters": [
      {
        "name": "hotAirBalloon",
        "type": "HotAirBalloon, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && (!OnlyOwnerAccessible() || !(player != creatorEntity)))\r\n\t{\r\n\t\tbool b = msg.read.Bit();\r\n\t\tSetFlag(BaseEntity.Flags.On, b);\r\n\t\tif (IsOn())\r\n\t\t{\r\n\t\t\tInvoke(ScheduleOff, 60f);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCancelInvoke(ScheduleOff);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "HotAirBalloon",
    "methodName": "EngineSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnHotAirBalloonToggled",
    "fullName": "OnHotAirBalloonToggled [on]",
    "category": "Entity",
    "parameters": [
      {
        "name": "hotAirBalloon",
        "type": "HotAirBalloon, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && (!OnlyOwnerAccessible() || !(player != creatorEntity)))\r\n\t{\r\n\t\tbool b = msg.read.Bit();\r\n\t\tSetFlag(BaseEntity.Flags.On, b);\r\n\t\tif (IsOn())\r\n\t\t{\r\n\t\t\tInvoke(ScheduleOff, 60f);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCancelInvoke(ScheduleOff);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "HotAirBalloon",
    "methodName": "EngineSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnHotAirBalloonToggled",
    "fullName": "OnHotAirBalloonToggled [off]",
    "category": "Entity",
    "parameters": [
      {
        "name": "hotAirBalloon",
        "type": "HotAirBalloon, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && (!OnlyOwnerAccessible() || !(player != creatorEntity)))\r\n\t{\r\n\t\tbool b = msg.read.Bit();\r\n\t\tSetFlag(BaseEntity.Flags.On, b);\r\n\t\tif (IsOn())\r\n\t\t{\r\n\t\t\tInvoke(ScheduleOff, 60f);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCancelInvoke(ScheduleOff);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "HotAirBalloon",
    "methodName": "EngineSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnReactiveTargetReset",
    "fullName": "OnReactiveTargetReset",
    "category": "Entity",
    "parameters": [
      {
        "name": "reactiveTarget",
        "type": "ReactiveTarget, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ResetTarget()\r\n{\r\n\tif (IsLowered() && CanToggle() && CanReset())\r\n\t{\r\n\t\tCancelInvoke(ResetTarget);\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\tSetFlag(BaseEntity.Flags.Reserved1, b: false);\r\n\t\tknockdownHealth = 100f;\r\n\t\tSendPowerBurst();\r\n\t}\r\n}\r\n",
    "targetName": "ReactiveTarget",
    "methodName": "ResetTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCargoPlaneSignaled",
    "fullName": "OnCargoPlaneSignaled",
    "category": "Entity",
    "parameters": [
      {
        "name": "local0",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "supplySignal",
        "type": "SupplySignal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void Explode()\r\n{\r\n\tBaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);\r\n\tif ((bool)baseEntity)\r\n\t{\r\n\t\tUnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\r\n\t\tbaseEntity.SendMessage(\"InitDropPosition\", base.transform.position + vector, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t\tbaseEntity.Spawn();\r\n\t}\r\n\tInvoke(FinishUp, 210f);\r\n\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\tSendNetworkUpdateImmediate();\r\n}\r\n",
    "targetName": "SupplySignal",
    "methodName": "Explode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnWaterPurify",
    "fullName": "OnWaterPurify",
    "category": "Entity",
    "parameters": [
      {
        "name": "waterPurifier",
        "type": "WaterPurifier, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ConvertWater(float timeCooked)\r\n{\r\n\tif (stopWhenOutputFull)\r\n\t{\r\n\t\tItem slot = waterStorage.inventory.GetSlot(0);\r\n\t\tif (slot != null && slot.amount >= slot.MaxStackable())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tfloat num = timeCooked * ((float)waterToProcessPerMinute / 60f);\r\n\tdirtyWaterProcssed += num;\r\n\tif (dirtyWaterProcssed >= 1f)\r\n\t{\r\n\t\tItem slot2 = base.inventory.GetSlot(0);\r\n\t\tint num2 = UnityEngine.Mathf.Min(UnityEngine.Mathf.FloorToInt(dirtyWaterProcssed), slot2.amount);\r\n\t\tnum = num2;\r\n\t\tslot2.UseItem(num2);\r\n\t\tdirtyWaterProcssed -= num2;\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n\tpendingFreshWater += num / (float)freshWaterRatio;\r\n\tif (!(pendingFreshWater >= 1f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num3 = UnityEngine.Mathf.FloorToInt(pendingFreshWater);\r\n\tpendingFreshWater -= num3;\r\n\tItem slot3 = waterStorage.inventory.GetSlot(0);\r\n\tif (slot3 != null && slot3.info != freshWater)\r\n\t{\r\n\t\tslot3.RemoveFromContainer();\r\n\t\tslot3.Remove();\r\n\t}\r\n\tif (slot3 == null)\r\n\t{\r\n\t\tItem item = ItemManager.Create(freshWater, num3, 0uL);\r\n\t\tif (!item.MoveToContainer(waterStorage.inventory))\r\n\t\t{\r\n\t\t\titem.Remove();\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tslot3.amount += num3;\r\n\t\tslot3.amount = UnityEngine.Mathf.Clamp(slot3.amount, 0, waterStorage.maxStackSize);\r\n\t\twaterStorage.inventory.MarkDirty();\r\n\t}\r\n\twaterStorage.SendNetworkUpdate();\r\n}\r\n",
    "targetName": "WaterPurifier",
    "methodName": "ConvertWater",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWaterPurified",
    "fullName": "OnWaterPurified",
    "category": "Entity",
    "parameters": [
      {
        "name": "waterPurifier",
        "type": "WaterPurifier, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ConvertWater(float timeCooked)\r\n{\r\n\tif (stopWhenOutputFull)\r\n\t{\r\n\t\tItem slot = waterStorage.inventory.GetSlot(0);\r\n\t\tif (slot != null && slot.amount >= slot.MaxStackable())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tfloat num = timeCooked * ((float)waterToProcessPerMinute / 60f);\r\n\tdirtyWaterProcssed += num;\r\n\tif (dirtyWaterProcssed >= 1f)\r\n\t{\r\n\t\tItem slot2 = base.inventory.GetSlot(0);\r\n\t\tint num2 = UnityEngine.Mathf.Min(UnityEngine.Mathf.FloorToInt(dirtyWaterProcssed), slot2.amount);\r\n\t\tnum = num2;\r\n\t\tslot2.UseItem(num2);\r\n\t\tdirtyWaterProcssed -= num2;\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n\tpendingFreshWater += num / (float)freshWaterRatio;\r\n\tif (!(pendingFreshWater >= 1f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num3 = UnityEngine.Mathf.FloorToInt(pendingFreshWater);\r\n\tpendingFreshWater -= num3;\r\n\tItem slot3 = waterStorage.inventory.GetSlot(0);\r\n\tif (slot3 != null && slot3.info != freshWater)\r\n\t{\r\n\t\tslot3.RemoveFromContainer();\r\n\t\tslot3.Remove();\r\n\t}\r\n\tif (slot3 == null)\r\n\t{\r\n\t\tItem item = ItemManager.Create(freshWater, num3, 0uL);\r\n\t\tif (!item.MoveToContainer(waterStorage.inventory))\r\n\t\t{\r\n\t\t\titem.Remove();\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tslot3.amount += num3;\r\n\t\tslot3.amount = UnityEngine.Mathf.Clamp(slot3.amount, 0, waterStorage.maxStackSize);\r\n\t\twaterStorage.inventory.MarkDirty();\r\n\t}\r\n\twaterStorage.SendNetworkUpdate();\r\n}\r\n",
    "targetName": "WaterPurifier",
    "methodName": "ConvertWater",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnWaterCollect",
    "fullName": "OnWaterCollect [WaterCatcher]",
    "category": "Entity",
    "parameters": [
      {
        "name": "waterCatcher",
        "type": "WaterCatcher, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CollectWater()\r\n{\r\n\tif (!IsFull())\r\n\t{\r\n\t\tfloat baseRate = collectionRates.baseRate;\r\n\t\tbaseRate += Climate.GetFog(base.transform.position) * collectionRates.fogRate;\r\n\t\tif (TestIsOutside(base.transform, rainTestPosition, rainTestSize, 256f))\r\n\t\t{\r\n\t\t\tbaseRate += Climate.GetRain(base.transform.position) * collectionRates.rainRate;\r\n\t\t\tbaseRate += Climate.GetSnow(base.transform.position) * collectionRates.snowRate;\r\n\t\t}\r\n\t\tAddResource(UnityEngine.Mathf.CeilToInt(maxItemToCreate * baseRate));\r\n\t}\r\n}\r\n",
    "targetName": "WaterCatcher",
    "methodName": "CollectWater",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLiquidVesselFill",
    "fullName": "OnLiquidVesselFill",
    "category": "Entity",
    "parameters": [
      {
        "name": "baseLiquidVessel",
        "type": "BaseLiquidVessel, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "LiquidContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void FillCheck()\r\n{\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat f = (UnityEngine.Time.realtimeSinceStartup - lastFillTime) * fillMlPerSec;\r\n\tUnityEngine.Vector3 pos = ownerPlayer.transform.position - new UnityEngine.Vector3(0f, 1f, 0f);\r\n\tLiquidContainer facingLiquidContainer = GetFacingLiquidContainer();\r\n\tif (facingLiquidContainer == null && CanFillFromWorld())\r\n\t{\r\n\t\tItem contents = GetContents();\r\n\t\tItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(pos);\r\n\t\tif (contents != null && contents.info.itemid != itemDefinition.itemid)\r\n\t\t{\r\n\t\t\tif ((float)timeSinceLastToast > 5f)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.Log(\"pushing toast\");\r\n\t\t\t\ttimeSinceLastToast = 0f;\r\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Red_Normal, DifferentLiquidType, false);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tAddLiquid(itemDefinition, UnityEngine.Mathf.FloorToInt(f));\r\n\t}\r\n\telse if (facingLiquidContainer != null && facingLiquidContainer.HasLiquidItem())\r\n\t{\r\n\t\tint num = UnityEngine.Mathf.CeilToInt((1f - HeldFraction()) * (float)MaxHoldable());\r\n\t\tif (num > 0)\r\n\t\t{\r\n\t\t\tGetContents();\r\n\t\t\tItem liquidItem = facingLiquidContainer.GetLiquidItem();\r\n\t\t\tint num2 = UnityEngine.Mathf.Min(UnityEngine.Mathf.CeilToInt(f), UnityEngine.Mathf.Min(liquidItem.amount, num));\r\n\t\t\tAddLiquid(liquidItem.info, num2);\r\n\t\t\tliquidItem.UseItem(num2);\r\n\t\t\tfacingLiquidContainer.OpenTap(2f);\r\n\t\t}\r\n\t}\r\n\tlastFillTime = UnityEngine.Time.realtimeSinceStartup;\r\n}\r\n",
    "targetName": "BaseLiquidVessel",
    "methodName": "FillCheck",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDecayHeal",
    "fullName": "OnDecayHeal",
    "category": "Entity",
    "parameters": [
      {
        "name": "decayEntity",
        "type": "DecayEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnDecay(Decay decay, float decayDeltaTime)\r\n{\r\n\tlastDecayTick = UnityEngine.Time.time;\r\n\tif (HasParent() || !decay.ShouldDecay(this))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = decayDeltaTime * ConVar.Decay.scale;\r\n\tif (ConVar.Decay.upkeep)\r\n\t{\r\n\t\tupkeepTimer += num;\r\n\t\tif (upkeepTimer > 0f)\r\n\t\t{\r\n\t\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\r\n\t\t\tif (buildingPrivilege != null)\r\n\t\t\t{\r\n\t\t\t\tupkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, UnityEngine.Mathf.Max(upkeepTimer, 600f));\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (upkeepTimer < 1f)\r\n\t\t{\r\n\t\t\tif (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f)\r\n\t\t\t{\r\n\t\t\t\tfloat num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();\r\n\t\t\t\tHeal(MaxHealth() * num2);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tupkeepTimer = 1f;\r\n\t}\r\n\tdecayTimer += num;\r\n\tif (decayTimer < GetEntityDecayDelay())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"DecayTick\"))\r\n\t{\r\n\t\tfloat num3 = 1f;\r\n\t\tif (ConVar.Decay.upkeep)\r\n\t\t{\r\n\t\t\tif (!BypassInsideDecayMultiplier && !IsOutside())\r\n\t\t\t{\r\n\t\t\t\tnum3 *= ConVar.Decay.upkeep_inside_decay_scale;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < decayPoints.Length; i++)\r\n\t\t\t{\r\n\t\t\t\tDecayPoint decayPoint = decayPoints[i];\r\n\t\t\t\tif (decayPoint.IsOccupied(this))\r\n\t\t\t\t{\r\n\t\t\t\t\tnum3 -= decayPoint.protection;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (num3 > 0f)\r\n\t\t{\r\n\t\t\tfloat num4 = num / GetEntityDecayDuration() * MaxHealth();\r\n\t\t\tHurt(num4 * num3 * decayVariance, Rust.DamageType.Decay);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "DecayEntity",
    "methodName": "OnDecay",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDecayDamage",
    "fullName": "OnDecayDamage",
    "category": "Entity",
    "parameters": [
      {
        "name": "decayEntity",
        "type": "DecayEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnDecay(Decay decay, float decayDeltaTime)\r\n{\r\n\tlastDecayTick = UnityEngine.Time.time;\r\n\tif (HasParent() || !decay.ShouldDecay(this))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = decayDeltaTime * ConVar.Decay.scale;\r\n\tif (ConVar.Decay.upkeep)\r\n\t{\r\n\t\tupkeepTimer += num;\r\n\t\tif (upkeepTimer > 0f)\r\n\t\t{\r\n\t\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\r\n\t\t\tif (buildingPrivilege != null)\r\n\t\t\t{\r\n\t\t\t\tupkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, UnityEngine.Mathf.Max(upkeepTimer, 600f));\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (upkeepTimer < 1f)\r\n\t\t{\r\n\t\t\tif (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f)\r\n\t\t\t{\r\n\t\t\t\tfloat num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();\r\n\t\t\t\tHeal(MaxHealth() * num2);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tupkeepTimer = 1f;\r\n\t}\r\n\tdecayTimer += num;\r\n\tif (decayTimer < GetEntityDecayDelay())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"DecayTick\"))\r\n\t{\r\n\t\tfloat num3 = 1f;\r\n\t\tif (ConVar.Decay.upkeep)\r\n\t\t{\r\n\t\t\tif (!BypassInsideDecayMultiplier && !IsOutside())\r\n\t\t\t{\r\n\t\t\t\tnum3 *= ConVar.Decay.upkeep_inside_decay_scale;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < decayPoints.Length; i++)\r\n\t\t\t{\r\n\t\t\t\tDecayPoint decayPoint = decayPoints[i];\r\n\t\t\t\tif (decayPoint.IsOccupied(this))\r\n\t\t\t\t{\r\n\t\t\t\t\tnum3 -= decayPoint.protection;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (num3 > 0f)\r\n\t\t{\r\n\t\t\tfloat num4 = num / GetEntityDecayDuration() * MaxHealth();\r\n\t\t\tHurt(num4 * num3 * decayVariance, Rust.DamageType.Decay);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "DecayEntity",
    "methodName": "OnDecay",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDebrisSpawn",
    "fullName": "OnDebrisSpawn",
    "category": "Entity",
    "parameters": [
      {
        "name": "decayEntity",
        "type": "DecayEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SpawnDebris(UnityEngine.Vector3 localPos, UnityEngine.Quaternion rot, bool dropToTerrain)\r\n{\r\n\tUnityEngine.Vector3 vector = base.transform.TransformPoint(localPos);\r\n\tif (dropToTerrain && UnityEngine.Physics.Raycast(vector, UnityEngine.Vector3.down, out var hitInfo, 6f, 8388608))\r\n\t{\r\n\t\tfloat num = vector.y - hitInfo.point.y;\r\n\t\tvector.y = hitInfo.point.y;\r\n\t\tlocalPos.y -= num;\r\n\t}\r\n\tSystem.Collections.Generic.List<DebrisEntity> obj = Facepunch.Pool.Get<System.Collections.Generic.List<DebrisEntity>>();\r\n\tVis.Entities(vector, 0.1f, obj, 256);\r\n\tif (obj.Count > 0)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity baseEntity = GameManager.server.CreateEntity(debrisPrefab.resourcePath, base.transform.TransformPoint(localPos), base.transform.rotation * rot);\r\n\tif ((bool)baseEntity)\r\n\t{\r\n\t\tbaseEntity.SetParent(parentEntity.Get(serverside: true), worldPositionStays: true);\r\n\t\tbaseEntity.Spawn();\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n}\r\n",
    "targetName": "DecayEntity",
    "methodName": "SpawnDebris",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWindmillUpdate",
    "fullName": "OnWindmillUpdate",
    "category": "Entity",
    "parameters": [
      {
        "name": "electricWindmill",
        "type": "ElectricWindmill, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void WindUpdate()\r\n{\r\n\tserverWindSpeed = GetWindSpeedScale();\r\n\tif (!AmIVisible())\r\n\t{\r\n\t\tserverWindSpeed = 0f;\r\n\t}\r\n\tint num = UnityEngine.Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);\r\n\tbool num2 = currentEnergy != num;\r\n\tcurrentEnergy = num;\r\n\tif (num2)\r\n\t{\r\n\t\tMarkDirty();\r\n\t}\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "ElectricWindmill",
    "methodName": "WindUpdate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWindmillUpdated",
    "fullName": "OnWindmillUpdated",
    "category": "Entity",
    "parameters": [
      {
        "name": "electricWindmill",
        "type": "ElectricWindmill, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void WindUpdate()\r\n{\r\n\tserverWindSpeed = GetWindSpeedScale();\r\n\tif (!AmIVisible())\r\n\t{\r\n\t\tserverWindSpeed = 0f;\r\n\t}\r\n\tint num = UnityEngine.Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);\r\n\tbool num2 = currentEnergy != num;\r\n\tcurrentEnergy = num;\r\n\tif (num2)\r\n\t{\r\n\t\tMarkDirty();\r\n\t}\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "ElectricWindmill",
    "methodName": "WindUpdate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnWaterCollect",
    "fullName": "OnWaterCollect [WaterPump]",
    "category": "Entity",
    "parameters": [
      {
        "name": "waterPump",
        "type": "WaterPump, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CreateWater()\r\n{\r\n\tif (!IsFull())\r\n\t{\r\n\t\tItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(WaterResourceLocation.position);\r\n\t\tif (itemDefinition != null)\r\n\t\t{\r\n\t\t\tbase.inventory.AddItem(itemDefinition, AmountPerPump, 0uL);\r\n\t\t\tUpdateOnFlag();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WaterPump",
    "methodName": "CreateWater",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSprinklerSplashed",
    "fullName": "OnSprinklerSplashed",
    "category": "Entity",
    "parameters": [
      {
        "name": "sprinkler",
        "type": "Sprinkler, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoSplash()\r\n{\r\n\tusing (TimeWarning.New(\"SprinklerSplash\"))\r\n\t{\r\n\t\tint num = WaterPerSplash;\r\n\t\tif ((float)updateSplashableCache > SplashFrequency * 4f || forceUpdateSplashables)\r\n\t\t{\r\n\t\t\tcachedSplashables.Clear();\r\n\t\t\tforceUpdateSplashables = false;\r\n\t\t\tupdateSplashableCache = 0f;\r\n\t\t\tUnityEngine.Vector3 position = Eyes.position;\r\n\t\t\tUnityEngine.Vector3 up = base.transform.up;\r\n\t\t\tfloat sprinklerEyeHeightOffset = ConVar.Server.sprinklerEyeHeightOffset;\r\n\t\t\tfloat value = UnityEngine.Vector3.Angle(up, UnityEngine.Vector3.up) / 180f;\r\n\t\t\tvalue = UnityEngine.Mathf.Clamp(value, 0.2f, 1f);\r\n\t\t\tsprinklerEyeHeightOffset *= value;\r\n\t\t\tUnityEngine.Vector3 startPosition = position + up * (ConVar.Server.sprinklerRadius * 0.5f);\r\n\t\t\tUnityEngine.Vector3 endPosition = position + up * sprinklerEyeHeightOffset;\r\n\t\t\tSystem.Collections.Generic.List<BaseEntity> obj = Facepunch.Pool.Get<System.Collections.Generic.List<BaseEntity>>();\r\n\t\t\tVis.Entities(startPosition, endPosition, ConVar.Server.sprinklerRadius, obj, 1237003025);\r\n\t\t\tif (obj.Count > 0)\r\n\t\t\t{\r\n\t\t\t\tforeach (BaseEntity item in obj)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!item.isClient && item is ISplashable splashable && !cachedSplashables.Contains(splashable) && splashable.WantsSplash(currentFuelType, num) && item.IsVisible(position) && (!(item is IOEntity entity) || !IsConnectedTo(entity, IOEntity.backtracking)) && (!(item is BasePlayer) || !(currentFuelType.baseRadioactivity > 0f)))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcachedSplashables.Add(splashable);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\t}\r\n\t\tif (cachedSplashables.Count > 0)\r\n\t\t{\r\n\t\t\tint num2 = num / cachedSplashables.Count;\r\n\t\t\tfloat num3 = (float)(num % cachedSplashables.Count) / (float)cachedSplashables.Count;\r\n\t\t\tforeach (ISplashable cachedSplashable in cachedSplashables)\r\n\t\t\t{\r\n\t\t\t\tint amount = num2 + ((UnityEngine.Random.value < num3) ? 1 : 0);\r\n\t\t\t\tif (!cachedSplashable.IsUnityNull() && cachedSplashable.WantsSplash(currentFuelType, amount))\r\n\t\t\t\t{\r\n\t\t\t\t\tint num4 = cachedSplashable.DoSplash(currentFuelType, amount);\r\n\t\t\t\t\tnum -= num4;\r\n\t\t\t\t\tif (num <= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (DecayPerSplash > 0f)\r\n\t\t{\r\n\t\t\tHurt(DecayPerSplash);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Sprinkler",
    "methodName": "DoSplash",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanWaterBallSplash",
    "fullName": "CanWaterBallSplash",
    "category": "Entity",
    "parameters": [
      {
        "name": "liquidDef",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "position",
        "type": "UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "radius",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "amount",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool DoSplash(UnityEngine.Vector3 position, float radius, ItemDefinition liquidDef, int amount)\r\n{\r\n\tSystem.Collections.Generic.List<BaseEntity> obj = Facepunch.Pool.Get<System.Collections.Generic.List<BaseEntity>>();\r\n\tVis.Entities(position, radius, obj, 1220225811);\r\n\tint num = 0;\r\n\tint num2 = amount;\r\n\tbool flag = false;\r\n\twhile (amount > 0 && num < 3)\r\n\t{\r\n\t\tSystem.Collections.Generic.List<ISplashable> obj2 = Facepunch.Pool.Get<System.Collections.Generic.List<ISplashable>>();\r\n\t\tforeach (BaseEntity item in obj)\r\n\t\t{\r\n\t\t\tif (item.isClient || !(item is ISplashable splashable) || obj2.Contains(splashable) || !splashable.WantsSplash(liquidDef, amount))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tbool flag2 = true;\r\n\t\t\tif (item is PlanterBox)\r\n\t\t\t{\r\n\t\t\t\tif (!GamePhysics.LineOfSight(item.transform.position + new UnityEngine.Vector3(0f, 1f, 0f), position, 2097152))\r\n\t\t\t\t{\r\n\t\t\t\t\tflag2 = false;\r\n\t\t\t\t}\r\n\t\t\t\tif (flag2)\r\n\t\t\t\t{\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (flag2)\r\n\t\t\t{\r\n\t\t\t\tobj2.Add(splashable);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (obj2.Count == 0)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tint b = UnityEngine.Mathf.CeilToInt(amount / obj2.Count);\r\n\t\tforeach (ISplashable item2 in obj2)\r\n\t\t{\r\n\t\t\tif (!flag || !(item2 is BasePlayer))\r\n\t\t\t{\r\n\t\t\t\tint num3 = item2.DoSplash(liquidDef, UnityEngine.Mathf.Min(amount, b));\r\n\t\t\t\tamount -= num3;\r\n\t\t\t\tif (amount <= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\r\n\t\tnum++;\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\treturn amount < num2;\r\n}\r\n",
    "targetName": "WaterBall",
    "methodName": "DoSplash",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPhotoCapture",
    "fullName": "OnPhotoCapture",
    "category": "Entity",
    "parameters": [
      {
        "name": "local5",
        "type": "PhotoEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(3uL)]\r\npublic void TakePhoto(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tItem item = GetItem();\r\n\tif (player == null || item == null || item.condition <= 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbyte[] array = msg.read.BytesWithSize();\r\n\tif (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem item2 = ItemManager.Create(photoItem, 1, 0uL);\r\n\tif (item2 == null)\r\n\t{\r\n\t\tUnityEngine.Debug.LogError(\"Failed to create photo item\");\r\n\t\treturn;\r\n\t}\r\n\titem2.SetItemOwnership(msg.player, ItemOwnershipPhrases.Photographed);\r\n\tif (!item2.instanceData.subEntity.IsValid)\r\n\t{\r\n\t\titem2.Remove();\r\n\t\tUnityEngine.Debug.LogError(\"Photo has no sub-entity\");\r\n\t\treturn;\r\n\t}\r\n\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);\r\n\tif (baseNetworkable == null)\r\n\t{\r\n\t\titem2.Remove();\r\n\t\tUnityEngine.Debug.LogError(\"Sub-entity was not found\");\r\n\t\treturn;\r\n\t}\r\n\tif (!(baseNetworkable is PhotoEntity photoEntity))\r\n\t{\r\n\t\titem2.Remove();\r\n\t\tUnityEngine.Debug.LogError(\"Sub-entity is not a photo\");\r\n\t\treturn;\r\n\t}\r\n\tphotoEntity.SetImageData(player.userID, array);\r\n\tif (!player.inventory.GiveItem(item2))\r\n\t{\r\n\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\r\n\t}\r\n\tEffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));\r\n\tif (!hasSentAchievement && !string.IsNullOrEmpty(\"SUMMER_PAPARAZZI\"))\r\n\t{\r\n\t\tUnityEngine.Vector3 position = GetOwnerPlayer().eyes.position;\r\n\t\tUnityEngine.Vector3 vector = GetOwnerPlayer().eyes.HeadForward();\r\n\t\tSystem.Collections.Generic.List<BasePlayer> obj = Facepunch.Pool.Get<System.Collections.Generic.List<BasePlayer>>();\r\n\t\tVis.Entities(position + vector * 5f, 5f, obj, 131072);\r\n\t\tforeach (BasePlayer item3 in obj)\r\n\t\t{\r\n\t\t\tif (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))\r\n\t\t\t{\r\n\t\t\t\thasSentAchievement = true;\r\n\t\t\t\tGetOwnerPlayer().GiveAchievement(\"SUMMER_PAPARAZZI\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t}\r\n\titem.LoseCondition(1f);\r\n}\r\n",
    "targetName": "InstantCameraTool",
    "methodName": "TakePhoto",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPhotoCaptured",
    "fullName": "OnPhotoCaptured",
    "category": "Entity",
    "parameters": [
      {
        "name": "local5",
        "type": "PhotoEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(3uL)]\r\npublic void TakePhoto(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tItem item = GetItem();\r\n\tif (player == null || item == null || item.condition <= 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbyte[] array = msg.read.BytesWithSize();\r\n\tif (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem item2 = ItemManager.Create(photoItem, 1, 0uL);\r\n\tif (item2 == null)\r\n\t{\r\n\t\tUnityEngine.Debug.LogError(\"Failed to create photo item\");\r\n\t\treturn;\r\n\t}\r\n\titem2.SetItemOwnership(msg.player, ItemOwnershipPhrases.Photographed);\r\n\tif (!item2.instanceData.subEntity.IsValid)\r\n\t{\r\n\t\titem2.Remove();\r\n\t\tUnityEngine.Debug.LogError(\"Photo has no sub-entity\");\r\n\t\treturn;\r\n\t}\r\n\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);\r\n\tif (baseNetworkable == null)\r\n\t{\r\n\t\titem2.Remove();\r\n\t\tUnityEngine.Debug.LogError(\"Sub-entity was not found\");\r\n\t\treturn;\r\n\t}\r\n\tif (!(baseNetworkable is PhotoEntity photoEntity))\r\n\t{\r\n\t\titem2.Remove();\r\n\t\tUnityEngine.Debug.LogError(\"Sub-entity is not a photo\");\r\n\t\treturn;\r\n\t}\r\n\tphotoEntity.SetImageData(player.userID, array);\r\n\tif (!player.inventory.GiveItem(item2))\r\n\t{\r\n\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\r\n\t}\r\n\tEffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));\r\n\tif (!hasSentAchievement && !string.IsNullOrEmpty(\"SUMMER_PAPARAZZI\"))\r\n\t{\r\n\t\tUnityEngine.Vector3 position = GetOwnerPlayer().eyes.position;\r\n\t\tUnityEngine.Vector3 vector = GetOwnerPlayer().eyes.HeadForward();\r\n\t\tSystem.Collections.Generic.List<BasePlayer> obj = Facepunch.Pool.Get<System.Collections.Generic.List<BasePlayer>>();\r\n\t\tVis.Entities(position + vector * 5f, 5f, obj, 131072);\r\n\t\tforeach (BasePlayer item3 in obj)\r\n\t\t{\r\n\t\t\tif (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))\r\n\t\t\t{\r\n\t\t\t\thasSentAchievement = true;\r\n\t\t\t\tGetOwnerPlayer().GiveAchievement(\"SUMMER_PAPARAZZI\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t}\r\n\titem.LoseCondition(1f);\r\n}\r\n",
    "targetName": "InstantCameraTool",
    "methodName": "TakePhoto",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTreeMarkerHit",
    "fullName": "OnTreeMarkerHit",
    "category": "Entity",
    "parameters": [
      {
        "name": "treeEntity",
        "type": "TreeEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool DidHitMarker(HitInfo info)\r\n{\r\n\tif (xMarker == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (PrefabAttribute.server.Find<TreeMarkerData>(prefabID) != null)\r\n\t{\r\n\t\tif (new UnityEngine.Bounds(xMarker.transform.position, UnityEngine.Vector3.one * 0.2f).Contains(info.HitPositionWorld))\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tUnityEngine.Vector3 lhs = UnityEngine.Vector3Ex.Direction2D(base.transform.position, xMarker.transform.position);\r\n\t\tUnityEngine.Vector3 attackNormal = info.attackNormal;\r\n\t\tfloat num = UnityEngine.Vector3.Dot(lhs, attackNormal);\r\n\t\tfloat num2 = UnityEngine.Vector3.Distance(xMarker.transform.position, info.HitPositionWorld);\r\n\t\tif (num >= 0.3f && num2 <= 0.2f)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "TreeEntity",
    "methodName": "DidHitMarker",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnSprayRemove",
    "fullName": "OnSprayRemove",
    "category": "Entity",
    "parameters": [
      {
        "name": "sprayCanSpray",
        "type": "SprayCanSpray, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void Server_RequestWaterClear(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && Menu_WaterClear_ShowIf(player))\r\n\t{\r\n\t\tKill();\r\n\t}\r\n}\r\n",
    "targetName": "SprayCanSpray",
    "methodName": "Server_RequestWaterClear",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnComposterUpdate",
    "fullName": "OnComposterUpdate",
    "category": "Entity",
    "parameters": [
      {
        "name": "composter",
        "type": "Composter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateComposting()\r\n{\r\n\tfor (int i = 0; i < base.inventory.capacity; i++)\r\n\t{\r\n\t\tItem slot = base.inventory.GetSlot(i);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tCompostItem(slot);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Composter",
    "methodName": "UpdateComposting",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRemoteIdentifierUpdate",
    "fullName": "OnRemoteIdentifierUpdate",
    "category": "Entity",
    "parameters": [
      {
        "name": "poweredRemoteControlEntity",
        "type": "PoweredRemoteControlEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "newID",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateIdentifier(string newID, bool clientSend = false)\r\n{\r\n\t_ = rcIdentifier;\r\n\tif (base.isServer)\r\n\t{\r\n\t\tif (!RemoteControlEntity.IDInUse(newID))\r\n\t\t{\r\n\t\t\trcIdentifier = newID;\r\n\t\t}\r\n\t\tif (!Rust.Application.isLoadingSave)\r\n\t\t{\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "PoweredRemoteControlEntity",
    "methodName": "UpdateIdentifier",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSwitchToggle",
    "fullName": "OnSwitchToggle [IndustrialConveyor]",
    "category": "Entity",
    "parameters": [
      {
        "name": "industrialConveyor",
        "type": "IndustrialConveyor, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(2uL)]\r\npublic void SvSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tSetSwitch(!IsOn());\r\n}\r\n",
    "targetName": "IndustrialConveyor",
    "methodName": "SvSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSwitchToggled",
    "fullName": "OnSwitchToggled [IndustrialConveyor]",
    "category": "Entity",
    "parameters": [
      {
        "name": "industrialConveyor",
        "type": "IndustrialConveyor, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(2uL)]\r\npublic void SvSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tSetSwitch(!IsOn());\r\n}\r\n",
    "targetName": "IndustrialConveyor",
    "methodName": "SvSwitch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanExplosiveStick",
    "fullName": "CanExplosiveStick",
    "category": "Entity",
    "parameters": [
      {
        "name": "timedExplosive",
        "type": "TimedExplosive, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CanStickTo(BaseEntity entity)\r\n{\r\n\tif (entity.TryGetComponent<DecorDeployable>(out var _))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (entity is Drone)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (entity is TravellingVendor)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "TimedExplosive",
    "methodName": "CanStickTo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPatrolHelicopterTakeDamage",
    "fullName": "OnPatrolHelicopterTakeDamage",
    "category": "Entity",
    "parameters": [
      {
        "name": "patrolHelicopter",
        "type": "PatrolHelicopter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void Hurt(HitInfo info)\r\n{\r\n\tbool flag = false;\r\n\tif (info.damageTypes.Total() >= base.health)\r\n\t{\r\n\t\tbase.health = 10000f;\r\n\t\tmyAI.CriticalDamage();\r\n\t\tflag = true;\r\n\t}\r\n\tbase.Hurt(info);\r\n\tif (flag)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tmyAI.OtherDamaged(info);\r\n\tPatrolHelicopter.weakspot[] array = weakspots;\r\n\tforeach (PatrolHelicopter.weakspot weakspot in array)\r\n\t{\r\n\t\tstring[] bonenames = weakspot.bonenames;\r\n\t\tforeach (string str in bonenames)\r\n\t\t{\r\n\t\t\tif (info.HitBone == StringPool.Get(str))\r\n\t\t\t{\r\n\t\t\t\tweakspot.Hurt(info.damageTypes.Total(), info);\r\n\t\t\t\tmyAI.WeakspotDamaged(weakspot, info);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "PatrolHelicopter",
    "methodName": "Hurt",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPatrolHelicopterKill",
    "fullName": "OnPatrolHelicopterKill",
    "category": "Entity",
    "parameters": [
      {
        "name": "patrolHelicopter",
        "type": "PatrolHelicopter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void Hurt(HitInfo info)\r\n{\r\n\tbool flag = false;\r\n\tif (info.damageTypes.Total() >= base.health)\r\n\t{\r\n\t\tbase.health = 10000f;\r\n\t\tmyAI.CriticalDamage();\r\n\t\tflag = true;\r\n\t}\r\n\tbase.Hurt(info);\r\n\tif (flag)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tmyAI.OtherDamaged(info);\r\n\tPatrolHelicopter.weakspot[] array = weakspots;\r\n\tforeach (PatrolHelicopter.weakspot weakspot in array)\r\n\t{\r\n\t\tstring[] bonenames = weakspot.bonenames;\r\n\t\tforeach (string str in bonenames)\r\n\t\t{\r\n\t\t\tif (info.HitBone == StringPool.Get(str))\r\n\t\t\t{\r\n\t\t\t\tweakspot.Hurt(info.damageTypes.Total(), info);\r\n\t\t\t\tmyAI.WeakspotDamaged(weakspot, info);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "PatrolHelicopter",
    "methodName": "Hurt",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlanterBoxFertilize",
    "fullName": "OnPlanterBoxFertilize",
    "category": "Entity",
    "parameters": [
      {
        "name": "planterBox",
        "type": "PlanterBox, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void FertilizeGrowables()\r\n{\r\n\tint num = GetFertilizerCount();\r\n\tif (num <= 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (BaseEntity child in children)\r\n\t{\r\n\t\tif (child == null)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tGrowableEntity growableEntity = child as GrowableEntity;\r\n\t\tif (!(growableEntity == null) && !growableEntity.Fertilized && ConsumeFertilizer())\r\n\t\t{\r\n\t\t\tgrowableEntity.Fertilize();\r\n\t\t\tnum--;\r\n\t\t\tif (num == 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "PlanterBox",
    "methodName": "FertilizeGrowables",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNoGoZoneAdded",
    "fullName": "OnNoGoZoneAdded",
    "category": "Entity",
    "parameters": [
      {
        "name": "patrolHelicopterAI",
        "type": "PatrolHelicopterAI, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void NoGoZoneAdded(PatrolHelicopterAI.DangerZone zone)\r\n{\r\n\tif (use_danger_zones && zone.IsPointInside(base.transform.position))\r\n\t{\r\n\t\tClearTargets();\r\n\t\tExitCurrentState();\r\n\t\tUnityEngine.Vector3 nearestEdge = zone.GetNearestEdge(base.transform.position);\r\n\t\tnearestEdge.y = UnityEngine.Random.Range(35f, 45f);\r\n\t\tState_Flee_Enter(nearestEdge);\r\n\t}\r\n}\r\n",
    "targetName": "PatrolHelicopterAI",
    "methodName": "NoGoZoneAdded",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEventTrigger",
    "fullName": "OnEventTrigger",
    "category": "Entity",
    "parameters": [
      {
        "name": "triggeredEventPrefab",
        "type": "TriggeredEventPrefab, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void RunEvent()\r\n{\r\n\tUnityEngine.Debug.Log(\"[event] \" + targetPrefab.resourcePath);\r\n\tBaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);\r\n\tif (!baseEntity)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbaseEntity.SendMessage(\"TriggeredEventSpawn\", UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\tbaseEntity.Spawn();\r\n\tspawnedEntity = baseEntity;\r\n\tif (!shouldBroadcastSpawn)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\r\n\t{\r\n\t\tif ((bool)activePlayer && activePlayer.IsConnected && !activePlayer.IsInTutorial)\r\n\t\t{\r\n\t\t\tactivePlayer.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "TriggeredEventPrefab",
    "methodName": "RunEvent",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanLootEntity",
    "fullName": "CanLootEntity",
    "category": "Entity",
    "parameters": [
      {
        "name": "worldItem",
        "type": "WorldItem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_OpenLoot(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (item == null || item.contents == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemModContainer component = item.info.GetComponent<ItemModContainer>();\r\n\tif (!(component == null) && component.canLootInWorld)\r\n\t{\r\n\t\tBasePlayer player = rpc.player;\r\n\t\tif ((bool)player && player.CanInteract() && CanOpenInSafeZone(player) && player.inventory.loot.StartLootingEntity(this))\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Open, b: true);\r\n\t\t\tplayer.inventory.loot.AddContainer(item.contents);\r\n\t\t\tplayer.inventory.loot.SendImmediate();\r\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\"RPC_OpenLootPanel\", player), \"generic_resizable\");\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WorldItem",
    "methodName": "RPC_OpenLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFreeableContainerRelease",
    "fullName": "OnFreeableContainerRelease",
    "category": "Entity",
    "parameters": [
      {
        "name": "freeableLootContainer",
        "type": "FreeableLootContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Release(BasePlayer ply)\r\n{\r\n\tGetRB().isKinematic = false;\r\n\tbuoyancy.enabled = true;\r\n\tbuoyancy.buoyancyScale = 1f;\r\n\tSetFlag(BaseEntity.Flags.Reserved8, b: false);\r\n\tif (freedEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(freedEffect.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t}\r\n\tif (ply != null && !ply.IsNpc && ply.IsConnected && net != null)\r\n\t{\r\n\t\tply.ProcessMissionEvent(BaseMission.MissionEventType.FREE_CRATE, net.ID, 1f);\r\n\t\tFacepunch.Rust.Analytics.Server.FreeUnderwaterCrate();\r\n\t\tFacepunch.Rust.Analytics.Azure.OnFreeUnderwaterCrate(ply, this);\r\n\t}\r\n}\r\n",
    "targetName": "FreeableLootContainer",
    "methodName": "Release",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFreeableContainerReleased",
    "fullName": "OnFreeableContainerReleased",
    "category": "Entity",
    "parameters": [
      {
        "name": "freeableLootContainer",
        "type": "FreeableLootContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Release(BasePlayer ply)\r\n{\r\n\tGetRB().isKinematic = false;\r\n\tbuoyancy.enabled = true;\r\n\tbuoyancy.buoyancyScale = 1f;\r\n\tSetFlag(BaseEntity.Flags.Reserved8, b: false);\r\n\tif (freedEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(freedEffect.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t}\r\n\tif (ply != null && !ply.IsNpc && ply.IsConnected && net != null)\r\n\t{\r\n\t\tply.ProcessMissionEvent(BaseMission.MissionEventType.FREE_CRATE, net.ID, 1f);\r\n\t\tFacepunch.Rust.Analytics.Server.FreeUnderwaterCrate();\r\n\t\tFacepunch.Rust.Analytics.Azure.OnFreeUnderwaterCrate(ply, this);\r\n\t}\r\n}\r\n",
    "targetName": "FreeableLootContainer",
    "methodName": "Release",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFreeableContainerReleaseStarted",
    "fullName": "OnFreeableContainerReleaseStarted",
    "category": "Entity",
    "parameters": [
      {
        "name": "freeableLootContainer",
        "type": "FreeableLootContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_FreeCrateTimer(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (IsTiedDown())\r\n\t{\r\n\t\tstartUntieTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t}\r\n}\r\n",
    "targetName": "FreeableLootContainer",
    "methodName": "RPC_FreeCrateTimer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnBigWheelLoss",
    "fullName": "OnBigWheelLoss",
    "category": "Entity",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Payout()\r\n{\r\n\tHitNumber currentHitType = GetCurrentHitType();\r\n\tSystem.Guid value = System.Guid.NewGuid();\r\n\tforeach (BigWheelBettingTerminal terminal in terminals)\r\n\t{\r\n\t\tif (terminal.isClient)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tbool flag = false;\r\n\t\tbool flag2 = false;\r\n\t\tItem slot = terminal.inventory.GetSlot((int)currentHitType.hitType);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\r\n\t\t\tint amount = slot.amount;\r\n\t\t\tslot.amount += slot.amount * num;\r\n\t\t\tslot.RemoveFromContainer();\r\n\t\t\tslot.MoveToContainer(terminal.inventory, 5);\r\n\t\t\tflag = true;\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);\r\n\t\t}\r\n\t\tfor (int i = 0; i < 5; i++)\r\n\t\t{\r\n\t\t\tItem slot2 = terminal.inventory.GetSlot(i);\r\n\t\t\tif (slot2 != null)\r\n\t\t\t{\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);\r\n\t\t\t\tslot2.Remove();\r\n\t\t\t\tflag2 = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag || flag2)\r\n\t\t{\r\n\t\t\tterminal.ClientRPC(RpcTarget.NetworkGroup(\"WinOrLoseSound\"), flag);\r\n\t\t}\r\n\t}\r\n\tItemManager.DoRemoves();\r\n\tSetTerminalsLocked(isLocked: false);\r\n}\r\n",
    "targetName": "BigWheelGame",
    "methodName": "Payout",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBigWheelWin",
    "fullName": "OnBigWheelWin",
    "category": "Entity",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Payout()\r\n{\r\n\tHitNumber currentHitType = GetCurrentHitType();\r\n\tSystem.Guid value = System.Guid.NewGuid();\r\n\tforeach (BigWheelBettingTerminal terminal in terminals)\r\n\t{\r\n\t\tif (terminal.isClient)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tbool flag = false;\r\n\t\tbool flag2 = false;\r\n\t\tItem slot = terminal.inventory.GetSlot((int)currentHitType.hitType);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\r\n\t\t\tint amount = slot.amount;\r\n\t\t\tslot.amount += slot.amount * num;\r\n\t\t\tslot.RemoveFromContainer();\r\n\t\t\tslot.MoveToContainer(terminal.inventory, 5);\r\n\t\t\tflag = true;\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);\r\n\t\t}\r\n\t\tfor (int i = 0; i < 5; i++)\r\n\t\t{\r\n\t\t\tItem slot2 = terminal.inventory.GetSlot(i);\r\n\t\t\tif (slot2 != null)\r\n\t\t\t{\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);\r\n\t\t\t\tslot2.Remove();\r\n\t\t\t\tflag2 = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag || flag2)\r\n\t\t{\r\n\t\t\tterminal.ClientRPC(RpcTarget.NetworkGroup(\"WinOrLoseSound\"), flag);\r\n\t\t}\r\n\t}\r\n\tItemManager.DoRemoves();\r\n\tSetTerminalsLocked(isLocked: false);\r\n}\r\n",
    "targetName": "BigWheelGame",
    "methodName": "Payout",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanDesignFirework",
    "fullName": "CanDesignFirework",
    "category": "Firework",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "patternFirework",
        "type": "PatternFirework, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool PlayerCanModify(BasePlayer player)\r\n{\r\n\tif (player == null || !player.CanInteract())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\r\n\tif (buildingPrivilege != null && !buildingPrivilege.CanAdministrate(player))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "PatternFirework",
    "methodName": "PlayerCanModify",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnFireworkDesignChange",
    "fullName": "OnFireworkDesignChange",
    "category": "Firework",
    "parameters": [
      {
        "name": "patternFirework",
        "type": "PatternFirework, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ProtoBuf.PatternFirework+Design, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void ServerSetFireworkDesign(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!PlayerCanModify(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);\r\n\tif (design?.stars != null)\r\n\t{\r\n\t\twhile (design.stars.Count > MaxStars)\r\n\t\t{\r\n\t\t\tint index = design.stars.Count - 1;\r\n\t\t\tdesign.stars[index].Dispose();\r\n\t\t\tdesign.stars.RemoveAt(index);\r\n\t\t}\r\n\t\tforeach (ProtoBuf.PatternFirework.Star star in design.stars)\r\n\t\t{\r\n\t\t\tstar.position = new UnityEngine.Vector2(UnityEngine.Mathf.Clamp(star.position.x, -1f, 1f), UnityEngine.Mathf.Clamp(star.position.y, -1f, 1f));\r\n\t\t\tstar.color = new UnityEngine.Color(UnityEngine.Mathf.Clamp01(star.color.r), UnityEngine.Mathf.Clamp01(star.color.g), UnityEngine.Mathf.Clamp01(star.color.b), 1f);\r\n\t\t}\r\n\t\tdesign.editedBy = rpc.player.userID;\r\n\t}\r\n\tDesign?.Dispose();\r\n\tDesign = design;\r\n\tSendNetworkUpdateImmediate();\r\n}\r\n",
    "targetName": "PatternFirework",
    "methodName": "ServerSetFireworkDesign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFireworkDesignChanged",
    "fullName": "OnFireworkDesignChanged",
    "category": "Firework",
    "parameters": [
      {
        "name": "patternFirework",
        "type": "PatternFirework, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ProtoBuf.PatternFirework+Design, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void ServerSetFireworkDesign(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!PlayerCanModify(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);\r\n\tif (design?.stars != null)\r\n\t{\r\n\t\twhile (design.stars.Count > MaxStars)\r\n\t\t{\r\n\t\t\tint index = design.stars.Count - 1;\r\n\t\t\tdesign.stars[index].Dispose();\r\n\t\t\tdesign.stars.RemoveAt(index);\r\n\t\t}\r\n\t\tforeach (ProtoBuf.PatternFirework.Star star in design.stars)\r\n\t\t{\r\n\t\t\tstar.position = new UnityEngine.Vector2(UnityEngine.Mathf.Clamp(star.position.x, -1f, 1f), UnityEngine.Mathf.Clamp(star.position.y, -1f, 1f));\r\n\t\t\tstar.color = new UnityEngine.Color(UnityEngine.Mathf.Clamp01(star.color.r), UnityEngine.Mathf.Clamp01(star.color.g), UnityEngine.Mathf.Clamp01(star.color.b), 1f);\r\n\t\t}\r\n\t\tdesign.editedBy = rpc.player.userID;\r\n\t}\r\n\tDesign?.Dispose();\r\n\tDesign = design;\r\n\tSendNetworkUpdateImmediate();\r\n}\r\n",
    "targetName": "PatternFirework",
    "methodName": "ServerSetFireworkDesign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFireworkStarted",
    "fullName": "OnFireworkStarted",
    "category": "Firework",
    "parameters": [
      {
        "name": "baseFirework",
        "type": "BaseFirework, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void Begin()\r\n{\r\n\tSetFlag(BaseEntity.Flags.OnFire, b: false);\r\n\tSetFlag(BaseEntity.Flags.On, b: true, recursive: false, networkupdate: false);\r\n\tSendNetworkUpdate_Flags();\r\n\tInvoke(OnExhausted, activityLength);\r\n}\r\n",
    "targetName": "BaseFirework",
    "methodName": "Begin",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFireworkExhausted",
    "fullName": "OnFireworkExhausted",
    "category": "Firework",
    "parameters": [
      {
        "name": "baseFirework",
        "type": "BaseFirework, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnExhausted()\r\n{\r\n\tSetFlag(BaseEntity.Flags.Reserved8, b: true, recursive: false, networkupdate: false);\r\n\tSetFlag(BaseEntity.Flags.OnFire, b: false, recursive: false, networkupdate: false);\r\n\tSetFlag(BaseEntity.Flags.On, b: false, recursive: false, networkupdate: false);\r\n\tEnableGlobalBroadcast(wants: false);\r\n\tSendNetworkUpdate_Flags();\r\n\tInvoke(Cleanup, corpseDuration);\r\n\t_activeFireworks.Remove(this);\r\n}\r\n",
    "targetName": "BaseFirework",
    "methodName": "OnExhausted",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFireworkDamage",
    "fullName": "OnFireworkDamage",
    "category": "Firework",
    "parameters": [
      {
        "name": "baseFirework",
        "type": "BaseFirework, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnAttacked(HitInfo info)\r\n{\r\n\tbase.OnAttacked(info);\r\n\tif (base.isServer && info.damageTypes.Has(Rust.DamageType.Heat))\r\n\t{\r\n\t\tStaggeredTryLightFuse();\r\n\t}\r\n}\r\n",
    "targetName": "BaseFirework",
    "methodName": "OnAttacked",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFishingStopped",
    "fullName": "OnFishingStopped",
    "category": "Fishing",
    "parameters": [
      {
        "name": "baseFishingRod",
        "type": "BaseFishingRod, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "reason",
        "type": "BaseFishingRod+FailReason, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void Server_Cancel(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (CurrentState != BaseFishingRod.CatchState.Caught)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.UserRequested);\r\n\t}\r\n}\r\n",
    "targetName": "BaseFishingRod",
    "methodName": "Server_Cancel",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFishingRodCast",
    "fullName": "OnFishingRodCast",
    "category": "Fishing",
    "parameters": [
      {
        "name": "baseFishingRod",
        "type": "BaseFishingRod, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void Server_RequestCast(BaseEntity.RPCMessage msg)\r\n{\r\n\tUnityEngine.Vector3 pos = msg.read.Vector3();\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tItem currentLure = GetCurrentLure();\r\n\tif (currentLure == null)\r\n\t{\r\n\t\tFailedCast(BaseFishingRod.FailReason.NoLure);\r\n\t\treturn;\r\n\t}\r\n\tif (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))\r\n\t{\r\n\t\tFailedCast(reason);\r\n\t\treturn;\r\n\t}\r\n\tFishingBobber component = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + UnityEngine.Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();\r\n\tcomponent.transform.forward = GetOwnerPlayer().eyes.BodyForward();\r\n\tcomponent.Spawn();\r\n\tcomponent.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);\r\n\tint usedLureAmount = 0;\r\n\tif (FishLookup.Instance != null)\r\n\t{\r\n\t\tcurrentFishTarget = FishLookup.Instance.GetFish(component.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);\r\n\t}\r\n\tlureUsed = currentLure.info;\r\n\tcurrentLure.UseItem(usedLureAmount);\r\n\tlastFish = fishableModifier;\r\n\tcurrentBobber.Set(component);\r\n\tClientRPC(RpcTarget.NetworkGroup(\"Client_ReceiveCastPoint\"), component.net.ID);\r\n\townerPlayer.SignalBroadcast(BaseEntity.Signal.Attack);\r\n\tcatchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));\r\n\tcatchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;\r\n\tfloat val = (lureUsed.TryGetComponent<ItemModCompostable>(out var component2) ? component2.BaitValue : 0f);\r\n\tval = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);\r\n\tcatchTime = UnityEngine.Mathf.Clamp((float)catchTime - val, 3f, 20f);\r\n\tplayerStartPosition = ownerPlayer.transform.position;\r\n\tSetFlag(BaseEntity.Flags.Busy, b: true);\r\n\tCurrentState = BaseFishingRod.CatchState.Waiting;\r\n\tInvokeRepeating(CatchProcess, 0f, 0f);\r\n\tinQueue = false;\r\n\tBasePlayer ownerPlayer2 = GetOwnerPlayer();\r\n\tif (ownerPlayer2 != null)\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnStartFish(ownerPlayer2, currentLure, pos);\r\n\t}\r\n}\r\n",
    "targetName": "BaseFishingRod",
    "methodName": "Server_RequestCast",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFishCaught",
    "fullName": "OnFishCaught",
    "category": "Fishing",
    "parameters": [
      {
        "name": "baseFishingRod",
        "type": "BaseFishingRod, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BaseFishingRod, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CatchProcessBudgeted()\r\n{\r\n\tinQueue = false;\r\n\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.UserRequested);\r\n\t\treturn;\r\n\t}\r\n\tUnityEngine.Vector3 position = ownerPlayer.transform.position;\r\n\tfloat num = UnityEngine.Vector3.Angle((UnityEngine.Vector3Ex.WithY(fishingBobber.transform.position, 0f) - UnityEngine.Vector3Ex.WithY(position, 0f)).normalized, UnityEngine.Vector3Ex.WithY(ownerPlayer.eyes.HeadForward(), 0f));\r\n\tfloat num2 = UnityEngine.Vector3.Distance(position, UnityEngine.Vector3Ex.WithY(fishingBobber.transform.position, position.y));\r\n\tif (num > ((num2 > 1.2f) ? 60f : 180f))\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.BadAngle);\r\n\t\treturn;\r\n\t}\r\n\tif (num2 > 1.2f && (float)lastSightCheck > 0.4f)\r\n\t{\r\n\t\tif (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))\r\n\t\t{\r\n\t\t\tServer_Cancel(BaseFishingRod.FailReason.Obstructed);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlastSightCheck = 0f;\r\n\t}\r\n\tif (UnityEngine.Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.TooFarAway);\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Vector3.Distance(playerStartPosition, position) > 1f)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.PlayerMoved);\r\n\t\treturn;\r\n\t}\r\n\tif (CurrentState == BaseFishingRod.CatchState.Waiting)\r\n\t{\r\n\t\tif ((float)catchTime < 0f)\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_HookedSomething\"));\r\n\t\t\tCurrentState = BaseFishingRod.CatchState.Catching;\r\n\t\t\tfishingBobber.SetFlag(BaseEntity.Flags.Reserved1, b: true);\r\n\t\t\tnextFishStateChange = 0f;\r\n\t\t\tfishCatchDuration = 0f;\r\n\t\t\tstrainTimer = 0f;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tBaseFishingRod.FishState fishState = currentFishState;\r\n\tif ((float)nextFishStateChange < 0f)\r\n\t{\r\n\t\tfloat num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);\r\n\t\tif (currentFishState != 0)\r\n\t\t{\r\n\t\t\tcurrentFishState = (BaseFishingRod.FishState)0;\r\n\t\t\tnextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);\r\n\t\t\tif (UnityEngine.Random.Range(0, 100) < 50)\r\n\t\t\t{\r\n\t\t\t\tcurrentFishState = BaseFishingRod.FishState.PullingLeft;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcurrentFishState = BaseFishingRod.FishState.PullingRight;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0, 100) > 60 && UnityEngine.Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)\r\n\t\t\t{\r\n\t\t\t\tcurrentFishState |= BaseFishingRod.FishState.PullingBack;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif ((float)fishCatchDuration > 120f)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.TimeOut);\r\n\t\treturn;\r\n\t}\r\n\tbool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);\r\n\tbool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);\r\n\tbool flag3 = HasReelInInput(ownerPlayer.serverInput);\r\n\tif (flag2 && flag)\r\n\t{\r\n\t\tflag2 = (flag = false);\r\n\t}\r\n\tUpdateFlags(flag2, flag, flag3);\r\n\tif (CurrentState == BaseFishingRod.CatchState.Waiting)\r\n\t{\r\n\t\tflag = (flag2 = (flag3 = false));\r\n\t}\r\n\tif (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\r\n\t{\r\n\t\tflag2 = false;\r\n\t}\r\n\tif (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\r\n\t{\r\n\t\tflag = false;\r\n\t}\r\n\tfloat value = ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f);\r\n\tfishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier, value);\r\n\tbool flag4 = false;\r\n\tfloat num4 = 0f;\r\n\tif (flag3 || flag2 || flag)\r\n\t{\r\n\t\tflag4 = true;\r\n\t\tnum4 = 0.5f;\r\n\t}\r\n\tif (currentFishState != 0 && flag4)\r\n\t{\r\n\t\tif (currentFishState.Contains(BaseFishingRod.FishState.PullingBack) && flag3)\r\n\t\t{\r\n\t\t\tnum4 = 1.5f;\r\n\t\t}\r\n\t\telse if ((currentFishState.Contains(BaseFishingRod.FishState.PullingLeft) || currentFishState.Contains(BaseFishingRod.FishState.PullingRight)) && flag3)\r\n\t\t{\r\n\t\t\tnum4 = 1.2f;\r\n\t\t}\r\n\t\telse if (currentFishState.Contains(BaseFishingRod.FishState.PullingLeft) && flag)\r\n\t\t{\r\n\t\t\tnum4 = 0.8f;\r\n\t\t}\r\n\t\telse if (currentFishState.Contains(BaseFishingRod.FishState.PullingRight) && flag2)\r\n\t\t{\r\n\t\t\tnum4 = 0.8f;\r\n\t\t}\r\n\t}\r\n\tif (flag3 && currentFishState != 0)\r\n\t{\r\n\t\tnum4 += 1f;\r\n\t}\r\n\tnum4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;\r\n\tnum4 -= ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f) - 1f;\r\n\tif (flag4)\r\n\t{\r\n\t\tstrainTimer += UnityEngine.Time.deltaTime * num4;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstrainTimer = UnityEngine.Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);\r\n\t}\r\n\tfloat num5 = strainTimer / 6f;\r\n\tSetFlag(BaseEntity.Flags.Reserved1, flag4 && num5 > 0.25f);\r\n\tif ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)\r\n\t{\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_UpdateFishState\"), (int)currentFishState, num5);\r\n\t\tlastStrainUpdate = 0f;\r\n\t}\r\n\tif (strainTimer > 7f || ForceFail)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.TensionBreak);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!(num2 <= FishCatchDistance) && !ForceSuccess)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tCurrentState = BaseFishingRod.CatchState.Caught;\r\n\t\tif (currentFishTarget != null)\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(currentFishTarget, 1, 0uL);\r\n\t\t\titem.SetItemOwnership(ownerPlayer, ItemOwnershipPhrases.Fishing);\r\n\t\t\townerPlayer.GiveItem(item, BaseEntity.GiveItemReason.Crafted);\r\n\t\t\tif (currentFishTarget.shortname == \"skull.human\")\r\n\t\t\t{\r\n\t\t\t\titem.name = Facepunch.RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));\r\n\t\t\t}\r\n\t\t\tif (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))\r\n\t\t\t{\r\n\t\t\t\townerPlayer.stats.Add(fishableModifier.SteamStatName, 1);\r\n\t\t\t\townerPlayer.stats.Save(forceSteamSave: true);\r\n\t\t\t\tFishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);\r\n\t\t\t}\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCaughtFish(ownerPlayer, item);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_OnCaughtFish\"), currentFishTarget.itemid);\r\n\t\townerPlayer.SignalBroadcast(BaseEntity.Signal.Alt_Attack);\r\n\t\tInvoke(ResetLine, 6f);\r\n\t\tfishingBobber.Kill();\r\n\t\tcurrentBobber.Set(null);\r\n\t\tCancelInvoke(CatchProcess);\r\n\t}\r\n}\r\n",
    "targetName": "BaseFishingRod",
    "methodName": "CatchProcessBudgeted",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanCastFishingRod",
    "fullName": "CanCastFishingRod",
    "category": "Fishing",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void Server_RequestCast(BaseEntity.RPCMessage msg)\r\n{\r\n\tUnityEngine.Vector3 pos = msg.read.Vector3();\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tItem currentLure = GetCurrentLure();\r\n\tif (currentLure == null)\r\n\t{\r\n\t\tFailedCast(BaseFishingRod.FailReason.NoLure);\r\n\t\treturn;\r\n\t}\r\n\tif (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))\r\n\t{\r\n\t\tFailedCast(reason);\r\n\t\treturn;\r\n\t}\r\n\tFishingBobber component = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + UnityEngine.Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();\r\n\tcomponent.transform.forward = GetOwnerPlayer().eyes.BodyForward();\r\n\tcomponent.Spawn();\r\n\tcomponent.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);\r\n\tint usedLureAmount = 0;\r\n\tif (FishLookup.Instance != null)\r\n\t{\r\n\t\tcurrentFishTarget = FishLookup.Instance.GetFish(component.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);\r\n\t}\r\n\tlureUsed = currentLure.info;\r\n\tcurrentLure.UseItem(usedLureAmount);\r\n\tlastFish = fishableModifier;\r\n\tcurrentBobber.Set(component);\r\n\tClientRPC(RpcTarget.NetworkGroup(\"Client_ReceiveCastPoint\"), component.net.ID);\r\n\townerPlayer.SignalBroadcast(BaseEntity.Signal.Attack);\r\n\tcatchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));\r\n\tcatchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;\r\n\tfloat val = (lureUsed.TryGetComponent<ItemModCompostable>(out var component2) ? component2.BaitValue : 0f);\r\n\tval = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);\r\n\tcatchTime = UnityEngine.Mathf.Clamp((float)catchTime - val, 3f, 20f);\r\n\tplayerStartPosition = ownerPlayer.transform.position;\r\n\tSetFlag(BaseEntity.Flags.Busy, b: true);\r\n\tCurrentState = BaseFishingRod.CatchState.Waiting;\r\n\tInvokeRepeating(CatchProcess, 0f, 0f);\r\n\tinQueue = false;\r\n\tBasePlayer ownerPlayer2 = GetOwnerPlayer();\r\n\tif (ownerPlayer2 != null)\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnStartFish(ownerPlayer2, currentLure, pos);\r\n\t}\r\n}\r\n",
    "targetName": "BaseFishingRod",
    "methodName": "Server_RequestCast",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanCatchFish",
    "fullName": "CanCatchFish",
    "category": "Fishing",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CatchProcessBudgeted()\r\n{\r\n\tinQueue = false;\r\n\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.UserRequested);\r\n\t\treturn;\r\n\t}\r\n\tUnityEngine.Vector3 position = ownerPlayer.transform.position;\r\n\tfloat num = UnityEngine.Vector3.Angle((UnityEngine.Vector3Ex.WithY(fishingBobber.transform.position, 0f) - UnityEngine.Vector3Ex.WithY(position, 0f)).normalized, UnityEngine.Vector3Ex.WithY(ownerPlayer.eyes.HeadForward(), 0f));\r\n\tfloat num2 = UnityEngine.Vector3.Distance(position, UnityEngine.Vector3Ex.WithY(fishingBobber.transform.position, position.y));\r\n\tif (num > ((num2 > 1.2f) ? 60f : 180f))\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.BadAngle);\r\n\t\treturn;\r\n\t}\r\n\tif (num2 > 1.2f && (float)lastSightCheck > 0.4f)\r\n\t{\r\n\t\tif (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))\r\n\t\t{\r\n\t\t\tServer_Cancel(BaseFishingRod.FailReason.Obstructed);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlastSightCheck = 0f;\r\n\t}\r\n\tif (UnityEngine.Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.TooFarAway);\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Vector3.Distance(playerStartPosition, position) > 1f)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.PlayerMoved);\r\n\t\treturn;\r\n\t}\r\n\tif (CurrentState == BaseFishingRod.CatchState.Waiting)\r\n\t{\r\n\t\tif ((float)catchTime < 0f)\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_HookedSomething\"));\r\n\t\t\tCurrentState = BaseFishingRod.CatchState.Catching;\r\n\t\t\tfishingBobber.SetFlag(BaseEntity.Flags.Reserved1, b: true);\r\n\t\t\tnextFishStateChange = 0f;\r\n\t\t\tfishCatchDuration = 0f;\r\n\t\t\tstrainTimer = 0f;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tBaseFishingRod.FishState fishState = currentFishState;\r\n\tif ((float)nextFishStateChange < 0f)\r\n\t{\r\n\t\tfloat num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);\r\n\t\tif (currentFishState != 0)\r\n\t\t{\r\n\t\t\tcurrentFishState = (BaseFishingRod.FishState)0;\r\n\t\t\tnextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);\r\n\t\t\tif (UnityEngine.Random.Range(0, 100) < 50)\r\n\t\t\t{\r\n\t\t\t\tcurrentFishState = BaseFishingRod.FishState.PullingLeft;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcurrentFishState = BaseFishingRod.FishState.PullingRight;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0, 100) > 60 && UnityEngine.Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)\r\n\t\t\t{\r\n\t\t\t\tcurrentFishState |= BaseFishingRod.FishState.PullingBack;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif ((float)fishCatchDuration > 120f)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.TimeOut);\r\n\t\treturn;\r\n\t}\r\n\tbool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);\r\n\tbool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);\r\n\tbool flag3 = HasReelInInput(ownerPlayer.serverInput);\r\n\tif (flag2 && flag)\r\n\t{\r\n\t\tflag2 = (flag = false);\r\n\t}\r\n\tUpdateFlags(flag2, flag, flag3);\r\n\tif (CurrentState == BaseFishingRod.CatchState.Waiting)\r\n\t{\r\n\t\tflag = (flag2 = (flag3 = false));\r\n\t}\r\n\tif (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\r\n\t{\r\n\t\tflag2 = false;\r\n\t}\r\n\tif (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\r\n\t{\r\n\t\tflag = false;\r\n\t}\r\n\tfloat value = ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f);\r\n\tfishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier, value);\r\n\tbool flag4 = false;\r\n\tfloat num4 = 0f;\r\n\tif (flag3 || flag2 || flag)\r\n\t{\r\n\t\tflag4 = true;\r\n\t\tnum4 = 0.5f;\r\n\t}\r\n\tif (currentFishState != 0 && flag4)\r\n\t{\r\n\t\tif (currentFishState.Contains(BaseFishingRod.FishState.PullingBack) && flag3)\r\n\t\t{\r\n\t\t\tnum4 = 1.5f;\r\n\t\t}\r\n\t\telse if ((currentFishState.Contains(BaseFishingRod.FishState.PullingLeft) || currentFishState.Contains(BaseFishingRod.FishState.PullingRight)) && flag3)\r\n\t\t{\r\n\t\t\tnum4 = 1.2f;\r\n\t\t}\r\n\t\telse if (currentFishState.Contains(BaseFishingRod.FishState.PullingLeft) && flag)\r\n\t\t{\r\n\t\t\tnum4 = 0.8f;\r\n\t\t}\r\n\t\telse if (currentFishState.Contains(BaseFishingRod.FishState.PullingRight) && flag2)\r\n\t\t{\r\n\t\t\tnum4 = 0.8f;\r\n\t\t}\r\n\t}\r\n\tif (flag3 && currentFishState != 0)\r\n\t{\r\n\t\tnum4 += 1f;\r\n\t}\r\n\tnum4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;\r\n\tnum4 -= ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f) - 1f;\r\n\tif (flag4)\r\n\t{\r\n\t\tstrainTimer += UnityEngine.Time.deltaTime * num4;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstrainTimer = UnityEngine.Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);\r\n\t}\r\n\tfloat num5 = strainTimer / 6f;\r\n\tSetFlag(BaseEntity.Flags.Reserved1, flag4 && num5 > 0.25f);\r\n\tif ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)\r\n\t{\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_UpdateFishState\"), (int)currentFishState, num5);\r\n\t\tlastStrainUpdate = 0f;\r\n\t}\r\n\tif (strainTimer > 7f || ForceFail)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.TensionBreak);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!(num2 <= FishCatchDistance) && !ForceSuccess)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tCurrentState = BaseFishingRod.CatchState.Caught;\r\n\t\tif (currentFishTarget != null)\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(currentFishTarget, 1, 0uL);\r\n\t\t\titem.SetItemOwnership(ownerPlayer, ItemOwnershipPhrases.Fishing);\r\n\t\t\townerPlayer.GiveItem(item, BaseEntity.GiveItemReason.Crafted);\r\n\t\t\tif (currentFishTarget.shortname == \"skull.human\")\r\n\t\t\t{\r\n\t\t\t\titem.name = Facepunch.RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));\r\n\t\t\t}\r\n\t\t\tif (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))\r\n\t\t\t{\r\n\t\t\t\townerPlayer.stats.Add(fishableModifier.SteamStatName, 1);\r\n\t\t\t\townerPlayer.stats.Save(forceSteamSave: true);\r\n\t\t\t\tFishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);\r\n\t\t\t}\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCaughtFish(ownerPlayer, item);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_OnCaughtFish\"), currentFishTarget.itemid);\r\n\t\townerPlayer.SignalBroadcast(BaseEntity.Signal.Alt_Attack);\r\n\t\tInvoke(ResetLine, 6f);\r\n\t\tfishingBobber.Kill();\r\n\t\tcurrentBobber.Set(null);\r\n\t\tCancelInvoke(CatchProcess);\r\n\t}\r\n}\r\n",
    "targetName": "BaseFishingRod",
    "methodName": "CatchProcessBudgeted",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFishCatch",
    "fullName": "OnFishCatch",
    "category": "Fishing",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CatchProcessBudgeted()\r\n{\r\n\tinQueue = false;\r\n\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.UserRequested);\r\n\t\treturn;\r\n\t}\r\n\tUnityEngine.Vector3 position = ownerPlayer.transform.position;\r\n\tfloat num = UnityEngine.Vector3.Angle((UnityEngine.Vector3Ex.WithY(fishingBobber.transform.position, 0f) - UnityEngine.Vector3Ex.WithY(position, 0f)).normalized, UnityEngine.Vector3Ex.WithY(ownerPlayer.eyes.HeadForward(), 0f));\r\n\tfloat num2 = UnityEngine.Vector3.Distance(position, UnityEngine.Vector3Ex.WithY(fishingBobber.transform.position, position.y));\r\n\tif (num > ((num2 > 1.2f) ? 60f : 180f))\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.BadAngle);\r\n\t\treturn;\r\n\t}\r\n\tif (num2 > 1.2f && (float)lastSightCheck > 0.4f)\r\n\t{\r\n\t\tif (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))\r\n\t\t{\r\n\t\t\tServer_Cancel(BaseFishingRod.FailReason.Obstructed);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlastSightCheck = 0f;\r\n\t}\r\n\tif (UnityEngine.Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.TooFarAway);\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Vector3.Distance(playerStartPosition, position) > 1f)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.PlayerMoved);\r\n\t\treturn;\r\n\t}\r\n\tif (CurrentState == BaseFishingRod.CatchState.Waiting)\r\n\t{\r\n\t\tif ((float)catchTime < 0f)\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_HookedSomething\"));\r\n\t\t\tCurrentState = BaseFishingRod.CatchState.Catching;\r\n\t\t\tfishingBobber.SetFlag(BaseEntity.Flags.Reserved1, b: true);\r\n\t\t\tnextFishStateChange = 0f;\r\n\t\t\tfishCatchDuration = 0f;\r\n\t\t\tstrainTimer = 0f;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tBaseFishingRod.FishState fishState = currentFishState;\r\n\tif ((float)nextFishStateChange < 0f)\r\n\t{\r\n\t\tfloat num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);\r\n\t\tif (currentFishState != 0)\r\n\t\t{\r\n\t\t\tcurrentFishState = (BaseFishingRod.FishState)0;\r\n\t\t\tnextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);\r\n\t\t\tif (UnityEngine.Random.Range(0, 100) < 50)\r\n\t\t\t{\r\n\t\t\t\tcurrentFishState = BaseFishingRod.FishState.PullingLeft;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcurrentFishState = BaseFishingRod.FishState.PullingRight;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0, 100) > 60 && UnityEngine.Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)\r\n\t\t\t{\r\n\t\t\t\tcurrentFishState |= BaseFishingRod.FishState.PullingBack;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif ((float)fishCatchDuration > 120f)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.TimeOut);\r\n\t\treturn;\r\n\t}\r\n\tbool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);\r\n\tbool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);\r\n\tbool flag3 = HasReelInInput(ownerPlayer.serverInput);\r\n\tif (flag2 && flag)\r\n\t{\r\n\t\tflag2 = (flag = false);\r\n\t}\r\n\tUpdateFlags(flag2, flag, flag3);\r\n\tif (CurrentState == BaseFishingRod.CatchState.Waiting)\r\n\t{\r\n\t\tflag = (flag2 = (flag3 = false));\r\n\t}\r\n\tif (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\r\n\t{\r\n\t\tflag2 = false;\r\n\t}\r\n\tif (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\r\n\t{\r\n\t\tflag = false;\r\n\t}\r\n\tfloat value = ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f);\r\n\tfishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier, value);\r\n\tbool flag4 = false;\r\n\tfloat num4 = 0f;\r\n\tif (flag3 || flag2 || flag)\r\n\t{\r\n\t\tflag4 = true;\r\n\t\tnum4 = 0.5f;\r\n\t}\r\n\tif (currentFishState != 0 && flag4)\r\n\t{\r\n\t\tif (currentFishState.Contains(BaseFishingRod.FishState.PullingBack) && flag3)\r\n\t\t{\r\n\t\t\tnum4 = 1.5f;\r\n\t\t}\r\n\t\telse if ((currentFishState.Contains(BaseFishingRod.FishState.PullingLeft) || currentFishState.Contains(BaseFishingRod.FishState.PullingRight)) && flag3)\r\n\t\t{\r\n\t\t\tnum4 = 1.2f;\r\n\t\t}\r\n\t\telse if (currentFishState.Contains(BaseFishingRod.FishState.PullingLeft) && flag)\r\n\t\t{\r\n\t\t\tnum4 = 0.8f;\r\n\t\t}\r\n\t\telse if (currentFishState.Contains(BaseFishingRod.FishState.PullingRight) && flag2)\r\n\t\t{\r\n\t\t\tnum4 = 0.8f;\r\n\t\t}\r\n\t}\r\n\tif (flag3 && currentFishState != 0)\r\n\t{\r\n\t\tnum4 += 1f;\r\n\t}\r\n\tnum4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;\r\n\tnum4 -= ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f) - 1f;\r\n\tif (flag4)\r\n\t{\r\n\t\tstrainTimer += UnityEngine.Time.deltaTime * num4;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstrainTimer = UnityEngine.Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);\r\n\t}\r\n\tfloat num5 = strainTimer / 6f;\r\n\tSetFlag(BaseEntity.Flags.Reserved1, flag4 && num5 > 0.25f);\r\n\tif ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)\r\n\t{\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_UpdateFishState\"), (int)currentFishState, num5);\r\n\t\tlastStrainUpdate = 0f;\r\n\t}\r\n\tif (strainTimer > 7f || ForceFail)\r\n\t{\r\n\t\tServer_Cancel(BaseFishingRod.FailReason.TensionBreak);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!(num2 <= FishCatchDistance) && !ForceSuccess)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tCurrentState = BaseFishingRod.CatchState.Caught;\r\n\t\tif (currentFishTarget != null)\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(currentFishTarget, 1, 0uL);\r\n\t\t\titem.SetItemOwnership(ownerPlayer, ItemOwnershipPhrases.Fishing);\r\n\t\t\townerPlayer.GiveItem(item, BaseEntity.GiveItemReason.Crafted);\r\n\t\t\tif (currentFishTarget.shortname == \"skull.human\")\r\n\t\t\t{\r\n\t\t\t\titem.name = Facepunch.RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));\r\n\t\t\t}\r\n\t\t\tif (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))\r\n\t\t\t{\r\n\t\t\t\townerPlayer.stats.Add(fishableModifier.SteamStatName, 1);\r\n\t\t\t\townerPlayer.stats.Save(forceSteamSave: true);\r\n\t\t\t\tFishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);\r\n\t\t\t}\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCaughtFish(ownerPlayer, item);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"Client_OnCaughtFish\"), currentFishTarget.itemid);\r\n\t\townerPlayer.SignalBroadcast(BaseEntity.Signal.Alt_Attack);\r\n\t\tInvoke(ResetLine, 6f);\r\n\t\tfishingBobber.Kill();\r\n\t\tcurrentBobber.Set(null);\r\n\t\tCancelInvoke(CatchProcess);\r\n\t}\r\n}\r\n",
    "targetName": "BaseFishingRod",
    "methodName": "CatchProcessBudgeted",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFuelConsume",
    "fullName": "OnFuelConsume",
    "category": "Fuel",
    "parameters": [
      {
        "name": "baseOven",
        "type": "BaseOven, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ConsumeFuel(Item fuel, ItemModBurnable burnable)\r\n{\r\n\tif (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)\r\n\t{\r\n\t\tItem item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);\r\n\t\tif (!item.MoveToContainer(base.inventory))\r\n\t\t{\r\n\t\t\tOvenFull();\r\n\t\t\titem.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\r\n\t\t}\r\n\t}\r\n\tif (fuel.amount <= GetFuelRate())\r\n\t{\r\n\t\tfuel.Remove();\r\n\t\treturn;\r\n\t}\r\n\tint fuelRate = GetFuelRate();\r\n\tfuel.UseItem(fuelRate);\r\n\tFacepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, \"smelt\");\r\n\tfuel.fuel = burnable.fuelAmount;\r\n\tfuel.MarkDirty();\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "ConsumeFuel",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFuelConsumed",
    "fullName": "OnFuelConsumed",
    "category": "Fuel",
    "parameters": [
      {
        "name": "baseOven",
        "type": "BaseOven, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ConsumeFuel(Item fuel, ItemModBurnable burnable)\r\n{\r\n\tif (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)\r\n\t{\r\n\t\tItem item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);\r\n\t\tif (!item.MoveToContainer(base.inventory))\r\n\t\t{\r\n\t\t\tOvenFull();\r\n\t\t\titem.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\r\n\t\t}\r\n\t}\r\n\tif (fuel.amount <= GetFuelRate())\r\n\t{\r\n\t\tfuel.Remove();\r\n\t\treturn;\r\n\t}\r\n\tint fuelRate = GetFuelRate();\r\n\tfuel.UseItem(fuelRate);\r\n\tFacepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, \"smelt\");\r\n\tfuel.fuel = burnable.fuelAmount;\r\n\tfuel.MarkDirty();\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "ConsumeFuel",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFuelAmountCheck",
    "fullName": "OnFuelAmountCheck",
    "category": "Fuel",
    "parameters": [
      {
        "name": "entityFuelSystem",
        "type": "EntityFuelSystem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public int GetFuelAmount()\r\n{\r\n\tItem fuelItem = GetFuelItem();\r\n\tif (fuelItem == null || fuelItem.amount < 1)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\treturn fuelItem.amount;\r\n}\r\n",
    "targetName": "EntityFuelSystem",
    "methodName": "GetFuelAmount",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Int32"
  },
  {
    "name": "OnFuelItemCheck",
    "fullName": "OnFuelItemCheck",
    "category": "Fuel",
    "parameters": [
      {
        "name": "entityFuelSystem",
        "type": "EntityFuelSystem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "StorageContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public Item GetFuelItem()\r\n{\r\n\tStorageContainer fuelContainer = GetFuelContainer();\r\n\tif (fuelContainer == null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\treturn fuelContainer.inventory.GetSlot(0);\r\n}\r\n",
    "targetName": "EntityFuelSystem",
    "methodName": "GetFuelItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "Item"
  },
  {
    "name": "OnFuelCheck",
    "fullName": "OnFuelCheck",
    "category": "Fuel",
    "parameters": [
      {
        "name": "entityFuelSystem",
        "type": "EntityFuelSystem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool HasFuel(bool forceCheck = false)\r\n{\r\n\tif (UnityEngine.Time.time > nextFuelCheckTime || forceCheck)\r\n\t{\r\n\t\tcachedHasFuel = (float)GetFuelAmount() > 0f;\r\n\t\tnextFuelCheckTime = UnityEngine.Time.time + UnityEngine.Random.Range(1f, 2f);\r\n\t}\r\n\treturn cachedHasFuel;\r\n}\r\n",
    "targetName": "EntityFuelSystem",
    "methodName": "HasFuel",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanCheckFuel",
    "fullName": "CanCheckFuel",
    "category": "Fuel",
    "parameters": [
      {
        "name": "entityFuelSystem",
        "type": "EntityFuelSystem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "StorageContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool IsInFuelInteractionRange(BasePlayer player)\r\n{\r\n\tStorageContainer fuelContainer = GetFuelContainer();\r\n\tif (fuelContainer != null)\r\n\t{\r\n\t\tfloat num = 0f;\r\n\t\tif (isServer)\r\n\t\t{\r\n\t\t\tnum = 3f;\r\n\t\t}\r\n\t\treturn fuelContainer.Distance(player.eyes.position) <= num;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "EntityFuelSystem",
    "methodName": "IsInFuelInteractionRange",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanUseFuel",
    "fullName": "CanUseFuel",
    "category": "Fuel",
    "parameters": [
      {
        "name": "entityFuelSystem",
        "type": "EntityFuelSystem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "StorageContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "seconds",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "fuelUsedPerSecond",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public int TryUseFuel(float seconds, float fuelUsedPerSecond)\r\n{\r\n\tStorageContainer fuelContainer = GetFuelContainer();\r\n\tif (fuelContainer == null)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\tItem slot = fuelContainer.inventory.GetSlot(0);\r\n\tif (slot == null || slot.amount < 1)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\tpendingFuel += seconds * fuelUsedPerSecond;\r\n\tif (pendingFuel >= 1f)\r\n\t{\r\n\t\tint num = UnityEngine.Mathf.FloorToInt(pendingFuel);\r\n\t\tslot.UseItem(num);\r\n\t\tFacepunch.Rust.Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, \"fuel_system\");\r\n\t\tpendingFuel -= num;\r\n\t\treturn num;\r\n\t}\r\n\treturn 0;\r\n}\r\n",
    "targetName": "EntityFuelSystem",
    "methodName": "TryUseFuel",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnConveyorFiltersChange",
    "fullName": "OnConveyorFiltersChange",
    "category": "Industrial",
    "parameters": [
      {
        "name": "industrialConveyor",
        "type": "IndustrialConveyor, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ProtoBuf.IndustrialConveyor+ItemFilterList, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void RPC_ChangeFilters(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player == null || !msg.player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tmode = (IndustrialConveyor.ConveyorMode)msg.read.Int32();\r\n\tfilterItems.Clear();\r\n\tProtoBuf.IndustrialConveyor.ItemFilterList itemFilterList = ProtoBuf.IndustrialConveyor.ItemFilterList.Deserialize(msg.read);\r\n\tif (itemFilterList.filters == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = UnityEngine.Mathf.Min(itemFilterList.filters.Count, 60);\r\n\tfor (int i = 0; i < num; i++)\r\n\t{\r\n\t\tif (filterItems.Count >= 30)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tIndustrialConveyor.ItemFilter item = new IndustrialConveyor.ItemFilter(itemFilterList.filters[i]);\r\n\t\tif (item.TargetItem != null || item.TargetCategory.HasValue)\r\n\t\t{\r\n\t\t\tfilterItems.Add(item);\r\n\t\t}\r\n\t}\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "IndustrialConveyor",
    "methodName": "RPC_ChangeFilters",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemCraft",
    "fullName": "OnItemCraft [IndustrialCrafter]",
    "category": "Industrial",
    "parameters": [
      {
        "name": "industrialCrafter",
        "type": "IndustrialCrafter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "ItemBlueprint, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void RunJob()\r\n{\r\n\tbase.RunJob();\r\n\tif (ConVar.Server.industrialCrafterFrequency <= 0f || HasFlag(BaseEntity.Flags.Reserved1) || currentlyCrafting != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfor (int i = 0; i <= 3; i++)\r\n\t{\r\n\t\tItem targetBlueprint = GetTargetBlueprint(i);\r\n\t\tif (targetBlueprint == null || GetWorkbench() == null || GetWorkbench().Workbenchlevel < targetBlueprint.blueprintTargetDef.Blueprint.GetWorkbenchLevel())\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;\r\n\t\tbool flag = true;\r\n\t\tforeach (ItemAmount ingredient in blueprint.GetIngredients())\r\n\t\t{\r\n\t\t\tif ((float)GetInputAmount(ingredient.itemDef) < ingredient.amount)\r\n\t\t\t{\r\n\t\t\t\tflag = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tflag = false;\r\n\t\tfor (int j = 8; j <= 11; j++)\r\n\t\t{\r\n\t\t\tItem slot = _inventory.GetSlot(j);\r\n\t\t\tif (slot == null || (slot.info == targetBlueprint.blueprintTargetDef && slot.amount + blueprint.amountToCreate <= slot.MaxStackable()))\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved2, b: true);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tSetFlag(BaseEntity.Flags.Reserved2, b: false);\r\n\t\tforeach (ItemAmount ingredient2 in blueprint.GetIngredients())\r\n\t\t{\r\n\t\t\tConsumeInputIngredient(ingredient2);\r\n\t\t}\r\n\t\tcurrentlyCrafting = targetBlueprint.blueprintTargetDef;\r\n\t\tcurrentlyCraftingAmount = blueprint.amountToCreate;\r\n\t\tfloat craftTime = blueprint.GetCraftTime();\r\n\t\tInvoke(CompleteCraft, craftTime);\r\n\t\tjobFinishes = craftTime;\r\n\t\tSetFlag(BaseEntity.Flags.Reserved1, b: true);\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"ClientUpdateCraftTimeRemaining\"), (float)jobFinishes, jobFinishes.Duration);\r\n\t\tbreak;\r\n\t}\r\n}\r\n",
    "targetName": "IndustrialCrafter",
    "methodName": "RunJob",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemRemovedFromContainer",
    "fullName": "OnItemRemovedFromContainer",
    "category": "Item",
    "parameters": [
      {
        "name": "itemContainer",
        "type": "ItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool Remove(Item item)\r\n{\r\n\tif (!itemList.Contains(item))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tonPreItemRemove?.Invoke(item);\r\n\titemList.Remove(item);\r\n\titem.parent = null;\r\n\tonItemParentChanged?.Invoke(parent, item);\r\n\tonItemAddedRemoved?.Invoke(item, arg2: false);\r\n\tItemContainer itemContainer = parent?.parent;\r\n\tif (itemContainer != null && itemContainer.onItemContentsChanged != null)\r\n\t{\r\n\t\titemContainer.onItemContentsChanged(item, arg2: false);\r\n\t}\r\n\tMarkDirty();\r\n\treturn true;\r\n}\r\n",
    "targetName": "ItemContainer",
    "methodName": "Remove",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemAddedToContainer",
    "fullName": "OnItemAddedToContainer",
    "category": "Item",
    "parameters": [
      {
        "name": "itemContainer",
        "type": "ItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool Insert(Item item)\r\n{\r\n\tif (itemList.Contains(item))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (IsFull())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\titemList.Add(item);\r\n\titem.parent = this;\r\n\tif (!FindPosition(item))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tMarkDirty();\r\n\tif (onItemAddedRemoved != null)\r\n\t{\r\n\t\tonItemAddedRemoved(item, arg2: true);\r\n\t}\r\n\tItemContainer itemContainer = parent?.parent;\r\n\tif (itemContainer != null && itemContainer.onItemContentsChanged != null)\r\n\t{\r\n\t\titemContainer.onItemContentsChanged(item, arg2: true);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "ItemContainer",
    "methodName": "Insert",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanAcceptItem",
    "fullName": "CanAcceptItem",
    "category": "Item",
    "parameters": [
      {
        "name": "itemContainer",
        "type": "ItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public ItemContainer.CanAcceptResult CanAcceptItem(Item item, int targetPos)\r\n{\r\n\tif (canAcceptItem != null && !canAcceptItem(item, targetPos))\r\n\t{\r\n\t\treturn ItemContainer.CanAcceptResult.CannotAccept;\r\n\t}\r\n\tif (isServer && availableSlots != null && availableSlots.Count > 0)\r\n\t{\r\n\t\tif (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)\r\n\t\t{\r\n\t\t\treturn ItemContainer.CanAcceptResult.CannotAccept;\r\n\t\t}\r\n\t\tif (item.isBroken)\r\n\t\t{\r\n\t\t\treturn ItemContainer.CanAcceptResult.CannotAccept;\r\n\t\t}\r\n\t\tint num = 0;\r\n\t\tforeach (ItemSlot availableSlot in availableSlots)\r\n\t\t{\r\n\t\t\tnum |= (int)availableSlot;\r\n\t\t}\r\n\t\tif (((uint)num & (uint)item.info.occupySlots) != (uint)item.info.occupySlots)\r\n\t\t{\r\n\t\t\treturn ItemContainer.CanAcceptResult.CannotAcceptRightNow;\r\n\t\t}\r\n\t}\r\n\tif ((allowedContents & item.info.itemType) != item.info.itemType)\r\n\t{\r\n\t\treturn ItemContainer.CanAcceptResult.CannotAccept;\r\n\t}\r\n\tif (HasLimitedAllowedItems)\r\n\t{\r\n\t\tbool flag = false;\r\n\t\tfor (int i = 0; i < onlyAllowedItems.Length; i++)\r\n\t\t{\r\n\t\t\tif (onlyAllowedItems[i] == item.info)\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\treturn ItemContainer.CanAcceptResult.CannotAccept;\r\n\t\t}\r\n\t}\r\n\tif (blockedItems != null && blockedItems.Contains(item.info))\r\n\t{\r\n\t\treturn ItemContainer.CanAcceptResult.CannotAccept;\r\n\t}\r\n\tif (item.GetItemVolume() > containerVolume)\r\n\t{\r\n\t\treturn ItemContainer.CanAcceptResult.CannotAccept;\r\n\t}\r\n\treturn ItemContainer.CanAcceptResult.CanAccept;\r\n}\r\n",
    "targetName": "ItemContainer",
    "methodName": "CanAcceptItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "ItemContainer+CanAcceptResult"
  },
  {
    "name": "OnItemCraft",
    "fullName": "OnItemCraft",
    "category": "Item",
    "parameters": [
      {
        "name": "local0",
        "type": "ItemCraftTask, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "owner",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "fromTempBlueprint",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)\r\n{\r\n\tif (owner != null && owner.IsTransferring())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!CanCraft(bp, amount, free))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\ttaskUID++;\r\n\tItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();\r\n\titemCraftTask.blueprint = bp;\r\n\tif (!free)\r\n\t{\r\n\t\tCollectIngredients(bp, itemCraftTask, amount, owner);\r\n\t}\r\n\titemCraftTask.endTime = 0f;\r\n\titemCraftTask.taskUID = taskUID;\r\n\titemCraftTask.instanceData = instanceData;\r\n\tif (itemCraftTask.instanceData != null)\r\n\t{\r\n\t\titemCraftTask.instanceData.ShouldPool = false;\r\n\t}\r\n\titemCraftTask.amount = amount;\r\n\titemCraftTask.skinID = skinID;\r\n\tif (fromTempBlueprint != null && itemCraftTask.takenItems != null)\r\n\t{\r\n\t\tfromTempBlueprint.RemoveFromContainer();\r\n\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\r\n\t\titemCraftTask.conditionScale = 0.5f;\r\n\t}\r\n\tqueue.AddLast(itemCraftTask);\r\n\tif (owner != null)\r\n\t{\r\n\t\towner.Command(\"note.craft_add\", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "ItemCrafter",
    "methodName": "CraftItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnItemCraftFinished",
    "fullName": "OnItemCraftFinished",
    "category": "Item",
    "parameters": [
      {
        "name": "task",
        "type": "ItemCraftTask, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "itemCrafter",
        "type": "ItemCrafter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void FinishCrafting(ItemCraftTask task)\r\n{\r\n\ttask.amount--;\r\n\ttask.numCrafted++;\r\n\tulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);\r\n\tItem item2 = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);\r\n\titem2.amount = task.blueprint.amountToCreate;\r\n\tint amount = item2.amount;\r\n\t_ = owner.currentCraftLevel;\r\n\tbool inSafezone = owner.InSafeZone();\r\n\tif (item2.hasCondition && task.conditionScale != 1f)\r\n\t{\r\n\t\titem2.maxCondition *= task.conditionScale;\r\n\t\titem2.condition = item2.maxCondition;\r\n\t}\r\n\titem2.OnVirginSpawn(owner);\r\n\titem2.SetItemOwnership(owner, ItemOwnershipPhrases.CraftedPhrase);\r\n\tforeach (ItemAmount ingredient in task.blueprint.GetIngredients())\r\n\t{\r\n\t\tint num = (int)ingredient.amount;\r\n\t\tif (task.takenItems == null)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tforeach (Item takenItem in task.takenItems)\r\n\t\t{\r\n\t\t\tif (takenItem.info == ingredient.itemDef)\r\n\t\t\t{\r\n\t\t\t\tint num2 = UnityEngine.Mathf.Min(takenItem.amount, num);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item2.info.shortname);\r\n\t\t\t\ttakenItem.UseItem(num);\r\n\t\t\t\tnum -= num2;\r\n\t\t\t}\r\n\t\t\tif (num <= 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\ttask.takenItems?.RemoveAll((Item item) => item.amount == 0);\r\n\tFacepunch.Rust.Analytics.Server.Crafting(task.blueprint.targetItem.shortname, task.skinID);\r\n\tFacepunch.Rust.Analytics.Azure.OnCraftItem(item2.info.shortname, item2.amount, base.baseEntity, task.workbenchEntity, inSafezone);\r\n\towner.Command(\"note.craft_done\", task.taskUID, 1, task.amount);\r\n\tif (task.instanceData != null)\r\n\t{\r\n\t\titem2.instanceData = task.instanceData;\r\n\t}\r\n\tif (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))\r\n\t{\r\n\t\towner.GiveAchievement(task.blueprint.UnlockAchievment);\r\n\t}\r\n\towner.ProcessMissionEvent(BaseMission.MissionEventType.CRAFT_ITEM, item2.info.itemid, amount);\r\n\tif (owner.inventory.GiveItem(item2))\r\n\t{\r\n\t\towner.Command(\"note.inv\", item2.info.itemid, amount);\r\n\t\treturn;\r\n\t}\r\n\tItemContainer itemContainer = System.Linq.Enumerable.First(containers);\r\n\towner.Command(\"note.inv\", item2.info.itemid, amount);\r\n\towner.Command(\"note.inv\", item2.info.itemid, -item2.amount);\r\n\titem2.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);\r\n}\r\n",
    "targetName": "ItemCrafter",
    "methodName": "FinishCrafting",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemCraftCancelled",
    "fullName": "OnItemCraftCancelled",
    "category": "Item",
    "parameters": [
      {
        "name": "local1",
        "type": "ItemCraftTask, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "itemCrafter",
        "type": "ItemCrafter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CancelTask(int iID)\r\n{\r\n\tif (queue.Count == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (owner != null && owner.IsTransferring())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tItemCraftTask itemCraftTask = System.Linq.Enumerable.FirstOrDefault(queue, (ItemCraftTask x) => x.taskUID == iID && !x.cancelled);\r\n\tif (itemCraftTask == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\titemCraftTask.cancelled = true;\r\n\tif (owner == null)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\towner.Command(\"note.craft_done\", itemCraftTask.taskUID, 0);\r\n\tif (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0)\r\n\t{\r\n\t\tforeach (Item takenItem in itemCraftTask.takenItems)\r\n\t\t{\r\n\t\t\tif (takenItem != null && takenItem.amount > 0)\r\n\t\t\t{\r\n\t\t\t\tif (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)\r\n\t\t\t\t{\r\n\t\t\t\t\ttakenItem.UseItem(itemCraftTask.numCrafted);\r\n\t\t\t\t}\r\n\t\t\t\tif (takenItem.amount > 0 && !takenItem.MoveToContainer(owner.inventory.containerMain))\r\n\t\t\t\t{\r\n\t\t\t\t\ttakenItem.Drop(owner.inventory.containerMain.dropPosition + UnityEngine.Random.value * UnityEngine.Vector3.down + UnityEngine.Random.insideUnitSphere, owner.inventory.containerMain.dropVelocity);\r\n\t\t\t\t\towner.Command(\"note.inv\", takenItem.info.itemid, -takenItem.amount);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\titemCraftTask.takenItems.Clear();\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "ItemCrafter",
    "methodName": "CancelTask",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanFastTrackCraftTask",
    "fullName": "CanFastTrackCraftTask",
    "category": "Item",
    "parameters": [
      {
        "name": "itemCrafter",
        "type": "ItemCrafter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "ItemCraftTask, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "taskID",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool FastTrackTask(int taskID)\r\n{\r\n\tif (queue.Count == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (owner != null && owner.IsTransferring())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tItemCraftTask value = queue.First.Value;\r\n\tif (value == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tItemCraftTask itemCraftTask = System.Linq.Enumerable.FirstOrDefault(queue, (ItemCraftTask x) => x.taskUID == taskID && !x.cancelled);\r\n\tif (itemCraftTask == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (itemCraftTask == value)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tvalue.endTime = 0f;\r\n\tqueue.Remove(itemCraftTask);\r\n\tqueue.AddFirst(itemCraftTask);\r\n\towner.Command(\"note.craft_fasttracked\", taskID);\r\n\treturn true;\r\n}\r\n",
    "targetName": "ItemCrafter",
    "methodName": "FastTrackTask",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnItemDeployed",
    "fullName": "OnItemDeployed [Regular]",
    "category": "Item",
    "parameters": [
      {
        "name": "deployer",
        "type": "Deployer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local5",
        "type": "ItemModDeployable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local6",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoDeploy_Regular(Deployable deployable, UnityEngine.Ray ray)\r\n{\r\n\tif (!HasItemAmount())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!ownerPlayer.CanBuild())\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\r\n\t}\r\n\telse if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredMovementAntiHack())\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.AntihackWithReason, false, ownerPlayer.lastViolationType.ToString());\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!CheckPlacement(deployable, ray, 8f) || !UnityEngine.Physics.Raycast(ray, out var hitInfo, 8f, 1235288065))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tUnityEngine.Vector3 point = hitInfo.point;\r\n\t\tUnityEngine.Quaternion deployedRotation = GetDeployedRotation(hitInfo.normal, ray.direction);\r\n\t\tItem ownerItem = GetOwnerItem();\r\n\t\tItemModDeployable modDeployable = GetModDeployable();\r\n\t\tif (ownerPlayer.Distance(point) > 3f)\r\n\t\t{\r\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))\r\n\t\t{\r\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);\r\n\t\tif (!baseEntity)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogWarning(\"Couldn't create prefab:\" + modDeployable.entityPrefab.resourcePath);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbaseEntity.skinID = ownerItem.skin;\r\n\t\tbaseEntity.SendMessage(\"SetDeployedBy\", ownerPlayer, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t\tbaseEntity.OwnerID = ownerPlayer.userID;\r\n\t\tbaseEntity.Spawn();\r\n\t\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);\r\n\t\tUseItemAmount(1);\r\n\t}\r\n}\r\n",
    "targetName": "Deployer",
    "methodName": "DoDeploy_Regular",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemDeployed",
    "fullName": "OnItemDeployed [Slot]",
    "category": "Item",
    "parameters": [
      {
        "name": "deployer",
        "type": "Deployer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoDeploy_Slot(Deployable deployable, UnityEngine.Ray ray, NetworkableId entityID)\r\n{\r\n\tif (!HasItemAmount())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!ownerPlayer.CanBuild())\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;\r\n\tif (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (ownerPlayer.Distance(baseEntity) > 3f)\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);\r\n\t\treturn;\r\n\t}\r\n\tif (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\r\n\t\treturn;\r\n\t}\r\n\tif (ownerPlayer.IsInTutorial)\r\n\t{\r\n\t\tTutorialIsland currentTutorialIsland = ownerPlayer.GetCurrentTutorialIsland();\r\n\t\tif (currentTutorialIsland != null && !currentTutorialIsland.CheckPlacement(ownerPlayer, deployable, baseEntity.transform.position, baseEntity.transform.rotation))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tItem ownerItem = GetOwnerItem();\r\n\tItemModDeployable modDeployable = GetModDeployable();\r\n\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);\r\n\tif (baseEntity2 != null)\r\n\t{\r\n\t\tbaseEntity2.skinID = ownerItem.skin;\r\n\t\tbaseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));\r\n\t\tbaseEntity2.OwnerID = ownerPlayer.userID;\r\n\t\tbaseEntity2.OnDeployed(baseEntity, ownerPlayer, ownerItem);\r\n\t\tbaseEntity2.Spawn();\r\n\t\tbaseEntity.SetSlot(deployable.slot, baseEntity2);\r\n\t\tif (deployable.placeEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\tif (ownerPlayer.IsInTutorial)\r\n\t\t{\r\n\t\t\tTutorialIsland currentTutorialIsland2 = ownerPlayer.GetCurrentTutorialIsland();\r\n\t\t\tif (currentTutorialIsland2 != null)\r\n\t\t\t{\r\n\t\t\t\tcurrentTutorialIsland2.OnPlayerBuiltConstruction(ownerPlayer);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (GetOwnerItemDefinition() != null)\r\n\t\t{\r\n\t\t\townerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload\r\n\t\t\t{\r\n\t\t\t\tWorldPosition = baseEntity2.transform.position,\r\n\t\t\t\tUintIdentifier = baseEntity2.prefabID,\r\n\t\t\t\tIntIdentifier = GetOwnerItemDefinition().itemid\r\n\t\t\t}, 1f);\r\n\t\t}\r\n\t}\r\n\tmodDeployable.OnDeployed(baseEntity2, ownerPlayer);\r\n\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);\r\n\tif (!ownerPlayer.IsInCreativeMode || !ConVar.Creative.freeBuild)\r\n\t{\r\n\t\tUseItemAmount(1);\r\n\t}\r\n}\r\n",
    "targetName": "Deployer",
    "methodName": "DoDeploy_Slot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanDeployItem",
    "fullName": "CanDeployItem",
    "category": "Item",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "deployer",
        "type": "Deployer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "NetworkableId, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void DoDeploy(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!msg.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDeployable deployable = GetDeployable();\r\n\tif (!(deployable == null))\r\n\t{\r\n\t\tUnityEngine.Ray ray = msg.read.Ray();\r\n\t\tNetworkableId entityID = msg.read.EntityID();\r\n\t\tif (deployable.toSlot)\r\n\t\t{\r\n\t\t\tDoDeploy_Slot(deployable, ray, entityID);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tDoDeploy_Regular(deployable, ray);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Deployer",
    "methodName": "DoDeploy",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "IOnLoseCondition",
    "fullName": "IOnLoseCondition",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void LoseCondition(float amount)\r\n{\r\n\tif (hasCondition && !ConVar.Debugging.disablecondition)\r\n\t{\r\n\t\tfloat num = condition;\r\n\t\tcondition -= amount;\r\n\t\tif (ConVar.Global.developer > 0)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.Log(info.shortname + \" was damaged by: \" + amount + \"cond is: \" + condition + \"/\" + maxCondition);\r\n\t\t}\r\n\t\tif (condition <= 0f && condition < num)\r\n\t\t{\r\n\t\t\tOnBroken();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Item",
    "methodName": "LoseCondition",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemUse",
    "fullName": "OnItemUse",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "amountToConsume",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UseItem(int amountToConsume = 1)\r\n{\r\n\tif (amountToConsume > 0)\r\n\t{\r\n\t\tamount -= amountToConsume;\r\n\t\tReduceItemOwnership(amountToConsume);\r\n\t\tif (amount <= 0)\r\n\t\t{\r\n\t\t\tamount = 0;\r\n\t\t\tRemove();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tMarkDirty();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Item",
    "methodName": "UseItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemSplit",
    "fullName": "OnItemSplit",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "#define UNITY_ASSERTIONS\r\npublic Item SplitItem(int split_Amount)\r\n{\r\n\tUnityEngine.Assertions.Assert.IsTrue(split_Amount > 0, \"split_Amount <= 0\");\r\n\tif (split_Amount <= 0)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tif (split_Amount >= amount)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tamount -= split_Amount;\r\n\tItem item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);\r\n\titem.amount = split_Amount;\r\n\titem.skin = skin;\r\n\tMigrateItemOwnership(item, split_Amount);\r\n\tif (IsBlueprint())\r\n\t{\r\n\t\titem.blueprintTarget = blueprintTarget;\r\n\t}\r\n\tif (info.amountType == ItemDefinition.AmountType.Genetics && instanceData != null && instanceData.dataInt != 0)\r\n\t{\r\n\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\r\n\t\titem.instanceData.dataInt = instanceData.dataInt;\r\n\t\titem.instanceData.ShouldPool = false;\r\n\t}\r\n\tif (instanceData != null && instanceData.dataInt > 0 && info != null && info.Blueprint != null && info.Blueprint.GetWorkbenchLevel() == 3)\r\n\t{\r\n\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\r\n\t\titem.instanceData.dataInt = instanceData.dataInt;\r\n\t\titem.instanceData.ShouldPool = false;\r\n\t\titem.SetFlag(Item.Flag.IsOn, IsOn());\r\n\t}\r\n\tif (instanceData != null && (bool)info.GetComponent<ItemModFoodSpoiling>())\r\n\t{\r\n\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\r\n\t\titem.instanceData.dataFloat = instanceData.dataFloat;\r\n\t\titem.instanceData.ShouldPool = false;\r\n\t}\r\n\tMarkDirty();\r\n\treturn item;\r\n}\r\n",
    "targetName": "Item",
    "methodName": "SplitItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "Item"
  },
  {
    "name": "CanStackItem",
    "fullName": "CanStackItem",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanStack(Item item)\r\n{\r\n\tif (item == this)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (MaxStackable() <= 1)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (item.info.stackable <= 1)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (item.info.itemid != info.itemid)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (hasCondition && condition != item.info.condition.max)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (item.hasCondition && item.condition != item.info.condition.max)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!IsValid())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (IsBlueprint() && blueprintTarget != item.blueprintTarget)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (item.skin != skin)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)\r\n\t{\r\n\t\tint num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\r\n\t\tint num2 = ((instanceData != null) ? instanceData.dataInt : (-1));\r\n\t\tif (num != num2)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\tif (item.instanceData != null && instanceData != null && (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt && item.info.Blueprint != null && item.info.Blueprint.GetWorkbenchLevel() == 3)))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (instanceData != null && instanceData.subEntity.IsValid && (bool)info.GetComponent<ItemModSign>())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (item.instanceData != null && item.instanceData.subEntity.IsValid && (bool)item.info.GetComponent<ItemModSign>())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (item.instanceData != null && instanceData != null && item.info.TryGetComponent<ItemModFoodSpoiling>(out var component))\r\n\t{\r\n\t\tbool flag = false;\r\n\t\tfloat dataFloat = item.instanceData.dataFloat;\r\n\t\tfloat dataFloat2 = instanceData.dataFloat;\r\n\t\tif (UnityEngine.Mathf.Abs(dataFloat - dataFloat2) < ConVar.Server.maxFoodSpoilTimeDiffForItemStack)\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t}\r\n\t\tfloat num3 = component.TotalSpoilTimeHours * 60f * 60f;\r\n\t\tfloat num4 = item.instanceData.dataFloat / num3;\r\n\t\tfloat num5 = instanceData.dataFloat / num3;\r\n\t\tif (num4 > ConVar.Server.normalisedFoodSpoilTimeStackThreshold && num5 > ConVar.Server.normalisedFoodSpoilTimeStackThreshold)\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t}\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "Item",
    "methodName": "CanStack",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnItemDropped",
    "fullName": "OnItemDropped",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public BaseEntity Drop(UnityEngine.Vector3 vPos, UnityEngine.Vector3 vVelocity, UnityEngine.Quaternion rotation = default(UnityEngine.Quaternion))\r\n{\r\n\tulong droppedBy = GetRootContainer()?.playerOwner?.userID ?? ((EncryptedValue<ulong>)0uL);\r\n\tRemoveFromWorld();\r\n\tif (info.AlignWorldModelOnDrop)\r\n\t{\r\n\t\trotation = UnityEngine.Quaternion.Euler(0f, UnityEngine.Quaternion.LookRotation(vVelocity.normalized, UnityEngine.Vector3.up).eulerAngles.y, 0f);\r\n\t\trotation = UnityEngine.Quaternion.Euler(info.WorldModelDropOffset) * rotation;\r\n\t}\r\n\tBaseEntity baseEntity = null;\r\n\tif (vPos != UnityEngine.Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))\r\n\t{\r\n\t\tbaseEntity = CreateWorldObject(vPos, rotation);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.SetVelocity(vVelocity);\r\n\t\t}\r\n\t\tif (baseEntity is DroppedItem droppedItem)\r\n\t\t{\r\n\t\t\tdroppedItem.DroppedBy = droppedBy;\r\n\t\t\tif (info.AdjustCenterOfMassOnDrop)\r\n\t\t\t{\r\n\t\t\t\tdroppedItem.Rigidbody.centerOfMass = info.DropCenterOfMass;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tRemove();\r\n\t}\r\n\tRemoveFromContainer();\r\n\treturn baseEntity;\r\n}\r\n",
    "targetName": "Item",
    "methodName": "Drop",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMaxStackable",
    "fullName": "OnMaxStackable",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public int MaxStackable()\r\n{\r\n\tint num = info.stackable;\r\n\tif (parent != null && parent.maxStackSize > 0)\r\n\t{\r\n\t\tnum = UnityEngine.Mathf.Min(parent.maxStackSize, num);\r\n\t}\r\n\treturn num;\r\n}\r\n",
    "targetName": "Item",
    "methodName": "MaxStackable",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Int32"
  },
  {
    "name": "OnItemRemove",
    "fullName": "OnItemRemove",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Remove(float fTime = 0f)\r\n{\r\n\tif (removeTime > 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (isServer)\r\n\t{\r\n\t\tItemMod[] itemMods = info.itemMods;\r\n\t\tfor (int i = 0; i < itemMods.Length; i++)\r\n\t\t{\r\n\t\t\titemMods[i].OnRemove(this);\r\n\t\t}\r\n\t}\r\n\tthis.onCycle = null;\r\n\tremoveTime = UnityEngine.Time.time + fTime;\r\n\tthis.OnDirty = null;\r\n\tposition = -1;\r\n\tItemManager.RemoveItem(this, fTime);\r\n}\r\n",
    "targetName": "Item",
    "methodName": "Remove",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemStacked",
    "fullName": "OnItemStacked [1]",
    "category": "Item",
    "parameters": [
      {
        "name": "local11",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "newcontainer",
        "type": "ItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local13",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)\r\n{\r\n\tusing (TimeWarning.New(\"MoveToContainer\"))\r\n\t{\r\n\t\tbool flag = iTargetPos == -1;\r\n\t\tItemContainer itemContainer = parent;\r\n\t\tif (iTargetPos == -1)\r\n\t\t{\r\n\t\t\tif (allowStack && info.stackable > 1)\r\n\t\t\t{\r\n\t\t\t\tforeach (Item item3 in System.Linq.Enumerable.OrderBy(newcontainer.FindItemsByItemID(info.itemid), (Item x) => x.position))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (item3.CanStack(this) && (ignoreStackLimit || item3.amount < item3.MaxStackable()))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tiTargetPos = item3.position;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)\r\n\t\t\t{\r\n\t\t\t\tiTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);\r\n\t\t\t\tif (iTargetPos == int.MinValue)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (iTargetPos == -1)\r\n\t\t\t{\r\n\t\t\t\tif (newcontainer == parent)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tbool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;\r\n\t\t\t\tItemModWearable itemModWearable = info.ItemModWearable;\r\n\t\t\t\tfor (int i = 0; i < newcontainer.capacity; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tItem slot = newcontainer.GetSlot(i);\r\n\t\t\t\t\tif (slot == null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (CanMoveTo(newcontainer, i))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tiTargetPos = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tiTargetPos = i;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (newcontainer.HasAvailableSlotsDefined && DoItemSlotsConflict(slot))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tiTargetPos = i;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (flag2 && iTargetPos == -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tiTargetPos = newcontainer.capacity - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (iTargetPos == -1)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (!CanMoveTo(newcontainer, iTargetPos))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))\r\n\t\t{\r\n\t\t\tItem slot2 = newcontainer.GetSlot(iTargetPos);\r\n\t\t\tif (slot2 == this)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (allowStack && slot2 != null)\r\n\t\t\t{\r\n\t\t\t\tint num = slot2.MaxStackable();\r\n\t\t\t\tif (slot2.CanStack(this))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (ignoreStackLimit)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnum = int.MaxValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (slot2.amount >= num)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tint num2 = UnityEngine.Mathf.Min(num - slot2.amount, amount);\r\n\t\t\t\t\tslot2.amount += num2;\r\n\t\t\t\t\tif (slot2.instanceData != null && instanceData != null && (bool)info.GetComponent<ItemModFoodSpoiling>())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tslot2.instanceData.dataFloat = UnityEngine.Mathf.Min(slot2.instanceData.dataFloat, instanceData.dataFloat);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnewcontainer.onItemAddedToStack?.Invoke(slot2, num2);\r\n\t\t\t\t\tamount -= num2;\r\n\t\t\t\t\tslot2.MarkDirty();\r\n\t\t\t\t\tMarkDirty();\r\n\t\t\t\t\tMigrateItemOwnership(slot2, num2);\r\n\t\t\t\t\tif (amount <= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tRemoveFromWorld();\r\n\t\t\t\t\t\tRemoveFromContainer();\r\n\t\t\t\t\t\tRemove();\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (flag)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (parent != null && allowSwap && slot2 != null)\r\n\t\t\t{\r\n\t\t\t\tItemContainer itemContainer2 = parent;\r\n\t\t\t\tint iTargetPos2 = position;\r\n\t\t\t\tItemContainer newcontainer2 = slot2.parent;\r\n\t\t\t\tint num3 = slot2.position;\r\n\t\t\t\tif (!slot2.CanMoveTo(itemContainer2, iTargetPos2))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)\r\n\t\t\t\t{\r\n\t\t\t\t\tItem item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);\r\n\t\t\t\t\tif (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tslot2.amount += item.amount;\r\n\t\t\t\t\t\titem.MigrateItemOwnership(slot2, item.amount);\r\n\t\t\t\t\t\titem.Remove();\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tBaseEntity entityOwner = GetEntityOwner();\r\n\t\t\t\tBaseEntity entityOwner2 = slot2.GetEntityOwner();\r\n\t\t\t\tRemoveFromContainer();\r\n\t\t\t\tslot2.RemoveFromContainer();\r\n\t\t\t\tRemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);\r\n\t\t\t\tslot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);\r\n\t\t\t\tif (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))\r\n\t\t\t\t{\r\n\t\t\t\t\tRemoveFromContainer();\r\n\t\t\t\t\tslot2.RemoveFromContainer();\r\n\t\t\t\t\tSetParent(itemContainer2);\r\n\t\t\t\t\tposition = iTargetPos2;\r\n\t\t\t\t\tslot2.SetParent(newcontainer2);\r\n\t\t\t\t\tslot2.position = num3;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (parent == newcontainer)\r\n\t\t{\r\n\t\t\tif (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))\r\n\t\t\t{\r\n\t\t\t\tnewcontainer.onItemPositionChanged?.Invoke(this, position, iTargetPos);\r\n\t\t\t\tposition = iTargetPos;\r\n\t\t\t\tMarkDirty();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)\r\n\t\t{\r\n\t\t\tItem item2 = SplitItem(newcontainer.maxStackSize);\r\n\t\t\tif (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))\r\n\t\t\t{\r\n\t\t\t\tDroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;\r\n\t\t\t\tif (droppedItem != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tdroppedItem.DroppedBy = sourcePlayer?.userID ?? ((EncryptedValue<ulong>)0uL);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (!newcontainer.CanAccept(this))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tBaseEntity entityOwner3 = GetEntityOwner();\r\n\t\tRemoveFromContainer();\r\n\t\tRemoveFromWorld();\r\n\t\tRemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);\r\n\t\tposition = iTargetPos;\r\n\t\tSetParent(newcontainer);\r\n\t\treturn true;\r\n\t}\r\n}\r\n",
    "targetName": "Item",
    "methodName": "MoveToContainer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemStacked",
    "fullName": "OnItemStacked [2]",
    "category": "Item",
    "parameters": [
      {
        "name": "local21",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "newcontainer",
        "type": "ItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)\r\n{\r\n\tusing (TimeWarning.New(\"MoveToContainer\"))\r\n\t{\r\n\t\tbool flag = iTargetPos == -1;\r\n\t\tItemContainer itemContainer = parent;\r\n\t\tif (iTargetPos == -1)\r\n\t\t{\r\n\t\t\tif (allowStack && info.stackable > 1)\r\n\t\t\t{\r\n\t\t\t\tforeach (Item item3 in System.Linq.Enumerable.OrderBy(newcontainer.FindItemsByItemID(info.itemid), (Item x) => x.position))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (item3.CanStack(this) && (ignoreStackLimit || item3.amount < item3.MaxStackable()))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tiTargetPos = item3.position;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)\r\n\t\t\t{\r\n\t\t\t\tiTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);\r\n\t\t\t\tif (iTargetPos == int.MinValue)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (iTargetPos == -1)\r\n\t\t\t{\r\n\t\t\t\tif (newcontainer == parent)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tbool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;\r\n\t\t\t\tItemModWearable itemModWearable = info.ItemModWearable;\r\n\t\t\t\tfor (int i = 0; i < newcontainer.capacity; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tItem slot = newcontainer.GetSlot(i);\r\n\t\t\t\t\tif (slot == null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (CanMoveTo(newcontainer, i))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tiTargetPos = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tiTargetPos = i;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (newcontainer.HasAvailableSlotsDefined && DoItemSlotsConflict(slot))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tiTargetPos = i;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (flag2 && iTargetPos == -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tiTargetPos = newcontainer.capacity - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (iTargetPos == -1)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (!CanMoveTo(newcontainer, iTargetPos))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))\r\n\t\t{\r\n\t\t\tItem slot2 = newcontainer.GetSlot(iTargetPos);\r\n\t\t\tif (slot2 == this)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (allowStack && slot2 != null)\r\n\t\t\t{\r\n\t\t\t\tint num = slot2.MaxStackable();\r\n\t\t\t\tif (slot2.CanStack(this))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (ignoreStackLimit)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnum = int.MaxValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (slot2.amount >= num)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tint num2 = UnityEngine.Mathf.Min(num - slot2.amount, amount);\r\n\t\t\t\t\tslot2.amount += num2;\r\n\t\t\t\t\tif (slot2.instanceData != null && instanceData != null && (bool)info.GetComponent<ItemModFoodSpoiling>())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tslot2.instanceData.dataFloat = UnityEngine.Mathf.Min(slot2.instanceData.dataFloat, instanceData.dataFloat);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnewcontainer.onItemAddedToStack?.Invoke(slot2, num2);\r\n\t\t\t\t\tamount -= num2;\r\n\t\t\t\t\tslot2.MarkDirty();\r\n\t\t\t\t\tMarkDirty();\r\n\t\t\t\t\tMigrateItemOwnership(slot2, num2);\r\n\t\t\t\t\tif (amount <= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tRemoveFromWorld();\r\n\t\t\t\t\t\tRemoveFromContainer();\r\n\t\t\t\t\t\tRemove();\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (flag)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (parent != null && allowSwap && slot2 != null)\r\n\t\t\t{\r\n\t\t\t\tItemContainer itemContainer2 = parent;\r\n\t\t\t\tint iTargetPos2 = position;\r\n\t\t\t\tItemContainer newcontainer2 = slot2.parent;\r\n\t\t\t\tint num3 = slot2.position;\r\n\t\t\t\tif (!slot2.CanMoveTo(itemContainer2, iTargetPos2))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)\r\n\t\t\t\t{\r\n\t\t\t\t\tItem item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);\r\n\t\t\t\t\tif (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tslot2.amount += item.amount;\r\n\t\t\t\t\t\titem.MigrateItemOwnership(slot2, item.amount);\r\n\t\t\t\t\t\titem.Remove();\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tBaseEntity entityOwner = GetEntityOwner();\r\n\t\t\t\tBaseEntity entityOwner2 = slot2.GetEntityOwner();\r\n\t\t\t\tRemoveFromContainer();\r\n\t\t\t\tslot2.RemoveFromContainer();\r\n\t\t\t\tRemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);\r\n\t\t\t\tslot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);\r\n\t\t\t\tif (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))\r\n\t\t\t\t{\r\n\t\t\t\t\tRemoveFromContainer();\r\n\t\t\t\t\tslot2.RemoveFromContainer();\r\n\t\t\t\t\tSetParent(itemContainer2);\r\n\t\t\t\t\tposition = iTargetPos2;\r\n\t\t\t\t\tslot2.SetParent(newcontainer2);\r\n\t\t\t\t\tslot2.position = num3;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (parent == newcontainer)\r\n\t\t{\r\n\t\t\tif (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))\r\n\t\t\t{\r\n\t\t\t\tnewcontainer.onItemPositionChanged?.Invoke(this, position, iTargetPos);\r\n\t\t\t\tposition = iTargetPos;\r\n\t\t\t\tMarkDirty();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)\r\n\t\t{\r\n\t\t\tItem item2 = SplitItem(newcontainer.maxStackSize);\r\n\t\t\tif (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))\r\n\t\t\t{\r\n\t\t\t\tDroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;\r\n\t\t\t\tif (droppedItem != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tdroppedItem.DroppedBy = sourcePlayer?.userID ?? ((EncryptedValue<ulong>)0uL);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (!newcontainer.CanAccept(this))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tBaseEntity entityOwner3 = GetEntityOwner();\r\n\t\tRemoveFromContainer();\r\n\t\tRemoveFromWorld();\r\n\t\tRemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);\r\n\t\tposition = iTargetPos;\r\n\t\tSetParent(newcontainer);\r\n\t\treturn true;\r\n\t}\r\n}\r\n",
    "targetName": "Item",
    "methodName": "MoveToContainer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemLock",
    "fullName": "OnItemLock",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void LockUnlock(bool bNewState)\r\n{\r\n\tif (HasFlag(Item.Flag.IsLocked) != bNewState)\r\n\t{\r\n\t\tSetFlag(Item.Flag.IsLocked, bNewState);\r\n\t\tMarkDirty();\r\n\t}\r\n}\r\n",
    "targetName": "Item",
    "methodName": "LockUnlock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemUnlock",
    "fullName": "OnItemUnlock",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void LockUnlock(bool bNewState)\r\n{\r\n\tif (HasFlag(Item.Flag.IsLocked) != bNewState)\r\n\t{\r\n\t\tSetFlag(Item.Flag.IsLocked, bNewState);\r\n\t\tMarkDirty();\r\n\t}\r\n}\r\n",
    "targetName": "Item",
    "methodName": "LockUnlock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnHealingItemUse",
    "fullName": "OnHealingItemUse",
    "category": "Item",
    "parameters": [
      {
        "name": "medicalTool",
        "type": "MedicalTool, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GiveEffectsTo(BasePlayer player)\r\n{\r\n\tif (!player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemDefinition ownerItemDefinition = GetOwnerItemDefinition();\r\n\tItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();\r\n\tif (!component)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"No consumable for medicaltool :\" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\r\n\tif (player != ownerPlayer && player.IsWounded() && canRevive)\r\n\t{\r\n\t\tplayer.StopWounded(ownerPlayer);\r\n\t}\r\n\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\r\n\t{\r\n\t\tif (effect.type == MetabolismAttribute.Type.Health)\r\n\t\t{\r\n\t\t\tplayer.health += effect.amount;\r\n\t\t\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\r\n\t\t}\r\n\t}\r\n\tif (player is BasePet)\r\n\t{\r\n\t\tplayer.SendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "MedicalTool",
    "methodName": "GiveEffectsTo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemResearch",
    "fullName": "OnItemResearch",
    "category": "Item",
    "parameters": [
      {
        "name": "researchTable",
        "type": "ResearchTable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void DoResearch(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (IsResearching())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = msg.player;\r\n\tItem targetItem = GetTargetItem();\r\n\tif (targetItem != null && targetItem.amount <= 1 && IsItemResearchable(targetItem))\r\n\t{\r\n\t\ttargetItem.CollectedForCrafting(player);\r\n\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;\r\n\t\tInvoke(ResearchAttemptFinished, researchDuration);\r\n\t\tbase.inventory.SetLocked(isLocked: true);\r\n\t\tint scrapCost = ScrapForResearch(targetItem);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\tSendNetworkUpdate();\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tif (researchStartEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\t}\r\n\t\tmsg.player.GiveAchievement(\"RESEARCH_ITEM\");\r\n\t}\r\n}\r\n",
    "targetName": "ResearchTable",
    "methodName": "DoResearch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemResearched",
    "fullName": "OnItemResearched",
    "category": "Item",
    "parameters": [
      {
        "name": "researchTable",
        "type": "ResearchTable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ResearchAttemptFinished()\r\n{\r\n\tItem targetItem = GetTargetItem();\r\n\tItem scrapItem = GetScrapItem();\r\n\tif (targetItem != null && scrapItem != null)\r\n\t{\r\n\t\tint num = ScrapForResearch(targetItem);\r\n\t\tif (scrapItem.amount >= num)\r\n\t\t{\r\n\t\t\tif (scrapItem.amount == num)\r\n\t\t\t{\r\n\t\t\t\tbase.inventory.Remove(scrapItem);\r\n\t\t\t\tscrapItem.RemoveFromContainer();\r\n\t\t\t\tscrapItem.Remove();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tscrapItem.UseItem(num);\r\n\t\t\t}\r\n\t\t\tbase.inventory.Remove(targetItem);\r\n\t\t\ttargetItem.Remove();\r\n\t\t\tItem item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);\r\n\t\t\tif (base.LastLootedByPlayer != null)\r\n\t\t\t{\r\n\t\t\t\titem.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.ResearchTable);\r\n\t\t\t}\r\n\t\t\titem.blueprintTarget = ((targetItem.info.isRedirectOf != null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);\r\n\t\t\tif (!item.MoveToContainer(base.inventory, 0))\r\n\t\t\t{\r\n\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t\t}\r\n\t\t\tif (researchSuccessEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(researchSuccessEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tSendNetworkUpdateImmediate();\r\n\tif (user != null)\r\n\t{\r\n\t\tuser.inventory.loot.SendImmediate();\r\n\t}\r\n\tEndResearch();\r\n}\r\n",
    "targetName": "ResearchTable",
    "methodName": "ResearchAttemptFinished",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnResearchCostDetermine",
    "fullName": "OnResearchCostDetermine [Item]",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static int ScrapForResearch(Item item)\r\n{\r\n\treturn ScrapForResearch(item.info);\r\n}\r\n",
    "targetName": "ResearchTable",
    "methodName": "ScrapForResearch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Int32"
  },
  {
    "name": "OnResearchCostDetermine",
    "fullName": "OnResearchCostDetermine [ItemDef]",
    "category": "Item",
    "parameters": [
      {
        "name": "info",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static int ScrapForResearch(Item item)\r\n{\r\n\treturn ScrapForResearch(item.info);\r\n}\r\n",
    "targetName": "ResearchTable",
    "methodName": "ScrapForResearch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Int32"
  },
  {
    "name": "OnItemRepair",
    "fullName": "OnItemRepair",
    "category": "Item",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "itemToRepair",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)\r\n{\r\n\tif (itemToRepair == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemDefinition info = itemToRepair.info;\r\n\tItemBlueprint component = info.GetComponent<ItemBlueprint>();\r\n\tif (!component)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemModRepair component2 = itemToRepair.info.GetComponent<ItemModRepair>();\r\n\tif (!info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (mustKnowBlueprint)\r\n\t{\r\n\t\tItemDefinition itemDefinition = ((info.isRedirectOf != null) ? info.isRedirectOf : info);\r\n\t\tif (!player.blueprints.HasUnlocked(itemDefinition) && (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tfloat num = RepairCostFraction(itemToRepair);\r\n\tbool flag = false;\r\n\tSystem.Collections.Generic.List<ItemAmount> obj = Facepunch.Pool.Get<System.Collections.Generic.List<ItemAmount>>();\r\n\tGetRepairCostList(component, obj);\r\n\tforeach (ItemAmount item in obj)\r\n\t{\r\n\t\tif (item.itemDef.category != ItemCategory.Component)\r\n\t\t{\r\n\t\t\tint amount = player.inventory.GetAmount(item.itemDef.itemid);\r\n\t\t\tif (UnityEngine.Mathf.CeilToInt(item.amount * num) > amount)\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn;\r\n\t}\r\n\tforeach (ItemAmount item2 in obj)\r\n\t{\r\n\t\tif (item2.itemDef.category != ItemCategory.Component)\r\n\t\t{\r\n\t\t\tint amount2 = UnityEngine.Mathf.CeilToInt(item2.amount * num);\r\n\t\t\tplayer.inventory.Take(null, item2.itemid, amount2);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, \"repair\", item2.itemDef.shortname, amount2, repairBenchEntity, null, safezone: false, null, 0uL, null, itemToRepair);\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\tfloat conditionNormalized = itemToRepair.conditionNormalized;\r\n\tfloat maxConditionNormalized = itemToRepair.maxConditionNormalized;\r\n\titemToRepair.DoRepair(maxConditionLostOnRepair);\r\n\tFacepunch.Rust.Analytics.Azure.OnItemRepaired(player, repairBenchEntity, itemToRepair, conditionNormalized, maxConditionNormalized);\r\n\tif (ConVar.Global.developer > 0)\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"Item repaired! condition : \" + itemToRepair.condition + \"/\" + itemToRepair.maxCondition);\r\n\t}\r\n\tstring strName = \"assets/bundled/prefabs/fx/repairbench/itemrepair.prefab\";\r\n\tif (component2 != null && component2.successEffect?.Get() != null)\r\n\t{\r\n\t\tstrName = component2.successEffect.resourcePath;\r\n\t}\r\n\tEffect.server.Run(strName, repairBenchEntity, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n}\r\n",
    "targetName": "RepairBench",
    "methodName": "RepairAnItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemSkinChange",
    "fullName": "OnItemSkinChange",
    "category": "Item",
    "parameters": [
      {
        "name": "local2",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local6",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "repairBench",
        "type": "RepairBench, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ChangeSkin(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tint num = msg.read.Int32();\r\n\tItemId itemId = new ItemId(msg.read.UInt64());\r\n\tbool isValid = itemId.IsValid;\r\n\tbool flag = !isValid || UnityEngine.Time.realtimeSinceStartup > nextSkinChangeAudioTime;\r\n\tItem slot = base.inventory.GetSlot(0);\r\n\tif (slot == null || (isValid && slot.uid != itemId))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag2 = false;\r\n\tif (msg.player.UnlockAllSkins)\r\n\t{\r\n\t\tflag2 = true;\r\n\t}\r\n\tif (num != 0 && !flag2 && !player.blueprints.CheckSkinOwnership(num, player.userID))\r\n\t{\r\n\t\tdebugprint(\"RepairBench.ChangeSkin player does not have item :\" + num + \":\");\r\n\t\treturn;\r\n\t}\r\n\tulong Skin = ItemDefinition.FindSkin(slot.info.itemid, num);\r\n\tif (Skin == slot.skin && slot.info.isRedirectOf == null)\r\n\t{\r\n\t\tdebugprint(\"RepairBench.ChangeSkin cannot apply same skin twice : \" + Skin + \": \" + slot.skin);\r\n\t\treturn;\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tnextSkinChangeAudioTime = UnityEngine.Time.realtimeSinceStartup + 0.75f;\r\n\t}\r\n\tItemSkinDirectory.Skin skin = System.Linq.Enumerable.FirstOrDefault(slot.info.skins, (ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);\r\n\tif (slot.info.isRedirectOf != null)\r\n\t{\r\n\t\tSkin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, num);\r\n\t\tskin = System.Linq.Enumerable.FirstOrDefault(slot.info.isRedirectOf.skins, (ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);\r\n\t}\r\n\tItemSkin itemSkin = ((skin.id == 0) ? null : (skin.invItem as ItemSkin));\r\n\tif (((bool)itemSkin && (itemSkin.Redirect != null || slot.info.isRedirectOf != null)) || (!itemSkin && slot.info.isRedirectOf != null))\r\n\t{\r\n\t\tItemDefinition template = ((itemSkin != null) ? itemSkin.Redirect : slot.info.isRedirectOf);\r\n\t\tbool flag3 = false;\r\n\t\tif (itemSkin != null && itemSkin.Redirect == null && slot.info.isRedirectOf != null)\r\n\t\t{\r\n\t\t\ttemplate = slot.info.isRedirectOf;\r\n\t\t\tflag3 = num != 0;\r\n\t\t}\r\n\t\tfloat condition = slot.condition;\r\n\t\tfloat maxCondition = slot.maxCondition;\r\n\t\tint amount = slot.amount;\r\n\t\tint ammoCount = 0;\r\n\t\tint num2 = 0;\r\n\t\tItemModContainerArmorSlot component = slot.info.GetComponent<ItemModContainerArmorSlot>();\r\n\t\tif (component != null && slot.contents != null)\r\n\t\t{\r\n\t\t\tnum2 = slot.contents.capacity;\r\n\t\t}\r\n\t\tItemDefinition ammoType = null;\r\n\t\tif (slot.GetHeldEntity() != null && slot.GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)\r\n\t\t{\r\n\t\t\tammoCount = baseProjectile.primaryMagazine.contents;\r\n\t\t\tammoType = baseProjectile.primaryMagazine.ammoType;\r\n\t\t}\r\n\t\tSystem.Collections.Generic.List<Item> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Item>>();\r\n\t\tif (slot.contents != null && slot.contents.itemList != null && slot.contents.itemList.Count > 0)\r\n\t\t{\r\n\t\t\tif (slot.contents.itemList.Count > obj.Capacity)\r\n\t\t\t{\r\n\t\t\t\tobj.Capacity = slot.contents.itemList.Count;\r\n\t\t\t}\r\n\t\t\tforeach (Item item2 in slot.contents.itemList)\r\n\t\t\t{\r\n\t\t\t\tobj.Add(item2);\r\n\t\t\t}\r\n\t\t\tforeach (Item item3 in obj)\r\n\t\t\t{\r\n\t\t\t\titem3.RemoveFromContainer();\r\n\t\t\t}\r\n\t\t}\r\n\t\tItem item = ItemManager.Create(template, 1, 0uL);\r\n\t\titem.ownershipShares = slot.ownershipShares;\r\n\t\tslot.ownershipShares = null;\r\n\t\tslot.Remove();\r\n\t\tItemManager.DoRemoves();\r\n\t\titem.MoveToContainer(base.inventory, 0, allowStack: false);\r\n\t\titem.maxCondition = maxCondition;\r\n\t\titem.condition = condition;\r\n\t\titem.amount = amount;\r\n\t\tif (item.GetHeldEntity() != null && item.GetHeldEntity() is BaseProjectile baseProjectile2)\r\n\t\t{\r\n\t\t\tif (baseProjectile2.primaryMagazine != null)\r\n\t\t\t{\r\n\t\t\t\tbaseProjectile2.SetAmmoCount(ammoCount);\r\n\t\t\t\tbaseProjectile2.primaryMagazine.ammoType = ammoType;\r\n\t\t\t}\r\n\t\t\tbaseProjectile2.ForceModsChanged();\r\n\t\t}\r\n\t\tif (num2 > 0)\r\n\t\t{\r\n\t\t\tcomponent = item.info.GetComponent<ItemModContainerArmorSlot>();\r\n\t\t\tcomponent.CreateAtCapacity(num2, item);\r\n\t\t}\r\n\t\tif (obj.Count > 0 && item.contents != null)\r\n\t\t{\r\n\t\t\tif (component != null)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < obj.Count; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tobj[i]?.MoveToContainer(item.contents, i, allowStack: false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tforeach (Item item4 in obj)\r\n\t\t\t\t{\r\n\t\t\t\t\titem4.MoveToContainer(item.contents);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\r\n\t\tif (flag3)\r\n\t\t{\r\n\t\t\tApplySkinToItem(item, Skin);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Server.SkinUsed(item.info.shortname, num);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, item, Skin);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tApplySkinToItem(slot, Skin);\r\n\t\tFacepunch.Rust.Analytics.Server.SkinUsed(slot.info.shortname, num);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, slot, Skin);\r\n\t}\r\n\tif (flag && skinchangeEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(skinchangeEffect.resourcePath, this, 0u, new UnityEngine.Vector3(0f, 1.5f, 0f), UnityEngine.Vector3.zero);\r\n\t}\r\n}\r\n",
    "targetName": "RepairBench",
    "methodName": "ChangeSkin",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMapImageUpdated",
    "fullName": "OnMapImageUpdated",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\npublic void ImageUpdate(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbyte b = msg.read.UInt8();\r\n\tbyte b2 = msg.read.UInt8();\r\n\tuint num = msg.read.UInt32();\r\n\tif ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tuint num2 = (uint)(b * 1000 + b2);\r\n\tbyte[] array = msg.read.BytesWithSize();\r\n\tif (array != null)\r\n\t{\r\n\t\tFileStorage.server.RemoveEntityNum(net.ID, num2);\r\n\t\tuint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);\r\n\t\tif (b == 0)\r\n\t\t{\r\n\t\t\tfogImages[b2] = num3;\r\n\t\t}\r\n\t\tif (b == 1)\r\n\t\t{\r\n\t\t\tpaintImages[b2] = num3;\r\n\t\t}\r\n\t\tInvalidateNetworkCache();\r\n\t}\r\n}\r\n",
    "targetName": "MapEntity",
    "methodName": "ImageUpdate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemUpgrade",
    "fullName": "OnItemUpgrade",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void ServerCommand(Item item, string command, BasePlayer player)\r\n{\r\n\tif (!(command == \"upgrade_item\") || item.amount < numForUpgrade)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Random.Range(0f, 1f) <= upgradeSuccessChance)\r\n\t{\r\n\t\titem.UseItem(numForUpgrade);\r\n\t\tItem item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);\r\n\t\titem2.SetItemOwnership(player, ItemOwnershipPhrases.UpgradeItem);\r\n\t\tif (!item2.MoveToContainer(player.inventory.containerMain))\r\n\t\t{\r\n\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\r\n\t\t}\r\n\t\tif (successEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\titem.UseItem(numToLoseOnFail);\r\n\t\tif (failEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(failEffect.resourcePath, player.eyes.position);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ItemModUpgrade",
    "methodName": "ServerCommand",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanEquipItem",
    "fullName": "CanEquipItem",
    "category": "Item",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanEquipItem(Item item, int targetSlot)\r\n{\r\n\tif ((item.info.flags & ItemDefinition.Flag.NotAllowedInBelt) != 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (base.baseEntity != null && base.baseEntity.IsRestrained)\r\n\t{\r\n\t\tHandcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();\r\n\t\tif (restraintItem != null && restraintItem.GetItem().position == targetSlot)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\tItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();\r\n\tif (component == null)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tItem[] array = containerBelt.itemList.ToArray();\r\n\tforeach (Item item2 in array)\r\n\t{\r\n\t\tif (item2 != item)\r\n\t\t{\r\n\t\t\tItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();\r\n\t\t\tif (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))\r\n\t\t\t{\r\n\t\t\t\titem2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "CanEquipItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanWearItem",
    "fullName": "CanWearItem",
    "category": "Item",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanWearItem(Item item, int targetSlot)\r\n{\r\n\treturn CanWearItem(item, canAdjustClothing: true, targetSlot);\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "CanWearItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnItemAction",
    "fullName": "OnItemAction",
    "category": "Item",
    "parameters": [
      {
        "name": "local2",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\npublic void ItemCmd(BaseEntity.RPCMessage msg)\r\n{\r\n\tif ((msg.player != null && msg.player.IsWounded()) || base.baseEntity.IsTransferring())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemId id = msg.read.ItemID();\r\n\tstring text = msg.read.String();\r\n\tItem item = FindItemByUID(id);\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity entityOwner = item.GetEntityOwner();\r\n\tif ((entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering) || item.IsLocked() || (item.parent != null && item.parent.IsLocked()) || !CanMoveItemsFrom(item.GetEntityOwner(), item))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (text == \"drop\")\r\n\t{\r\n\t\tint num = item.amount;\r\n\t\tif (msg.read.Unread >= 4)\r\n\t\t{\r\n\t\t\tnum = msg.read.Int32();\r\n\t\t}\r\n\t\tif (!msg.player.isMounted && !msg.player.HasParent() && !GamePhysics.LineOfSight(msg.player.transform.position, msg.player.eyes.position, 1218519041))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbase.baseEntity.stats.Add(\"item_drop\", 1, (Stats)5);\r\n\t\tif (num < item.amount)\r\n\t\t{\r\n\t\t\tItem item2 = item.SplitItem(num);\r\n\t\t\tItemContainer parent = item.parent;\r\n\t\t\tif (item2 != null)\r\n\t\t\t{\r\n\t\t\t\tDroppedItem droppedItem = item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;\r\n\t\t\t\tif (droppedItem != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Player;\r\n\t\t\t\t\tdroppedItem.DroppedBy = base.baseEntity.userID;\r\n\t\t\t\t\tdroppedItem.DroppedTime = System.DateTime.UtcNow;\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem, DroppedItem.DropReasonEnum.Player);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tparent?.onItemRemovedFromStack?.Invoke(item, num);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tItemContainer parent2 = item.parent;\r\n\t\t\tDroppedItem droppedItem2 = item.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;\r\n\t\t\tif (droppedItem2 != null)\r\n\t\t\t{\r\n\t\t\t\tdroppedItem2.DropReason = DroppedItem.DropReasonEnum.Player;\r\n\t\t\t\tdroppedItem2.DroppedBy = base.baseEntity.userID;\r\n\t\t\t\tdroppedItem2.DroppedTime = System.DateTime.UtcNow;\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem2, DroppedItem.DropReasonEnum.Player);\r\n\t\t\t}\r\n\t\t\tparent2?.onItemAddedRemoved?.Invoke(item, arg2: false);\r\n\t\t}\r\n\t\tbase.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, \"drop_item\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\titem.ServerCommand(text, base.baseEntity);\r\n\t\tItemManager.DoRemoves();\r\n\t\tServerUpdate(0f);\r\n\t}\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "ItemCmd",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanMoveItem",
    "fullName": "CanMoveItem",
    "category": "Item",
    "parameters": [
      {
        "name": "local5",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "ItemContainerId, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local3",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local4",
        "type": "ItemMoveModifier, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\npublic void MoveItem(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (base.baseEntity.IsTransferring())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemId id = msg.read.ItemID();\r\n\tItemContainerId itemContainerId = msg.read.ItemContainerID();\r\n\tint num = msg.read.Int8();\r\n\tint num2 = (int)msg.read.UInt32();\r\n\tItemMoveModifier itemMoveModifier = (ItemMoveModifier)msg.read.Int32();\r\n\tItem item = FindItemByUID(id);\r\n\tif (item == null)\r\n\t{\r\n\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidItem, false);\r\n\t\tConstructionErrors.Log(msg.player, id.ToString());\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity entityOwner = item.GetEntityOwner();\r\n\tif (entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!CanMoveItemsFrom(entityOwner, item))\r\n\t{\r\n\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.CannotMoveItem, true);\r\n\t\treturn;\r\n\t}\r\n\tif (num2 <= 0)\r\n\t{\r\n\t\tnum2 = item.amount;\r\n\t}\r\n\tnum2 = UnityEngine.Mathf.Clamp(num2, 1, item.MaxStackable());\r\n\tif (msg.player.GetActiveItem() == item)\r\n\t{\r\n\t\tmsg.player.UpdateActiveItem(default(ItemId));\r\n\t}\r\n\tif (!itemContainerId.IsValid)\r\n\t{\r\n\t\tBaseEntity baseEntity = entityOwner;\r\n\t\tif (loot.containers.Count > 0)\r\n\t\t{\r\n\t\t\tif (entityOwner == base.baseEntity)\r\n\t\t\t{\r\n\t\t\t\tif (!itemMoveModifier.HasFlag(ItemMoveModifier.Alt))\r\n\t\t\t\t{\r\n\t\t\t\t\tbaseEntity = loot.entitySource;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbaseEntity = base.baseEntity;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (baseEntity is IIdealSlotEntity idealSlotEntity)\r\n\t\t{\r\n\t\t\titemContainerId = idealSlotEntity.GetIdealContainer(base.baseEntity, item, itemMoveModifier);\r\n\t\t\tif (itemContainerId == ItemContainerId.Invalid)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tItemContainer parent = item.parent;\r\n\t\tif (parent != null && parent.IsLocked())\r\n\t\t{\r\n\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!itemContainerId.IsValid)\r\n\t\t{\r\n\t\t\tif (baseEntity == loot.entitySource)\r\n\t\t\t{\r\n\t\t\t\tforeach (ItemContainer container in loot.containers)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!container.PlayerItemInputBlocked() && !container.IsLocked() && item.MoveToContainer(container, -1, allowStack: true, ignoreStackLimit: false, base.baseEntity))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (!GiveItem(item, itemMoveModifier))\r\n\t\t\t{\r\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, \"GiveItem failed!\", false);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tItemContainer itemContainer = FindContainer(itemContainerId);\r\n\tif (itemContainer == null)\r\n\t{\r\n\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidContainer, false);\r\n\t\tConstructionErrors.Log(msg.player, itemContainerId.ToString());\r\n\t\treturn;\r\n\t}\r\n\tif (itemContainer.IsLocked())\r\n\t{\r\n\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);\r\n\t\treturn;\r\n\t}\r\n\tif (itemContainer.PlayerItemInputBlocked())\r\n\t{\r\n\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.DoesntAcceptPlayerItems, false);\r\n\t\treturn;\r\n\t}\r\n\tif (itemContainer.maxStackSize > 0)\r\n\t{\r\n\t\tnum2 = UnityEngine.Mathf.Clamp(num2, 1, itemContainer.maxStackSize);\r\n\t}\r\n\tusing (TimeWarning.New(\"Split\"))\r\n\t{\r\n\t\tif (item.amount > num2)\r\n\t\t{\r\n\t\t\tint split_Amount = num2;\r\n\t\t\tItem item2 = item.SplitItem(split_Amount);\r\n\t\t\tItem slot = itemContainer.GetSlot(num);\r\n\t\t\tif (slot != null && !item.CanStack(slot) && item.parent != null && !item2.MoveToContainer(item.parent, -1, allowStack: false, ignoreStackLimit: false, base.baseEntity, allowSwap: false))\r\n\t\t\t{\r\n\t\t\t\titem.amount += item2.amount;\r\n\t\t\t\titem2.Remove();\r\n\t\t\t\tItemManager.DoRemoves();\r\n\t\t\t\tServerUpdate(0f);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (!item2.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))\r\n\t\t\t{\r\n\t\t\t\titem.amount += item2.amount;\r\n\t\t\t\titem2.Remove();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\titem.parent.onItemRemovedFromStack?.Invoke(item, num2);\r\n\t\t\t}\r\n\t\t\tItemManager.DoRemoves();\r\n\t\t\tServerUpdate(0f);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (item.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))\r\n\t{\r\n\t\tItemManager.DoRemoves();\r\n\t\tServerUpdate(0f);\r\n\t}\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "MoveItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnInventoryItemsCount",
    "fullName": "OnInventoryItemsCount",
    "category": "Item",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public int GetAmount(ItemDefinition definition)\r\n{\r\n\tif (!(definition != null))\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\treturn GetAmount(definition.itemid);\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "GetAmount",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Int32"
  },
  {
    "name": "OnInventoryItemsTake",
    "fullName": "OnInventoryItemsTake",
    "category": "Item",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public int Take(System.Collections.Generic.List<Item> collect, int itemid, int amount)\r\n{\r\n\tint num = 0;\r\n\tif (containerMain != null)\r\n\t{\r\n\t\tint num2 = containerMain.Take(collect, itemid, amount);\r\n\t\tnum += num2;\r\n\t\tamount -= num2;\r\n\t}\r\n\tif (amount <= 0)\r\n\t{\r\n\t\treturn num;\r\n\t}\r\n\tif (containerBelt != null)\r\n\t{\r\n\t\tint num3 = containerBelt.Take(collect, itemid, amount);\r\n\t\tnum += num3;\r\n\t\tamount -= num3;\r\n\t}\r\n\tif (amount <= 0)\r\n\t{\r\n\t\treturn num;\r\n\t}\r\n\tif (containerWear != null)\r\n\t{\r\n\t\tint num4 = containerWear.Take(collect, itemid, amount);\r\n\t\tnum += num4;\r\n\t\tamount -= num4;\r\n\t}\r\n\treturn num;\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "Take",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Int32"
  },
  {
    "name": "OnInventoryItemsFind",
    "fullName": "OnInventoryItemsFind",
    "category": "Item",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public System.Collections.Generic.List<Item> FindItemsByItemID(int id)\r\n{\r\n\tSystem.Collections.Generic.List<Item> list = new System.Collections.Generic.List<Item>();\r\n\tif (containerMain != null)\r\n\t{\r\n\t\tlist.AddRange(containerMain.FindItemsByItemID(id));\r\n\t}\r\n\tif (containerBelt != null)\r\n\t{\r\n\t\tlist.AddRange(containerBelt.FindItemsByItemID(id));\r\n\t}\r\n\tif (containerWear != null)\r\n\t{\r\n\t\tlist.AddRange(containerWear.FindItemsByItemID(id));\r\n\t}\r\n\treturn list;\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "FindItemsByItemID",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Collections.Generic.List`1[[Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]"
  },
  {
    "name": "OnInventoryAmmoFind",
    "fullName": "OnInventoryAmmoFind",
    "category": "Item",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public Item FindAmmo(Rust.AmmoTypes ammoType)\r\n{\r\n\tItem item = containerMain?.FindAmmo(ammoType);\r\n\tif (item == null)\r\n\t{\r\n\t\titem = containerBelt?.FindAmmo(ammoType);\r\n\t}\r\n\treturn item;\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "FindAmmo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBackpackDrop",
    "fullName": "OnBackpackDrop",
    "category": "Item",
    "parameters": [
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TryDropBackpack()\r\n{\r\n\tItem anyBackpack = GetAnyBackpack();\r\n\tif (anyBackpack != null && base.baseEntity.isServer)\r\n\t{\r\n\t\tanyBackpack.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());\r\n\t}\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "TryDropBackpack",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnInventoryItemFind",
    "fullName": "OnInventoryItemFind",
    "category": "Item",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public Item FindItemByItemID(string itemName)\r\n{\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemName);\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\treturn FindItemByItemID(itemDefinition.itemid);\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "FindItemByItemID",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "Item"
  },
  {
    "name": "OnInventoryAmmoItemFind",
    "fullName": "OnInventoryAmmoItemFind [PlayerInventory]",
    "category": "Item",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public Item FindAmmo(Rust.AmmoTypes ammoType)\r\n{\r\n\tItem item = containerMain?.FindAmmo(ammoType);\r\n\tif (item == null)\r\n\t{\r\n\t\titem = containerBelt?.FindAmmo(ammoType);\r\n\t}\r\n\treturn item;\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "FindAmmo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "Item"
  },
  {
    "name": "OnItemPickup",
    "fullName": "OnItemPickup",
    "category": "Item",
    "parameters": [
      {
        "name": "worldItem",
        "type": "WorldItem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void Pickup(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && this.item != null && allowPickup && CanOpenInSafeZone(msg.player))\r\n\t{\r\n\t\tItemModContainer component = this.item.info.GetComponent<ItemModContainer>();\r\n\t\tif (!(component != null) || !component.canLootInWorld || !(component.pickupInWorldDelay > 0f) || !(UnityEngine.Mathf.Abs(pickupStartTime + component.pickupInWorldDelay - UnityEngine.Time.realtimeSinceStartup) > ConVar.AntiHack.rpc_timer_forgiveness))\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\"PickupSound\"));\r\n\t\t\tItem item = this.item;\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnItemPickup(msg.player, this);\r\n\t\t\tRemoveItem();\r\n\t\t\tTryApplyOwnershipOnPickup(msg.player, item);\r\n\t\t\tmsg.player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);\r\n\t\t\tmsg.player.SignalBroadcast(BaseEntity.Signal.Gesture, \"pickup_item\");\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WorldItem",
    "methodName": "Pickup",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFindBurnable",
    "fullName": "OnFindBurnable",
    "category": "Item",
    "parameters": [
      {
        "name": "baseOven",
        "type": "BaseOven, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public Item FindBurnable()\r\n{\r\n\tif (base.inventory == null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tforeach (Item item in base.inventory.itemList)\r\n\t{\r\n\t\tif (IsBurnableItem(item))\r\n\t\t{\r\n\t\t\treturn item;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "FindBurnable",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "Item"
  },
  {
    "name": "OnItemRecycle",
    "fullName": "OnItemRecycle",
    "category": "Item",
    "parameters": [
      {
        "name": "local3",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "recycler",
        "type": "Recycler, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RecycleThink()\r\n{\r\n\tbool flag = false;\r\n\tfloat num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tItem slot = base.inventory.GetSlot(i);\r\n\t\tif (!CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (slot.hasCondition)\r\n\t\t{\r\n\t\t\tnum = UnityEngine.Mathf.Clamp01(num * UnityEngine.Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));\r\n\t\t}\r\n\t\tint num2 = 1;\r\n\t\tif (slot.amount > 1)\r\n\t\t{\r\n\t\t\tnum2 = UnityEngine.Mathf.CeilToInt(UnityEngine.Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));\r\n\t\t}\r\n\t\tif (slot.info.Blueprint.scrapFromRecycle > 0)\r\n\t\t{\r\n\t\t\tfloat num3 = slot.info.Blueprint.scrapFromRecycle * num2;\r\n\t\t\tif (slot.MaxStackable() == 1 && slot.hasCondition)\r\n\t\t\t{\r\n\t\t\t\tnum3 *= slot.conditionNormalized;\r\n\t\t\t}\r\n\t\t\tfloat num4 = num / 0.5f;\r\n\t\t\tnum3 *= num4;\r\n\t\t\tint num5 = UnityEngine.Mathf.FloorToInt(num3);\r\n\t\t\tfloat num6 = num3 - (float)num5;\r\n\t\t\tscrapRemainder += num6;\r\n\t\t\tif (scrapRemainder >= 1f)\r\n\t\t\t{\r\n\t\t\t\tint num7 = UnityEngine.Mathf.FloorToInt(scrapRemainder);\r\n\t\t\t\tscrapRemainder -= num7;\r\n\t\t\t\tnum5 += num7;\r\n\t\t\t}\r\n\t\t\tif (num5 >= 1)\r\n\t\t\t{\r\n\t\t\t\tItem item = ItemManager.CreateByName(\"scrap\", num5, 0uL);\r\n\t\t\t\tif (base.LastLootedByPlayer != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titem.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);\r\n\t\t\t\tMoveItemToOutput(item);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))\r\n\t\t{\r\n\t\t\tSystem.Collections.Generic.List<BasePlayer> obj = Facepunch.Pool.Get<System.Collections.Generic.List<BasePlayer>>();\r\n\t\t\tVis.Entities(base.transform.position, 3f, obj, 131072);\r\n\t\t\tforeach (BasePlayer item3 in obj)\r\n\t\t\t{\r\n\t\t\t\tif (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)\r\n\t\t\t\t{\r\n\t\t\t\t\titem3.stats.Add(slot.info.Blueprint.RecycleStat, num2, (Stats)5);\r\n\t\t\t\t\titem3.stats.Save();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num2, this);\r\n\t\tslot.UseItem(num2);\r\n\t\tforeach (ItemAmount ingredient in slot.info.Blueprint.GetIngredients())\r\n\t\t{\r\n\t\t\tif (ingredient.itemDef.shortname == \"scrap\")\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfloat num8 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num2;\r\n\t\t\tint num9 = UnityEngine.Mathf.FloorToInt(num8);\r\n\t\t\tfloat num10 = num8 - (float)num9;\r\n\t\t\tif (num10 > float.Epsilon && UnityEngine.Random.Range(0f, 1f) <= num10)\r\n\t\t\t{\r\n\t\t\t\tnum9++;\r\n\t\t\t}\r\n\t\t\tif (num9 <= 0)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tint num11 = UnityEngine.Mathf.CeilToInt((float)num9 / (float)ingredient.itemDef.stackable);\r\n\t\t\tfor (int j = 0; j < num11; j++)\r\n\t\t\t{\r\n\t\t\t\tif (ingredient.itemDef.IsAllowedInEra(Rust.EraRestriction.Recycle))\r\n\t\t\t\t{\r\n\t\t\t\t\tint num12 = ((num9 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num9);\r\n\t\t\t\t\tItem item2 = ItemManager.Create(ingredient.itemDef, num12, 0uL);\r\n\t\t\t\t\tif (base.LastLootedByPlayer != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);\r\n\t\t\t\t\tif (!MoveItemToOutput(item2))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tflag = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnum9 -= num12;\r\n\t\t\t\t\tif (num9 <= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\tif (flag || !HasRecyclable())\r\n\t{\r\n\t\tStopRecycling();\r\n\t}\r\n}\r\n",
    "targetName": "Recycler",
    "methodName": "RecycleThink",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemRecycleAmount",
    "fullName": "OnItemRecycleAmount",
    "category": "Item",
    "parameters": [
      {
        "name": "local3",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "recycler",
        "type": "Recycler, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RecycleThink()\r\n{\r\n\tbool flag = false;\r\n\tfloat num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tItem slot = base.inventory.GetSlot(i);\r\n\t\tif (!CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (slot.hasCondition)\r\n\t\t{\r\n\t\t\tnum = UnityEngine.Mathf.Clamp01(num * UnityEngine.Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));\r\n\t\t}\r\n\t\tint num2 = 1;\r\n\t\tif (slot.amount > 1)\r\n\t\t{\r\n\t\t\tnum2 = UnityEngine.Mathf.CeilToInt(UnityEngine.Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));\r\n\t\t}\r\n\t\tif (slot.info.Blueprint.scrapFromRecycle > 0)\r\n\t\t{\r\n\t\t\tfloat num3 = slot.info.Blueprint.scrapFromRecycle * num2;\r\n\t\t\tif (slot.MaxStackable() == 1 && slot.hasCondition)\r\n\t\t\t{\r\n\t\t\t\tnum3 *= slot.conditionNormalized;\r\n\t\t\t}\r\n\t\t\tfloat num4 = num / 0.5f;\r\n\t\t\tnum3 *= num4;\r\n\t\t\tint num5 = UnityEngine.Mathf.FloorToInt(num3);\r\n\t\t\tfloat num6 = num3 - (float)num5;\r\n\t\t\tscrapRemainder += num6;\r\n\t\t\tif (scrapRemainder >= 1f)\r\n\t\t\t{\r\n\t\t\t\tint num7 = UnityEngine.Mathf.FloorToInt(scrapRemainder);\r\n\t\t\t\tscrapRemainder -= num7;\r\n\t\t\t\tnum5 += num7;\r\n\t\t\t}\r\n\t\t\tif (num5 >= 1)\r\n\t\t\t{\r\n\t\t\t\tItem item = ItemManager.CreateByName(\"scrap\", num5, 0uL);\r\n\t\t\t\tif (base.LastLootedByPlayer != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titem.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);\r\n\t\t\t\tMoveItemToOutput(item);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))\r\n\t\t{\r\n\t\t\tSystem.Collections.Generic.List<BasePlayer> obj = Facepunch.Pool.Get<System.Collections.Generic.List<BasePlayer>>();\r\n\t\t\tVis.Entities(base.transform.position, 3f, obj, 131072);\r\n\t\t\tforeach (BasePlayer item3 in obj)\r\n\t\t\t{\r\n\t\t\t\tif (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)\r\n\t\t\t\t{\r\n\t\t\t\t\titem3.stats.Add(slot.info.Blueprint.RecycleStat, num2, (Stats)5);\r\n\t\t\t\t\titem3.stats.Save();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num2, this);\r\n\t\tslot.UseItem(num2);\r\n\t\tforeach (ItemAmount ingredient in slot.info.Blueprint.GetIngredients())\r\n\t\t{\r\n\t\t\tif (ingredient.itemDef.shortname == \"scrap\")\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfloat num8 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num2;\r\n\t\t\tint num9 = UnityEngine.Mathf.FloorToInt(num8);\r\n\t\t\tfloat num10 = num8 - (float)num9;\r\n\t\t\tif (num10 > float.Epsilon && UnityEngine.Random.Range(0f, 1f) <= num10)\r\n\t\t\t{\r\n\t\t\t\tnum9++;\r\n\t\t\t}\r\n\t\t\tif (num9 <= 0)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tint num11 = UnityEngine.Mathf.CeilToInt((float)num9 / (float)ingredient.itemDef.stackable);\r\n\t\t\tfor (int j = 0; j < num11; j++)\r\n\t\t\t{\r\n\t\t\t\tif (ingredient.itemDef.IsAllowedInEra(Rust.EraRestriction.Recycle))\r\n\t\t\t\t{\r\n\t\t\t\t\tint num12 = ((num9 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num9);\r\n\t\t\t\t\tItem item2 = ItemManager.Create(ingredient.itemDef, num12, 0uL);\r\n\t\t\t\t\tif (base.LastLootedByPlayer != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);\r\n\t\t\t\t\tif (!MoveItemToOutput(item2))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tflag = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnum9 -= num12;\r\n\t\t\t\t\tif (num9 <= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\tif (flag || !HasRecyclable())\r\n\t{\r\n\t\tStopRecycling();\r\n\t}\r\n}\r\n",
    "targetName": "Recycler",
    "methodName": "RecycleThink",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemRecycle",
    "fullName": "OnItemRecycle [2]",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RecycleThink()\r\n{\r\n\tbool flag = false;\r\n\tfloat num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tItem slot = base.inventory.GetSlot(i);\r\n\t\tif (!CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (slot.hasCondition)\r\n\t\t{\r\n\t\t\tnum = UnityEngine.Mathf.Clamp01(num * UnityEngine.Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));\r\n\t\t}\r\n\t\tint num2 = 1;\r\n\t\tif (slot.amount > 1)\r\n\t\t{\r\n\t\t\tnum2 = UnityEngine.Mathf.CeilToInt(UnityEngine.Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));\r\n\t\t}\r\n\t\tif (slot.info.Blueprint.scrapFromRecycle > 0)\r\n\t\t{\r\n\t\t\tfloat num3 = slot.info.Blueprint.scrapFromRecycle * num2;\r\n\t\t\tif (slot.MaxStackable() == 1 && slot.hasCondition)\r\n\t\t\t{\r\n\t\t\t\tnum3 *= slot.conditionNormalized;\r\n\t\t\t}\r\n\t\t\tfloat num4 = num / 0.5f;\r\n\t\t\tnum3 *= num4;\r\n\t\t\tint num5 = UnityEngine.Mathf.FloorToInt(num3);\r\n\t\t\tfloat num6 = num3 - (float)num5;\r\n\t\t\tscrapRemainder += num6;\r\n\t\t\tif (scrapRemainder >= 1f)\r\n\t\t\t{\r\n\t\t\t\tint num7 = UnityEngine.Mathf.FloorToInt(scrapRemainder);\r\n\t\t\t\tscrapRemainder -= num7;\r\n\t\t\t\tnum5 += num7;\r\n\t\t\t}\r\n\t\t\tif (num5 >= 1)\r\n\t\t\t{\r\n\t\t\t\tItem item = ItemManager.CreateByName(\"scrap\", num5, 0uL);\r\n\t\t\t\tif (base.LastLootedByPlayer != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titem.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);\r\n\t\t\t\tMoveItemToOutput(item);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))\r\n\t\t{\r\n\t\t\tSystem.Collections.Generic.List<BasePlayer> obj = Facepunch.Pool.Get<System.Collections.Generic.List<BasePlayer>>();\r\n\t\t\tVis.Entities(base.transform.position, 3f, obj, 131072);\r\n\t\t\tforeach (BasePlayer item3 in obj)\r\n\t\t\t{\r\n\t\t\t\tif (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)\r\n\t\t\t\t{\r\n\t\t\t\t\titem3.stats.Add(slot.info.Blueprint.RecycleStat, num2, (Stats)5);\r\n\t\t\t\t\titem3.stats.Save();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num2, this);\r\n\t\tslot.UseItem(num2);\r\n\t\tforeach (ItemAmount ingredient in slot.info.Blueprint.GetIngredients())\r\n\t\t{\r\n\t\t\tif (ingredient.itemDef.shortname == \"scrap\")\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfloat num8 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num2;\r\n\t\t\tint num9 = UnityEngine.Mathf.FloorToInt(num8);\r\n\t\t\tfloat num10 = num8 - (float)num9;\r\n\t\t\tif (num10 > float.Epsilon && UnityEngine.Random.Range(0f, 1f) <= num10)\r\n\t\t\t{\r\n\t\t\t\tnum9++;\r\n\t\t\t}\r\n\t\t\tif (num9 <= 0)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tint num11 = UnityEngine.Mathf.CeilToInt((float)num9 / (float)ingredient.itemDef.stackable);\r\n\t\t\tfor (int j = 0; j < num11; j++)\r\n\t\t\t{\r\n\t\t\t\tif (ingredient.itemDef.IsAllowedInEra(Rust.EraRestriction.Recycle))\r\n\t\t\t\t{\r\n\t\t\t\t\tint num12 = ((num9 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num9);\r\n\t\t\t\t\tItem item2 = ItemManager.Create(ingredient.itemDef, num12, 0uL);\r\n\t\t\t\t\tif (base.LastLootedByPlayer != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);\r\n\t\t\t\t\tif (!MoveItemToOutput(item2))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tflag = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnum9 -= num12;\r\n\t\t\t\t\tif (num9 <= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\tif (flag || !HasRecyclable())\r\n\t{\r\n\t\tStopRecycling();\r\n\t}\r\n}\r\n",
    "targetName": "Recycler",
    "methodName": "RecycleThink",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanCombineDroppedItem",
    "fullName": "CanCombineDroppedItem",
    "category": "Item",
    "parameters": [
      {
        "name": "droppedItem",
        "type": "DroppedItem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "di",
        "type": "DroppedItem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnDroppedOn(DroppedItem di)\r\n{\r\n\tif (item == null || di.item == null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (di.item.info != null)\r\n\t{\r\n\t\tif (di.item.info.amountType == ItemDefinition.AmountType.Genetics)\r\n\t\t{\r\n\t\t\tint num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));\r\n\t\t\tint num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\r\n\t\t\tif (num != num2)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tint num3 = di.item.amount + item.amount;\r\n\tif (num3 <= item.MaxStackable() && num3 != 0)\r\n\t{\r\n\t\tif (di.DropReason == DroppedItem.DropReasonEnum.Player)\r\n\t\t{\r\n\t\t\tDropReason = DroppedItem.DropReasonEnum.Player;\r\n\t\t}\r\n\t\tdi.item.MigrateItemOwnership(item, di.item.amount);\r\n\t\tdi.DestroyItem();\r\n\t\tdi.Kill();\r\n\t\tint worldModelIndex = item.info.GetWorldModelIndex(item.amount);\r\n\t\titem.amount = num3;\r\n\t\titem.MarkDirty();\r\n\t\tif (GetDespawnDuration() < float.PositiveInfinity)\r\n\t\t{\r\n\t\t\tInvoke(IdleDestroy, GetDespawnDuration());\r\n\t\t}\r\n\t\tEffect.server.Run(\"assets/bundled/prefabs/fx/notice/stack.world.fx.prefab\", this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\tint worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);\r\n\t\tif (worldModelIndex != worldModelIndex2)\r\n\t\t{\r\n\t\t\titem.Drop(base.transform.position, UnityEngine.Vector3.zero, base.transform.rotation);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "DroppedItem",
    "methodName": "OnDroppedOn",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDroppedItemCombined",
    "fullName": "OnDroppedItemCombined",
    "category": "Item",
    "parameters": [
      {
        "name": "droppedItem",
        "type": "DroppedItem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnDroppedOn(DroppedItem di)\r\n{\r\n\tif (item == null || di.item == null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (di.item.info != null)\r\n\t{\r\n\t\tif (di.item.info.amountType == ItemDefinition.AmountType.Genetics)\r\n\t\t{\r\n\t\t\tint num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));\r\n\t\t\tint num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\r\n\t\t\tif (num != num2)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tint num3 = di.item.amount + item.amount;\r\n\tif (num3 <= item.MaxStackable() && num3 != 0)\r\n\t{\r\n\t\tif (di.DropReason == DroppedItem.DropReasonEnum.Player)\r\n\t\t{\r\n\t\t\tDropReason = DroppedItem.DropReasonEnum.Player;\r\n\t\t}\r\n\t\tdi.item.MigrateItemOwnership(item, di.item.amount);\r\n\t\tdi.DestroyItem();\r\n\t\tdi.Kill();\r\n\t\tint worldModelIndex = item.info.GetWorldModelIndex(item.amount);\r\n\t\titem.amount = num3;\r\n\t\titem.MarkDirty();\r\n\t\tif (GetDespawnDuration() < float.PositiveInfinity)\r\n\t\t{\r\n\t\t\tInvoke(IdleDestroy, GetDespawnDuration());\r\n\t\t}\r\n\t\tEffect.server.Run(\"assets/bundled/prefabs/fx/notice/stack.world.fx.prefab\", this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\tint worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);\r\n\t\tif (worldModelIndex != worldModelIndex2)\r\n\t\t{\r\n\t\t\titem.Drop(base.transform.position, UnityEngine.Vector3.zero, base.transform.rotation);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "DroppedItem",
    "methodName": "OnDroppedOn",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnItemDespawn",
    "fullName": "OnItemDespawn",
    "category": "Item",
    "parameters": [
      {
        "name": "droppedItem",
        "type": "DroppedItem, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void IdleDestroy()\r\n{\r\n\tFacepunch.Rust.Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);\r\n\tDestroyItem();\r\n\tKill();\r\n}\r\n",
    "targetName": "DroppedItem",
    "methodName": "IdleDestroy",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnBonusItemDrop",
    "fullName": "OnBonusItemDrop",
    "category": "Item",
    "parameters": [
      {
        "name": "local5",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void DropBonusItems(BaseEntity initiator, ItemContainer container)\r\n{\r\n\tbase.DropBonusItems(initiator, container);\r\n\tif (initiator == null || container == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer = initiator as BasePlayer;\r\n\tif (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\r\n\tif (!(num > 1f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\r\n\tfloat num2 = UnityEngine.Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\r\n\tvariableValue += num2;\r\n\tint num3 = 0;\r\n\tif (variableValue >= 1f)\r\n\t{\r\n\t\tnum3 = (int)variableValue;\r\n\t\tvariableValue -= (float)num3;\r\n\t}\r\n\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\r\n\tif (num3 > 0)\r\n\t{\r\n\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\t(item.Drop(GetDropPosition() + new UnityEngine.Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "LootContainer",
    "methodName": "DropBonusItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBonusItemDropped",
    "fullName": "OnBonusItemDropped",
    "category": "Item",
    "parameters": [
      {
        "name": "local5",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void DropBonusItems(BaseEntity initiator, ItemContainer container)\r\n{\r\n\tbase.DropBonusItems(initiator, container);\r\n\tif (initiator == null || container == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer = initiator as BasePlayer;\r\n\tif (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\r\n\tif (!(num > 1f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\r\n\tfloat num2 = UnityEngine.Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\r\n\tvariableValue += num2;\r\n\tint num3 = 0;\r\n\tif (variableValue >= 1f)\r\n\t{\r\n\t\tnum3 = (int)variableValue;\r\n\t\tvariableValue -= (float)num3;\r\n\t}\r\n\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\r\n\tif (num3 > 0)\r\n\t{\r\n\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\t(item.Drop(GetDropPosition() + new UnityEngine.Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "LootContainer",
    "methodName": "DropBonusItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnBonusItemDropped [patch 1]",
    "fullName": "OnBonusItemDropped [patch 1]",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void DropBonusItems(BaseEntity initiator, ItemContainer container)\r\n{\r\n\tbase.DropBonusItems(initiator, container);\r\n\tif (initiator == null || container == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer = initiator as BasePlayer;\r\n\tif (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\r\n\tif (!(num > 1f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\r\n\tfloat num2 = UnityEngine.Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\r\n\tvariableValue += num2;\r\n\tint num3 = 0;\r\n\tif (variableValue >= 1f)\r\n\t{\r\n\t\tnum3 = (int)variableValue;\r\n\t\tvariableValue -= (float)num3;\r\n\t}\r\n\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\r\n\tif (num3 > 0)\r\n\t{\r\n\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\t(item.Drop(GetDropPosition() + new UnityEngine.Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "LootContainer",
    "methodName": "DropBonusItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBonusItemDropped [patch 2]",
    "fullName": "OnBonusItemDropped [patch 2]",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void DropBonusItems(BaseEntity initiator, ItemContainer container)\r\n{\r\n\tbase.DropBonusItems(initiator, container);\r\n\tif (initiator == null || container == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer = initiator as BasePlayer;\r\n\tif (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\r\n\tif (!(num > 1f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\r\n\tfloat num2 = UnityEngine.Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\r\n\tvariableValue += num2;\r\n\tint num3 = 0;\r\n\tif (variableValue >= 1f)\r\n\t{\r\n\t\tnum3 = (int)variableValue;\r\n\t\tvariableValue -= (float)num3;\r\n\t}\r\n\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\r\n\tif (num3 > 0)\r\n\t{\r\n\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\t(item.Drop(GetDropPosition() + new UnityEngine.Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "LootContainer",
    "methodName": "DropBonusItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBonusItemDropped [patch 3]",
    "fullName": "OnBonusItemDropped [patch 3]",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void DropBonusItems(BaseEntity initiator, ItemContainer container)\r\n{\r\n\tbase.DropBonusItems(initiator, container);\r\n\tif (initiator == null || container == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer = initiator as BasePlayer;\r\n\tif (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\r\n\tif (!(num > 1f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\r\n\tfloat num2 = UnityEngine.Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\r\n\tvariableValue += num2;\r\n\tint num3 = 0;\r\n\tif (variableValue >= 1f)\r\n\t{\r\n\t\tnum3 = (int)variableValue;\r\n\t\tvariableValue -= (float)num3;\r\n\t}\r\n\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\r\n\tif (num3 > 0)\r\n\t{\r\n\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\t(item.Drop(GetDropPosition() + new UnityEngine.Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "LootContainer",
    "methodName": "DropBonusItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBonusItemDropped [patch 4]",
    "fullName": "OnBonusItemDropped [patch 4]",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void DropBonusItems(BaseEntity initiator, ItemContainer container)\r\n{\r\n\tbase.DropBonusItems(initiator, container);\r\n\tif (initiator == null || container == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer = initiator as BasePlayer;\r\n\tif (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\r\n\tif (!(num > 1f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\r\n\tfloat num2 = UnityEngine.Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\r\n\tvariableValue += num2;\r\n\tint num3 = 0;\r\n\tif (variableValue >= 1f)\r\n\t{\r\n\t\tnum3 = (int)variableValue;\r\n\t\tvariableValue -= (float)num3;\r\n\t}\r\n\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\r\n\tif (num3 > 0)\r\n\t{\r\n\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\t(item.Drop(GetDropPosition() + new UnityEngine.Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "LootContainer",
    "methodName": "DropBonusItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBonusItemDropped [patch 5]",
    "fullName": "OnBonusItemDropped [patch 5]",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void DropBonusItems(BaseEntity initiator, ItemContainer container)\r\n{\r\n\tbase.DropBonusItems(initiator, container);\r\n\tif (initiator == null || container == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer = initiator as BasePlayer;\r\n\tif (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\r\n\tif (!(num > 1f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\r\n\tfloat num2 = UnityEngine.Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\r\n\tvariableValue += num2;\r\n\tint num3 = 0;\r\n\tif (variableValue >= 1f)\r\n\t{\r\n\t\tnum3 = (int)variableValue;\r\n\t\tvariableValue -= (float)num3;\r\n\t}\r\n\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\r\n\tif (num3 > 0)\r\n\t{\r\n\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\t(item.Drop(GetDropPosition() + new UnityEngine.Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "LootContainer",
    "methodName": "DropBonusItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemRefill",
    "fullName": "OnItemRefill",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void ServerCommand(Item item, string command, BasePlayer player)\r\n{\r\n\tif (command == \"refill\" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f))\r\n\t{\r\n\t\tfloat conditionNormalized = item.conditionNormalized;\r\n\t\tfloat maxConditionNormalized = item.maxConditionNormalized;\r\n\t\titem.DoRepair(conditionLost);\r\n\t\tif (successEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnItemRepaired(player, player.GetCachedCraftLevelWorkbench(), item, conditionNormalized, maxConditionNormalized);\r\n\t}\r\n}\r\n",
    "targetName": "ItemModRepair",
    "methodName": "ServerCommand",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemSubmit",
    "fullName": "OnItemSubmit",
    "category": "Item",
    "parameters": [
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "mailbox",
        "type": "Mailbox, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "fromPlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SubmitInputItems(BasePlayer fromPlayer)\r\n{\r\n\tfor (int i = 0; i < InputContainer.capacity; i++)\r\n\t{\r\n\t\tItem slot = InputContainer.GetSlot(i);\r\n\t\tif (slot != null && slot.MoveToContainer(base.inventory))\r\n\t\t{\r\n\t\t\tEffect.server.Run(mailDropSound.resourcePath, GetDropPosition());\r\n\t\t\tif (fromPlayer != null && !PlayerIsOwner(fromPlayer))\r\n\t\t\t{\r\n\t\t\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Mailbox",
    "methodName": "SubmitInputItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemSubmit",
    "fullName": "OnItemSubmit [patch]",
    "category": "Item",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SubmitInputItems(BasePlayer fromPlayer)\r\n{\r\n\tfor (int i = 0; i < InputContainer.capacity; i++)\r\n\t{\r\n\t\tItem slot = InputContainer.GetSlot(i);\r\n\t\tif (slot != null && slot.MoveToContainer(base.inventory))\r\n\t\t{\r\n\t\t\tEffect.server.Run(mailDropSound.resourcePath, GetDropPosition());\r\n\t\t\tif (fromPlayer != null && !PlayerIsOwner(fromPlayer))\r\n\t\t\t{\r\n\t\t\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Mailbox",
    "methodName": "SubmitInputItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemUnwrap",
    "fullName": "OnItemUnwrap",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "itemModUnwrap",
        "type": "ItemModUnwrap, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void ServerCommand(Item item, string command, BasePlayer player)\r\n{\r\n\tif (command == \"unwrap\" && item.amount > 0)\r\n\t{\r\n\t\titem.UseItem();\r\n\t\tint num = UnityEngine.Random.Range(minTries, maxTries + 1);\r\n\t\tItemOwnershipShare ownership = default(ItemOwnershipShare);\r\n\t\tif (OwnershipPhrase != null && !string.IsNullOrEmpty(OwnershipPhrase.token))\r\n\t\t{\r\n\t\t\tItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);\r\n\t\t\titemOwnershipShare.username = player.displayName;\r\n\t\t\titemOwnershipShare.reason = OwnershipPhrase.token;\r\n\t\t\townership = itemOwnershipShare;\r\n\t\t}\r\n\t\tfor (int i = 0; i < num; i++)\r\n\t\t{\r\n\t\t\trevealList.SpawnIntoContainer(player.inventory.containerMain, ownership);\r\n\t\t}\r\n\t\tif (successEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ItemModUnwrap",
    "methodName": "ServerCommand",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnItemPainted",
    "fullName": "OnItemPainted",
    "category": "Item",
    "parameters": [
      {
        "name": "paintedItemStorageEntity",
        "type": "PaintedItemStorageEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.CallsPerSecond(3uL)]\r\npublic void Server_UpdateImage(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player == null || (ulong)msg.player.userID != base.OwnerID)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (Item item2 in msg.player.inventory.containerWear.itemList)\r\n\t{\r\n\t\tif (item2.instanceData != null && item2.instanceData.subEntity == net.ID)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tItem item = msg.player.inventory.FindBySubEntityID(net.ID);\r\n\tif (item == null || item.isBroken)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbyte[] array = msg.read.BytesWithSize();\r\n\tif (array == null)\r\n\t{\r\n\t\tif (_currentImageCrc != 0)\r\n\t\t{\r\n\t\t\tFileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);\r\n\t\t}\r\n\t\t_currentImageCrc = 0u;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!ImageProcessing.IsValidPNG(array, 512, 512))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint currentImageCrc = _currentImageCrc;\r\n\t\tif (_currentImageCrc != 0)\r\n\t\t{\r\n\t\t\tFileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);\r\n\t\t}\r\n\t\t_currentImageCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);\r\n\t\tif (_currentImageCrc != currentImageCrc)\r\n\t\t{\r\n\t\t\titem.LoseCondition(0.25f);\r\n\t\t}\r\n\t\tlastEditedBy = msg.player.userID;\r\n\t}\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "PaintedItemStorageEntity",
    "methodName": "Server_UpdateImage",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnInventoryAmmoItemFind",
    "fullName": "OnInventoryAmmoItemFind [Chainsaw]",
    "category": "Item",
    "parameters": [
      {
        "name": "inventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "chainsaw",
        "type": "Chainsaw, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public Item GetAmmo()\r\n{\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\treturn ownerPlayer.inventory.FindItemByItemName(fuelType.shortname);\r\n}\r\n",
    "targetName": "Chainsaw",
    "methodName": "GetAmmo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "Item"
  },
  {
    "name": "OnInventoryAmmoItemFind",
    "fullName": "OnInventoryAmmoItemFind [FlameThrower]",
    "category": "Item",
    "parameters": [
      {
        "name": "inventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "flameThrower",
        "type": "FlameThrower, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public Item GetAmmo()\r\n{\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\treturn ownerPlayer.inventory.FindItemByItemName(fuelType.shortname);\r\n}\r\n",
    "targetName": "FlameThrower",
    "methodName": "GetAmmo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "Item"
  },
  {
    "name": "OnRackedWeaponMount",
    "fullName": "OnRackedWeaponMount",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void MountWeapon(BasePlayer player, int gridCellIndex, int rotation)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tHeldEntity heldEntity = player.GetHeldEntity();\r\n\tif (!(heldEntity == null))\r\n\t{\r\n\t\tItem item = heldEntity.GetItem();\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tMountWeapon(item, player, gridCellIndex, rotation);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "MountWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnRackedWeaponMounted",
    "fullName": "OnRackedWeaponMounted",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void MountWeapon(BasePlayer player, int gridCellIndex, int rotation)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tHeldEntity heldEntity = player.GetHeldEntity();\r\n\tif (!(heldEntity == null))\r\n\t{\r\n\t\tItem item = heldEntity.GetItem();\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tMountWeapon(item, player, gridCellIndex, rotation);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "MountWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRackedWeaponSwap",
    "fullName": "OnRackedWeaponSwap",
    "category": "Item",
    "parameters": [
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "WeaponRackSlot, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)\r\n{\r\n\tItem item = player.GetHeldEntity()?.GetItem();\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);\r\n\tif (forItemDef == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);\r\n\tif (weaponAtIndex != null)\r\n\t{\r\n\t\tint mountSlotIndex = gridCellIndex;\r\n\t\tif (CustomRackType != 0)\r\n\t\t{\r\n\t\t\tgridCellIndex = 0;\r\n\t\t}\r\n\t\tint bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);\r\n\t\tif (bestPlacementCellIndex != -1)\r\n\t\t{\r\n\t\t\titem.RemoveFromContainer();\r\n\t\t\tGivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);\r\n\t\t\tMountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);\r\n\t\t\tItemManager.DoRemoves();\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "SwapPlayerWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRackedWeaponSwapped",
    "fullName": "OnRackedWeaponSwapped",
    "category": "Item",
    "parameters": [
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "WeaponRackSlot, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)\r\n{\r\n\tItem item = player.GetHeldEntity()?.GetItem();\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);\r\n\tif (forItemDef == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);\r\n\tif (weaponAtIndex != null)\r\n\t{\r\n\t\tint mountSlotIndex = gridCellIndex;\r\n\t\tif (CustomRackType != 0)\r\n\t\t{\r\n\t\t\tgridCellIndex = 0;\r\n\t\t}\r\n\t\tint bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);\r\n\t\tif (bestPlacementCellIndex != -1)\r\n\t\t{\r\n\t\t\titem.RemoveFromContainer();\r\n\t\t\tGivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);\r\n\t\t\tMountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);\r\n\t\t\tItemManager.DoRemoves();\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "SwapPlayerWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRackedWeaponTake",
    "fullName": "OnRackedWeaponTake",
    "category": "Item",
    "parameters": [
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\r\n\tif (weaponAtIndex == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tClearSlot(weaponAtIndex);\r\n\tbool flag = false;\r\n\tbool flag2 = true;\r\n\tif (slot.IsBackpack())\r\n\t{\r\n\t\tflag2 = false;\r\n\t\tif (slot.info.GetComponent<ItemModBackpack>() != null && player.inventory.GetAnyBackpack() == null)\r\n\t\t{\r\n\t\t\tflag = slot.MoveToContainer(player.inventory.containerWear);\r\n\t\t}\r\n\t}\r\n\tif (!flag)\r\n\t{\r\n\t\tflag = slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex);\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tif (flag2 && ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1))\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.Player(\"SetActiveBeltSlot\", player), slot.position, slot.uid);\r\n\t\t}\r\n\t\tClientRPC(RpcTarget.Player(\"PlayGrabSound\", player), slot.info.itemid);\r\n\t}\r\n\telse if (!slot.MoveToContainer(player.inventory.containerMain))\r\n\t{\r\n\t\tslot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\r\n\t}\r\n\tif (sendUpdate)\r\n\t{\r\n\t\tItemManager.DoRemoves();\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "GivePlayerWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRackedWeaponTaken",
    "fullName": "OnRackedWeaponTaken",
    "category": "Item",
    "parameters": [
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\r\n\tif (weaponAtIndex == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tClearSlot(weaponAtIndex);\r\n\tbool flag = false;\r\n\tbool flag2 = true;\r\n\tif (slot.IsBackpack())\r\n\t{\r\n\t\tflag2 = false;\r\n\t\tif (slot.info.GetComponent<ItemModBackpack>() != null && player.inventory.GetAnyBackpack() == null)\r\n\t\t{\r\n\t\t\tflag = slot.MoveToContainer(player.inventory.containerWear);\r\n\t\t}\r\n\t}\r\n\tif (!flag)\r\n\t{\r\n\t\tflag = slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex);\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tif (flag2 && ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1))\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.Player(\"SetActiveBeltSlot\", player), slot.position, slot.uid);\r\n\t\t}\r\n\t\tClientRPC(RpcTarget.Player(\"PlayGrabSound\", player), slot.info.itemid);\r\n\t}\r\n\telse if (!slot.MoveToContainer(player.inventory.containerMain))\r\n\t{\r\n\t\tslot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\r\n\t}\r\n\tif (sendUpdate)\r\n\t{\r\n\t\tItemManager.DoRemoves();\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "GivePlayerWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRackedWeaponUnload",
    "fullName": "OnRackedWeaponUnload",
    "category": "Item",
    "parameters": [
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UnloadWeapon(BasePlayer player, int mountSlotIndex)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\r\n\tif (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity heldEntity = slot.GetHeldEntity();\r\n\tif (!(heldEntity == null))\r\n\t{\r\n\t\tBaseProjectile component = heldEntity.GetComponent<BaseProjectile>();\r\n\t\tif (!(component == null))\r\n\t\t{\r\n\t\t\tItemDefinition ammoType = component.primaryMagazine.ammoType;\r\n\t\t\tcomponent.UnloadAmmo(slot, player);\r\n\t\t\tSetSlotAmmoDetails(weaponAtIndex, slot);\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t\tClientRPC(RpcTarget.Player(\"PlayAmmoSound\", player), ammoType.itemid, 1);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "UnloadWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRackedWeaponUnloaded",
    "fullName": "OnRackedWeaponUnloaded",
    "category": "Item",
    "parameters": [
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UnloadWeapon(BasePlayer player, int mountSlotIndex)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\r\n\tif (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity heldEntity = slot.GetHeldEntity();\r\n\tif (!(heldEntity == null))\r\n\t{\r\n\t\tBaseProjectile component = heldEntity.GetComponent<BaseProjectile>();\r\n\t\tif (!(component == null))\r\n\t\t{\r\n\t\t\tItemDefinition ammoType = component.primaryMagazine.ammoType;\r\n\t\t\tcomponent.UnloadAmmo(slot, player);\r\n\t\t\tSetSlotAmmoDetails(weaponAtIndex, slot);\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t\tClientRPC(RpcTarget.Player(\"PlayAmmoSound\", player), ammoType.itemid, 1);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "UnloadWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRackedWeaponLoad",
    "fullName": "OnRackedWeaponLoad",
    "category": "Item",
    "parameters": [
      {
        "name": "local4",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local7",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void LoadWeaponAmmo(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint gridIndex = msg.read.Int32();\r\n\tint num = msg.read.Int32();\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);\r\n\tif (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity heldEntity = slot.GetHeldEntity();\r\n\tif (heldEntity == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseProjectile component = heldEntity.GetComponent<BaseProjectile>();\r\n\tif (component == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (itemDefinition == SnowballGun.SnowballInventoryItem)\r\n\t{\r\n\t\titemDefinition = SnowballGun.SnowballAmmoItem;\r\n\t\tif (!(itemDefinition != null))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tnum = itemDefinition.itemid;\r\n\t}\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemModProjectile component2 = itemDefinition.GetComponent<ItemModProjectile>();\r\n\tif (!(component2 == null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))\r\n\t{\r\n\t\tif (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)\r\n\t\t{\r\n\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));\r\n\t\t\tcomponent.SetAmmoCount(0);\r\n\t\t}\r\n\t\tcomponent.primaryMagazine.ammoType = itemDefinition;\r\n\t\tcomponent.TryReloadMagazine(player.inventory);\r\n\t\tSetSlotAmmoDetails(weaponAtIndex, slot);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tClientRPC(RpcTarget.Player(\"PlayAmmoSound\", player), itemDefinition.itemid, 0);\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "LoadWeaponAmmo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRackedWeaponLoaded",
    "fullName": "OnRackedWeaponLoaded",
    "category": "Item",
    "parameters": [
      {
        "name": "local4",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local7",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weaponRack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void LoadWeaponAmmo(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint gridIndex = msg.read.Int32();\r\n\tint num = msg.read.Int32();\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);\r\n\tif (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity heldEntity = slot.GetHeldEntity();\r\n\tif (heldEntity == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseProjectile component = heldEntity.GetComponent<BaseProjectile>();\r\n\tif (component == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (itemDefinition == SnowballGun.SnowballInventoryItem)\r\n\t{\r\n\t\titemDefinition = SnowballGun.SnowballAmmoItem;\r\n\t\tif (!(itemDefinition != null))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tnum = itemDefinition.itemid;\r\n\t}\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemModProjectile component2 = itemDefinition.GetComponent<ItemModProjectile>();\r\n\tif (!(component2 == null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))\r\n\t{\r\n\t\tif (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)\r\n\t\t{\r\n\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));\r\n\t\t\tcomponent.SetAmmoCount(0);\r\n\t\t}\r\n\t\tcomponent.primaryMagazine.ammoType = itemDefinition;\r\n\t\tcomponent.TryReloadMagazine(player.inventory);\r\n\t\tSetSlotAmmoDetails(weaponAtIndex, slot);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tClientRPC(RpcTarget.Player(\"PlayAmmoSound\", player), itemDefinition.itemid, 0);\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "LoadWeaponAmmo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanLockerAcceptItem",
    "fullName": "CanLockerAcceptItem",
    "category": "Item",
    "parameters": [
      {
        "name": "locker",
        "type": "Locker, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool ItemFilter(Item item, int targetSlot)\r\n{\r\n\tif (!base.ItemFilter(item, targetSlot))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tbool num = item.IsBackpack();\r\n\tbool flag = IsBackpackSlot(targetSlot);\r\n\tif (num != flag)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (isTransferringIndustrialItem && GetRowType(targetSlot) == Locker.RowType.Belt && item.info.category == ItemCategory.Attire)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (item.info.category == ItemCategory.Attire)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn GetRowType(targetSlot) == Locker.RowType.Belt;\r\n}\r\n",
    "targetName": "Locker",
    "methodName": "ItemFilter",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnItemFilter",
    "fullName": "OnItemFilter",
    "category": "Item",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "storageContainer",
        "type": "StorageContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "targetSlot",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool ItemFilter(Item item, int targetSlot)\r\n{\r\n\tif (onlyAcceptCategory == ItemCategory.All)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn item.info.category == onlyAcceptCategory;\r\n}\r\n",
    "targetName": "StorageContainer",
    "methodName": "ItemFilter",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnMissionFailed",
    "fullName": "OnMissionFailed",
    "category": "Mission",
    "parameters": [
      {
        "name": "baseMission",
        "type": "BaseMission, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void MissionFailed(BaseMission.MissionInstance instance, BasePlayer assignee, BaseMission.MissionFailReason failReason)\r\n{\r\n\tif (!instance.GetMission().completeSilently)\r\n\t{\r\n\t\tassignee.ChatMessage(\"You have failed the mission : \" + missionName.english);\r\n\t}\r\n\tDoMissionEffect(failedEffect.resourcePath, assignee);\r\n\tFacepunch.Rust.Analytics.Server.MissionFailed(this, failReason);\r\n\tFacepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, failReason);\r\n\tinstance.status = BaseMission.MissionStatus.Failed;\r\n\tMissionEnded(instance, assignee);\r\n}\r\n",
    "targetName": "BaseMission",
    "methodName": "MissionFailed",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMissionSucceeded",
    "fullName": "OnMissionSucceeded",
    "category": "Mission",
    "parameters": [
      {
        "name": "baseMission",
        "type": "BaseMission, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void MissionSuccess(BaseMission.MissionInstance instance, BasePlayer assignee)\r\n{\r\n\tinstance.status = BaseMission.MissionStatus.Accomplished;\r\n\tMissionEnded(instance, assignee);\r\n\tMissionComplete(instance, assignee);\r\n}\r\n",
    "targetName": "BaseMission",
    "methodName": "MissionSuccess",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMissionStart",
    "fullName": "OnMissionStart",
    "category": "Mission",
    "parameters": [
      {
        "name": "baseMission",
        "type": "BaseMission, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void MissionStart(BaseMission.MissionInstance instance, BasePlayer assignee)\r\n{\r\n\tfor (int i = 0; i < objectives.Length; i++)\r\n\t{\r\n\t\tobjectives[i].Get().MissionStarted(i, instance, assignee);\r\n\t}\r\n\tif (acceptEffect.isValid)\r\n\t{\r\n\t\tDoMissionEffect(acceptEffect.resourcePath, assignee);\r\n\t}\r\n\tBaseMission.MissionEntityEntry[] array = missionEntities;\r\n\tforeach (BaseMission.MissionEntityEntry missionEntityEntry in array)\r\n\t{\r\n\t\tif (missionEntityEntry.spawnOnMissionStart)\r\n\t\t{\r\n\t\t\tinstance.GetMissionEntity(missionEntityEntry.identifier, assignee);\r\n\t\t}\r\n\t}\r\n\tif (AllowedTutorialItems != 0)\r\n\t{\r\n\t\tassignee.SetTutorialAllowance(AllowedTutorialItems);\r\n\t}\r\n}\r\n",
    "targetName": "BaseMission",
    "methodName": "MissionStart",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanAssignMission",
    "fullName": "CanAssignMission",
    "category": "Mission",
    "parameters": [
      {
        "name": "assignee",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "mission",
        "type": "BaseMission, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "provider",
        "type": "IMissionProvider, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)\r\n{\r\n\tif (!missionsenabled)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!mission.IsEligableForMission(assignee, provider))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tint num = Facepunch.Extend.List.FindIndexWith(assignee.missions, (BaseMission.MissionInstance i) => i.missionID, mission.id);\r\n\tBaseMission.MissionInstance missionInstance;\r\n\tint activeMission;\r\n\tif (num >= 0)\r\n\t{\r\n\t\tmissionInstance = assignee.missions[num];\r\n\t\tactiveMission = num;\r\n\t\tmissionInstance.Reset();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmissionInstance = Facepunch.Pool.Get<BaseMission.MissionInstance>();\r\n\t\tactiveMission = assignee.missions.Count;\r\n\t\tassignee.missions.Add(missionInstance);\r\n\t}\r\n\tmissionInstance.missionID = mission.id;\r\n\tmissionInstance.startTime = UnityEngine.Time.time;\r\n\tmissionInstance.providerID = provider.ProviderID();\r\n\tmissionInstance.status = BaseMission.MissionStatus.Active;\r\n\tmissionInstance.objectiveStatuses = new BaseMission.MissionInstance.ObjectiveStatus[mission.objectives.Length];\r\n\tfor (int j = 0; j < mission.objectives.Length; j++)\r\n\t{\r\n\t\tmissionInstance.objectiveStatuses[j] = new BaseMission.MissionInstance.ObjectiveStatus();\r\n\t}\r\n\tmission.MissionStart(missionInstance, assignee);\r\n\tassignee.SetActiveMission(activeMission);\r\n\tassignee.MissionDirty();\r\n\treturn true;\r\n}\r\n",
    "targetName": "BaseMission",
    "methodName": "AssignMission",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnMissionAssigned",
    "fullName": "OnMissionAssigned",
    "category": "Mission",
    "parameters": [
      {
        "name": "mission",
        "type": "BaseMission, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "provider",
        "type": "IMissionProvider, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "assignee",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)\r\n{\r\n\tif (!missionsenabled)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!mission.IsEligableForMission(assignee, provider))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tint num = Facepunch.Extend.List.FindIndexWith(assignee.missions, (BaseMission.MissionInstance i) => i.missionID, mission.id);\r\n\tBaseMission.MissionInstance missionInstance;\r\n\tint activeMission;\r\n\tif (num >= 0)\r\n\t{\r\n\t\tmissionInstance = assignee.missions[num];\r\n\t\tactiveMission = num;\r\n\t\tmissionInstance.Reset();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmissionInstance = Facepunch.Pool.Get<BaseMission.MissionInstance>();\r\n\t\tactiveMission = assignee.missions.Count;\r\n\t\tassignee.missions.Add(missionInstance);\r\n\t}\r\n\tmissionInstance.missionID = mission.id;\r\n\tmissionInstance.startTime = UnityEngine.Time.time;\r\n\tmissionInstance.providerID = provider.ProviderID();\r\n\tmissionInstance.status = BaseMission.MissionStatus.Active;\r\n\tmissionInstance.objectiveStatuses = new BaseMission.MissionInstance.ObjectiveStatus[mission.objectives.Length];\r\n\tfor (int j = 0; j < mission.objectives.Length; j++)\r\n\t{\r\n\t\tmissionInstance.objectiveStatuses[j] = new BaseMission.MissionInstance.ObjectiveStatus();\r\n\t}\r\n\tmission.MissionStart(missionInstance, assignee);\r\n\tassignee.SetActiveMission(activeMission);\r\n\tassignee.MissionDirty();\r\n\treturn true;\r\n}\r\n",
    "targetName": "BaseMission",
    "methodName": "AssignMission",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMissionStarted",
    "fullName": "OnMissionStarted",
    "category": "Mission",
    "parameters": [
      {
        "name": "baseMission",
        "type": "BaseMission, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void MissionStart(BaseMission.MissionInstance instance, BasePlayer assignee)\r\n{\r\n\tfor (int i = 0; i < objectives.Length; i++)\r\n\t{\r\n\t\tobjectives[i].Get().MissionStarted(i, instance, assignee);\r\n\t}\r\n\tif (acceptEffect.isValid)\r\n\t{\r\n\t\tDoMissionEffect(acceptEffect.resourcePath, assignee);\r\n\t}\r\n\tBaseMission.MissionEntityEntry[] array = missionEntities;\r\n\tforeach (BaseMission.MissionEntityEntry missionEntityEntry in array)\r\n\t{\r\n\t\tif (missionEntityEntry.spawnOnMissionStart)\r\n\t\t{\r\n\t\t\tinstance.GetMissionEntity(missionEntityEntry.identifier, assignee);\r\n\t\t}\r\n\t}\r\n\tif (AllowedTutorialItems != 0)\r\n\t{\r\n\t\tassignee.SetTutorialAllowance(AllowedTutorialItems);\r\n\t}\r\n}\r\n",
    "targetName": "BaseMission",
    "methodName": "MissionStart",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanNetworkTo",
    "fullName": "CanNetworkTo",
    "category": "Network",
    "parameters": [
      {
        "name": "baseNetworkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool ShouldNetworkTo(BasePlayer player)\r\n{\r\n\tif (net.group == null)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn player.net.subscriber.IsSubscribed(net.group);\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "ShouldNetworkTo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnNetworkGroupEntered",
    "fullName": "OnNetworkGroupEntered",
    "category": "Network",
    "parameters": [
      {
        "name": "baseNetworkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnNetworkGroupEnter(Network.Visibility.Group group)\r\n{\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "OnNetworkGroupEnter",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnNetworkGroupLeft",
    "fullName": "OnNetworkGroupLeft",
    "category": "Network",
    "parameters": [
      {
        "name": "baseNetworkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnNetworkGroupLeave(Network.Visibility.Group group)\r\n{\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "OnNetworkGroupLeave",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnNetworkSubscriptionsGather",
    "fullName": "OnNetworkSubscriptionsGather",
    "category": "Network",
    "parameters": [
      {
        "name": "networkVisibilityGrid",
        "type": "NetworkVisibilityGrid, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GetVisibleFrom(Network.Visibility.Group group, System.Collections.Generic.List<Network.Visibility.Group> groups, int radius)\r\n{\r\n\tgroups.Add(Network.Net.sv.visibility.Get(0u));\r\n\tif (group.restricted)\r\n\t{\r\n\t\tgroups.Add(group);\r\n\t\treturn;\r\n\t}\r\n\tint iD = (int)group.ID;\r\n\tif (iD < startID)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tvar (num, num2, groupLayer2) = DeconstructGroupId(iD);\r\n\tAddLayers(num, num2, groupLayer2);\r\n\tfor (int i = 1; i <= radius; i++)\r\n\t{\r\n\t\tAddLayers(num - i, num2, groupLayer2);\r\n\t\tAddLayers(num + i, num2, groupLayer2);\r\n\t\tAddLayers(num, num2 - i, groupLayer2);\r\n\t\tAddLayers(num, num2 + i, groupLayer2);\r\n\t\tfor (int j = 1; j < i; j++)\r\n\t\t{\r\n\t\t\tAddLayers(num - i, num2 - j, groupLayer2);\r\n\t\t\tAddLayers(num - i, num2 + j, groupLayer2);\r\n\t\t\tAddLayers(num + i, num2 - j, groupLayer2);\r\n\t\t\tAddLayers(num + i, num2 + j, groupLayer2);\r\n\t\t\tAddLayers(num - j, num2 - i, groupLayer2);\r\n\t\t\tAddLayers(num + j, num2 - i, groupLayer2);\r\n\t\t\tAddLayers(num - j, num2 + i, groupLayer2);\r\n\t\t\tAddLayers(num + j, num2 + i, groupLayer2);\r\n\t\t}\r\n\t\tAddLayers(num - i, num2 - i, groupLayer2);\r\n\t\tAddLayers(num - i, num2 + i, groupLayer2);\r\n\t\tAddLayers(num + i, num2 - i, groupLayer2);\r\n\t\tAddLayers(num + i, num2 + i, groupLayer2);\r\n\t}\r\n\tvoid Add(int groupX, int groupY, int groupLayer)\r\n\t{\r\n\t\tgroups.Add(Network.Net.sv.visibility.Get(CoordToID(groupX, groupY, groupLayer)));\r\n\t}\r\n\tvoid AddLayers(int groupX, int groupY, int groupLayer)\r\n\t{\r\n\t\tAdd(groupX, groupY, groupLayer);\r\n\t\tif (groupLayer == 0)\r\n\t\t{\r\n\t\t\tAdd(groupX, groupY, 1);\r\n\t\t}\r\n\t\tif (groupLayer == 1)\r\n\t\t{\r\n\t\t\tAdd(groupX, groupY, 2);\r\n\t\t\tAdd(groupX, groupY, 0);\r\n\t\t}\r\n\t\tif (groupLayer == 2)\r\n\t\t{\r\n\t\t\tAdd(groupX, groupY, 1);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "NetworkVisibilityGrid",
    "methodName": "GetVisibleFrom",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSignalBroadcast",
    "fullName": "OnSignalBroadcast",
    "category": "Network",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SignalBroadcast(BaseEntity.Signal signal, string arg, Network.Connection sourceConnection = null)\r\n{\r\n\tif (net != null && net.group != null)\r\n\t{\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"SignalFromServerEx\", this, Network.SendMethod.Unreliable, Network.Priority.Immediate), (int)signal, arg, sourceConnection?.userid ?? 0);\r\n\t}\r\n}\r\n",
    "targetName": "BaseEntity",
    "methodName": "SignalBroadcast",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNetworkSubscriptionsUpdate",
    "fullName": "OnNetworkSubscriptionsUpdate",
    "category": "Network",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool UpdateSubscriptions(int removeLimit, int addLimit)\r\n{\r\n\tif (!updateSubscriptions)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (subscriber == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tusing (TimeWarning.New(\"UpdateSubscriptions\"))\r\n\t{\r\n\t\tupdateSubscriptions = false;\r\n\t\tSystem.Collections.Generic.List<Network.Visibility.Group> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Network.Visibility.Group>>();\r\n\t\tSystem.Collections.Generic.List<Network.Visibility.Group> obj2 = Facepunch.Pool.Get<System.Collections.Generic.List<Network.Visibility.Group>>();\r\n\t\tSystem.Collections.Generic.List<Network.Visibility.Group> obj3 = Facepunch.Pool.Get<System.Collections.Generic.List<Network.Visibility.Group>>();\r\n\t\tsv.visibility.GetVisibleFromFar(this.group, obj3);\r\n\t\tAddVisibleFromNear(secondaryGroup, obj3);\r\n\t\tFacepunch.Extend.List.Compare(subscriber.subscribed, obj3, obj, obj2, null);\r\n\t\tfor (int i = 0; i < obj2.Count; i++)\r\n\t\t{\r\n\t\t\tNetwork.Visibility.Group group = obj2[i];\r\n\t\t\tif (removeLimit > 0)\r\n\t\t\t{\r\n\t\t\t\tsubscriber.Unsubscribe(group);\r\n\t\t\t\tif (handler != null)\r\n\t\t\t\t{\r\n\t\t\t\t\thandler.OnNetworkGroupLeave(group);\r\n\t\t\t\t}\r\n\t\t\t\tremoveLimit -= group.networkables.Count;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tupdateSubscriptions = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int j = 0; j < obj.Count; j++)\r\n\t\t{\r\n\t\t\tNetwork.Visibility.Group group2 = obj[j];\r\n\t\t\tif (addLimit > 0)\r\n\t\t\t{\r\n\t\t\t\tsubscriber.Subscribe(group2);\r\n\t\t\t\tif (handler != null)\r\n\t\t\t\t{\r\n\t\t\t\t\thandler.OnNetworkGroupEnter(group2);\r\n\t\t\t\t}\r\n\t\t\t\taddLimit -= group2.networkables.Count;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tupdateSubscriptions = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj3);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "Network.Networkable",
    "methodName": "UpdateSubscriptions",
    "assemblyName": "Facepunch.Network",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnNetworkSubscriptionsUpdate",
    "fullName": "OnNetworkSubscriptionsUpdate [2]",
    "category": "Network",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool UpdateHighPrioritySubscriptions()\r\n{\r\n\tif (subscriber == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tusing (TimeWarning.New(\"UpdateHighPrioritySubscriptions\"))\r\n\t{\r\n\t\tSystem.Collections.Generic.List<Network.Visibility.Group> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Network.Visibility.Group>>();\r\n\t\tSystem.Collections.Generic.List<Network.Visibility.Group> obj2 = Facepunch.Pool.Get<System.Collections.Generic.List<Network.Visibility.Group>>();\r\n\t\tsv.visibility.GetVisibleFromNear(this.group, obj2);\r\n\t\tAddVisibleFromNear(secondaryGroup, obj2);\r\n\t\tFacepunch.Extend.List.Compare(subscriber.subscribed, obj2, obj, null, null);\r\n\t\tfor (int i = 0; i < obj.Count; i++)\r\n\t\t{\r\n\t\t\tNetwork.Visibility.Group group = obj[i];\r\n\t\t\tsubscriber.Subscribe(group);\r\n\t\t\tif (handler != null)\r\n\t\t\t{\r\n\t\t\t\thandler.OnNetworkGroupEnter(group);\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "Network.Networkable",
    "methodName": "UpdateHighPrioritySubscriptions",
    "assemblyName": "Facepunch.Network",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanNpcEat",
    "fullName": "CanNpcEat [BaseNpc]",
    "category": "NPC",
    "parameters": [
      {
        "name": "baseNpc",
        "type": "BaseNpc, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool WantsToEat(BaseEntity best)\r\n{\r\n\tif (!best.HasTrait(BaseEntity.TraitFlag.Food))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (best.HasTrait(BaseEntity.TraitFlag.Alive))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "BaseNpc",
    "methodName": "WantsToEat",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnNpcAttack",
    "fullName": "OnNpcAttack [BaseNpc]",
    "category": "NPC",
    "parameters": [
      {
        "name": "baseNpc",
        "type": "BaseNpc, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BaseNpc, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void StartAttack()\r\n{\r\n\tif ((bool)AttackTarget && AttackReady() && !((AttackTarget.ServerPosition - ServerPosition).magnitude > AttackRange))\r\n\t{\r\n\t\tnextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;\r\n\t\tBaseCombatEntity combatTarget = CombatTarget;\r\n\t\tif ((bool)combatTarget)\r\n\t\t{\r\n\t\t\tcombatTarget.Hurt(AttackDamage, AttackDamageType, this);\r\n\t\t\tStamina.Use(AttackCost);\r\n\t\t\tBusyTimer.Activate(0.5f);\r\n\t\t\tSignalBroadcast(BaseEntity.Signal.Attack);\r\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\"Attack\"), AttackTarget.ServerPosition);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseNpc",
    "methodName": "StartAttack",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "IOnNpcTarget",
    "fullName": "IOnNpcTarget [BaseNpc]",
    "category": "NPC",
    "parameters": [
      {
        "name": "baseNpc",
        "type": "BaseNpc, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public float GetWantsToAttack(BaseEntity target)\r\n{\r\n\treturn WantsToAttack(target);\r\n}\r\n",
    "targetName": "BaseNpc",
    "methodName": "GetWantsToAttack",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Single"
  },
  {
    "name": "OnNpcGiveSoldItem",
    "fullName": "OnNpcGiveSoldItem",
    "category": "NPC",
    "parameters": [
      {
        "name": "nPCVendingMachine",
        "type": "NPCVendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "soldItem",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "buyer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void GiveSoldItem(Item soldItem, BasePlayer buyer)\r\n{\r\n\tsoldItem.SetItemOwnership(buyer, ItemOwnershipPhrases.VendorSale);\r\n\tbase.GiveSoldItem(soldItem, buyer);\r\n}\r\n",
    "targetName": "NPCVendingMachine",
    "methodName": "GiveSoldItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNpcRadioChatter",
    "fullName": "OnNpcRadioChatter [ScientistNPC]",
    "category": "NPC",
    "parameters": [
      {
        "name": "scientistNPC",
        "type": "ScientistNPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void PlayRadioChatter()\r\n{\r\n\tif (RadioChatterEffects.Length != 0)\r\n\t{\r\n\t\tif (base.IsDestroyed || base.transform == null)\r\n\t\t{\r\n\t\t\tCancelInvoke(PlayRadioChatter);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tEffect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get(\"head\"), UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\tQueueRadioChatter();\r\n\t}\r\n}\r\n",
    "targetName": "ScientistNPC",
    "methodName": "PlayRadioChatter",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNpcAlert",
    "fullName": "OnNpcAlert [ScientistNPC]",
    "category": "NPC",
    "parameters": [
      {
        "name": "scientistNPC",
        "type": "ScientistNPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Alert()\r\n{\r\n\tlastAlertedTime = UnityEngine.Time.time;\r\n\tSetChatterType(ScientistNPC.RadioChatterType.Alert);\r\n}\r\n",
    "targetName": "ScientistNPC",
    "methodName": "Alert",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNpcEquipWeapon",
    "fullName": "OnNpcEquipWeapon [ScientistNPC]",
    "category": "NPC",
    "parameters": [
      {
        "name": "scientistNPC",
        "type": "ScientistNPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void EquipWeapon(bool skipDeployDelay = false)\r\n{\r\n\tbase.EquipWeapon(skipDeployDelay);\r\n\tHeldEntity heldEntity = GetHeldEntity();\r\n\tif (!(heldEntity != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem item = heldEntity.GetItem();\r\n\tif (item == null || item.contents == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Random.Range(0, 3) == 0)\r\n\t{\r\n\t\tItem item2 = ItemManager.CreateByName(\"weapon.mod.flashlight\", 1, 0uL);\r\n\t\tif (!item2.MoveToContainer(item.contents))\r\n\t\t{\r\n\t\t\titem2.Remove();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlightsOn = false;\r\n\t\tInvokeRandomized(base.LightCheck, 0f, 30f, 5f);\r\n\t\tLightCheck();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tItem item3 = ItemManager.CreateByName(\"weapon.mod.lasersight\", 1, 0uL);\r\n\t\tif (!item3.MoveToContainer(item.contents))\r\n\t\t{\r\n\t\t\titem3.Remove();\r\n\t\t}\r\n\t\tLightToggle();\r\n\t\tlightsOn = true;\r\n\t}\r\n}\r\n",
    "targetName": "ScientistNPC",
    "methodName": "EquipWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNpcEquipWeapon",
    "fullName": "OnNpcEquipWeapon [NPCPlayer]",
    "category": "NPC",
    "parameters": [
      {
        "name": "nPCPlayer",
        "type": "NPCPlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void EquipWeapon(bool skipDeployDelay = false)\r\n{\r\n\tif (base.inventory == null || base.inventory.containerBelt == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.containerBelt.GetSlot(0);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tUpdateActiveItem(base.inventory.containerBelt.GetSlot(0).uid);\r\n\tBaseEntity heldEntity = slot.GetHeldEntity();\r\n\tif (!(heldEntity != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tAttackEntity component = heldEntity.GetComponent<AttackEntity>();\r\n\tif (component != null)\r\n\t{\r\n\t\tif (skipDeployDelay)\r\n\t\t{\r\n\t\t\tcomponent.ResetAttackCooldown();\r\n\t\t}\r\n\t\tcomponent.TopUpAmmo();\r\n\t}\r\n}\r\n",
    "targetName": "NPCPlayer",
    "methodName": "EquipWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCorpsePopulate",
    "fullName": "OnCorpsePopulate",
    "category": "NPC",
    "parameters": [
      {
        "name": "nPCPlayer",
        "type": "NPCPlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "NPCPlayerCorpse, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override BaseCorpse CreateCorpse(BasePlayer.PlayerFlags flagsOnDeath, UnityEngine.Vector3 posOnDeath, UnityEngine.Quaternion rotOnDeath, System.Collections.Generic.List<TriggerBase> triggersOnDeath, bool forceServerSide = false)\r\n{\r\n\tusing (TimeWarning.New(\"Create corpse\"))\r\n\t{\r\n\t\tNPCPlayerCorpse nPCPlayerCorpse = DropCorpse(CorpsePath, flagsOnDeath, modelState) as NPCPlayerCorpse;\r\n\t\tif ((bool)nPCPlayerCorpse)\r\n\t\t{\r\n\t\t\tif (NavAgent != null)\r\n\t\t\t{\r\n\t\t\t\tnPCPlayerCorpse.transform.position += UnityEngine.Vector3.down * NavAgent.baseOffset;\r\n\t\t\t}\r\n\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\r\n\t\t\tnPCPlayerCorpse.SetFlag(BaseEntity.Flags.Reserved5, HasPlayerFlag(BasePlayer.PlayerFlags.DisplaySash));\r\n\t\t\tnPCPlayerCorpse.SetFlag(BaseEntity.Flags.Reserved2, b: true);\r\n\t\t\tif (CopyInventoryToCorpse)\r\n\t\t\t{\r\n\t\t\t\tnPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain, base.inventory.containerWear, base.inventory.containerBelt);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tnPCPlayerCorpse.CreateEmptyContainer(base.inventory.containerMain.capacity);\r\n\t\t\t}\r\n\t\t\tnPCPlayerCorpse.playerName = OverrideCorpseName;\r\n\t\t\tnPCPlayerCorpse.playerSteamID = userID;\r\n\t\t\tnPCPlayerCorpse.Spawn();\r\n\t\t\tif (ShouldCorpseTakeChildren)\r\n\t\t\t{\r\n\t\t\t\tnPCPlayerCorpse.TakeChildren(this);\r\n\t\t\t}\r\n\t\t\tfor (int i = 0; i < nPCPlayerCorpse.containers.Length; i++)\r\n\t\t\t{\r\n\t\t\t\tItemContainer itemContainer = nPCPlayerCorpse.containers[i];\r\n\t\t\t\tif (!KeepCorpseClothingIntact || i != 1)\r\n\t\t\t\t{\r\n\t\t\t\t\titemContainer.Clear();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tApplyLoot(nPCPlayerCorpse);\r\n\t\t}\r\n\t\treturn nPCPlayerCorpse;\r\n\t}\r\n}\r\n",
    "targetName": "NPCPlayer",
    "methodName": "CreateCorpse",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "BaseCorpse"
  },
  {
    "name": "OnNpcDuck",
    "fullName": "OnNpcDuck [HumanNPC]",
    "category": "NPC",
    "parameters": [
      {
        "name": "humanNPC",
        "type": "HumanNPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetDucked(bool flag)\r\n{\r\n\tmodelState.ducked = flag;\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "HumanNPC",
    "methodName": "SetDucked",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNpcTarget",
    "fullName": "OnNpcTarget [HumanNPC]",
    "category": "NPC",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public BaseEntity GetBestTarget()\r\n{\r\n\tBaseEntity result = null;\r\n\tfloat num = -1f;\r\n\tforeach (BaseEntity player in Brain.Senses.Players)\r\n\t{\r\n\t\tif (!(player == null) && !(player.Health() <= 0f))\r\n\t\t{\r\n\t\t\tfloat value = UnityEngine.Vector3.Distance(player.transform.position, base.transform.position);\r\n\t\t\tfloat num2 = 1f - UnityEngine.Mathf.InverseLerp(1f, Brain.SenseRange, value);\r\n\t\t\tfloat value2 = UnityEngine.Vector3.Dot((player.transform.position - base.eyes.position).normalized, base.eyes.BodyForward());\r\n\t\t\tnum2 += UnityEngine.Mathf.InverseLerp(Brain.VisionCone, 1f, value2) / 2f;\r\n\t\t\tnum2 += (Brain.Senses.Memory.IsLOS(player) ? 2f : 0f);\r\n\t\t\tif (num2 > num)\r\n\t\t\t{\r\n\t\t\t\tresult = player;\r\n\t\t\t\tnum = num2;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n",
    "targetName": "HumanNPC",
    "methodName": "GetBestTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNpcConversationRespond",
    "fullName": "OnNpcConversationRespond",
    "category": "NPC",
    "parameters": [
      {
        "name": "nPCTalking",
        "type": "NPCTalking, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "ConversationData, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "ConversationData+ResponseNode, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void Server_ResponsePressed(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tint num = msg.read.Int32();\r\n\tint num2 = msg.read.Int32();\r\n\tConversationData conversationFor = GetConversationFor(player);\r\n\tif (conversationFor == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (responseNode.conditions.Length != 0)\r\n\t{\r\n\t\tUpdateFlags();\r\n\t}\r\n\tbool flag = responseNode.PassesConditions(player, this);\r\n\tif (flag)\r\n\t{\r\n\t\tstring actionString = responseNode.GetActionString();\r\n\t\tif (!string.IsNullOrEmpty(actionString))\r\n\t\t{\r\n\t\t\tOnConversationAction(player, actionString);\r\n\t\t}\r\n\t}\r\n\tint speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));\r\n\tif (speechNodeIndex == -1)\r\n\t{\r\n\t\tForceEndConversation(player);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tForceSpeechNode(player, speechNodeIndex);\r\n\t}\r\n}\r\n",
    "targetName": "NPCTalking",
    "methodName": "Server_ResponsePressed",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNpcConversationResponded",
    "fullName": "OnNpcConversationResponded",
    "category": "NPC",
    "parameters": [
      {
        "name": "nPCTalking",
        "type": "NPCTalking, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "ConversationData, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "ConversationData+ResponseNode, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void Server_ResponsePressed(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tint num = msg.read.Int32();\r\n\tint num2 = msg.read.Int32();\r\n\tConversationData conversationFor = GetConversationFor(player);\r\n\tif (conversationFor == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (responseNode.conditions.Length != 0)\r\n\t{\r\n\t\tUpdateFlags();\r\n\t}\r\n\tbool flag = responseNode.PassesConditions(player, this);\r\n\tif (flag)\r\n\t{\r\n\t\tstring actionString = responseNode.GetActionString();\r\n\t\tif (!string.IsNullOrEmpty(actionString))\r\n\t\t{\r\n\t\t\tOnConversationAction(player, actionString);\r\n\t\t}\r\n\t}\r\n\tint speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));\r\n\tif (speechNodeIndex == -1)\r\n\t{\r\n\t\tForceEndConversation(player);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tForceSpeechNode(player, speechNodeIndex);\r\n\t}\r\n}\r\n",
    "targetName": "NPCTalking",
    "methodName": "Server_ResponsePressed",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnNpcConversationEnded",
    "fullName": "OnNpcConversationEnded",
    "category": "NPC",
    "parameters": [
      {
        "name": "nPCTalking",
        "type": "NPCTalking, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnConversationEnded(BasePlayer player)\r\n{\r\n\tif (conversingPlayers.Contains(player))\r\n\t{\r\n\t\tconversingPlayers.Remove(player);\r\n\t}\r\n}\r\n",
    "targetName": "NPCTalking",
    "methodName": "OnConversationEnded",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnNpcConversationStart",
    "fullName": "OnNpcConversationStart",
    "category": "NPC",
    "parameters": [
      {
        "name": "nPCTalking",
        "type": "NPCTalking, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "ply",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ConversationData, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void Server_BeginTalking(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tServer_BeginTalking(player);\r\n}\r\n",
    "targetName": "NPCTalking",
    "methodName": "Server_BeginTalking",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNpcConversationResponded [patch]",
    "fullName": "OnNpcConversationResponded [patch]",
    "category": "NPC",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void Server_ResponsePressed(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tint num = msg.read.Int32();\r\n\tint num2 = msg.read.Int32();\r\n\tConversationData conversationFor = GetConversationFor(player);\r\n\tif (conversationFor == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (responseNode.conditions.Length != 0)\r\n\t{\r\n\t\tUpdateFlags();\r\n\t}\r\n\tbool flag = responseNode.PassesConditions(player, this);\r\n\tif (flag)\r\n\t{\r\n\t\tstring actionString = responseNode.GetActionString();\r\n\t\tif (!string.IsNullOrEmpty(actionString))\r\n\t\t{\r\n\t\t\tOnConversationAction(player, actionString);\r\n\t\t}\r\n\t}\r\n\tint speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));\r\n\tif (speechNodeIndex == -1)\r\n\t{\r\n\t\tForceEndConversation(player);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tForceSpeechNode(player, speechNodeIndex);\r\n\t}\r\n}\r\n",
    "targetName": "NPCTalking",
    "methodName": "Server_ResponsePressed",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNpcTargetSense",
    "fullName": "OnNpcTargetSense",
    "category": "NPC",
    "parameters": [
      {
        "name": "owner",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "ent",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "brainSenses",
        "type": "AIBrainSenses, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)\r\n{\r\n\tIAISenses iAISenses = owner as IAISenses;\r\n\tBasePlayer basePlayer = ent as BasePlayer;\r\n\tif (basePlayer != null && PlayerIgnoreList.Contains(basePlayer))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = false;\r\n\tif (iAISenses != null && iAISenses.IsThreat(ent))\r\n\t{\r\n\t\tflag = true;\r\n\t\tif (brainSenses != null)\r\n\t\t{\r\n\t\t\tbrainSenses.LastThreatTimestamp = UnityEngine.Time.realtimeSinceStartup;\r\n\t\t}\r\n\t}\r\n\tfor (int i = 0; i < All.Count; i++)\r\n\t{\r\n\t\tif (All[i].Entity == ent)\r\n\t\t{\r\n\t\t\tRust.Ai.SimpleAIMemory.SeenInfo value = All[i];\r\n\t\t\tvalue.Position = ent.transform.position;\r\n\t\t\tvalue.Timestamp = UnityEngine.Mathf.Max(UnityEngine.Time.realtimeSinceStartup, value.Timestamp);\r\n\t\t\tAll[i] = value;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (basePlayer != null)\r\n\t{\r\n\t\tif (ConVar.AI.ignoreplayers && !basePlayer.IsNpc)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tPlayers.Add(ent);\r\n\t}\r\n\tif (iAISenses != null)\r\n\t{\r\n\t\tif (iAISenses.IsTarget(ent))\r\n\t\t{\r\n\t\t\tTargets.Add(ent);\r\n\t\t}\r\n\t\tif (iAISenses.IsFriendly(ent))\r\n\t\t{\r\n\t\t\tFriendlies.Add(ent);\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tThreats.Add(ent);\r\n\t\t}\r\n\t}\r\n\tAll.Add(new Rust.Ai.SimpleAIMemory.SeenInfo\r\n\t{\r\n\t\tEntity = ent,\r\n\t\tPosition = ent.transform.position,\r\n\t\tTimestamp = UnityEngine.Time.realtimeSinceStartup\r\n\t});\r\n}\r\n",
    "targetName": "Rust.Ai.SimpleAIMemory",
    "methodName": "SetKnown",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnAIBrainStateSwitch",
    "fullName": "OnAIBrainStateSwitch",
    "category": "NPC",
    "parameters": [
      {
        "name": "baseAIBrain",
        "type": "BaseAIBrain, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BaseAIBrain, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "newState",
        "type": "BaseAIBrain+BasicAIState, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool SwitchToState(AIState newState, int stateContainerID = -1)\r\n{\r\n\tif (!HasState(newState))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tbool num = SwitchToState(states[newState], stateContainerID);\r\n\tif (num)\r\n\t{\r\n\t\tOnStateChanged();\r\n\t}\r\n\treturn num;\r\n}\r\n",
    "targetName": "BaseAIBrain",
    "methodName": "SwitchToState",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnAIBrainStateSwitched",
    "fullName": "OnAIBrainStateSwitched",
    "category": "NPC",
    "parameters": [
      {
        "name": "baseAIBrain",
        "type": "BaseAIBrain, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BaseAIBrain, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool SwitchToState(AIState newState, int stateContainerID = -1)\r\n{\r\n\tif (!HasState(newState))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tbool num = SwitchToState(states[newState], stateContainerID);\r\n\tif (num)\r\n\t{\r\n\t\tOnStateChanged();\r\n\t}\r\n\treturn num;\r\n}\r\n",
    "targetName": "BaseAIBrain",
    "methodName": "SwitchToState",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanDeployScientists",
    "fullName": "CanDeployScientists [BradleyAPC]",
    "category": "NPC",
    "parameters": [
      {
        "name": "bradleyAPC",
        "type": "BradleyAPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanDeployScientists(BaseEntity attacker, System.Collections.Generic.List<GameObjectRef> scientistPrefabs, System.Collections.Generic.List<UnityEngine.Vector3> spawnPositions)\r\n{\r\n\tint count = scientistPrefabs.Count;\r\n\tif (!inDeployedState && UnityEngine.Vector3.Distance(attacker.transform.position, base.transform.position) > DeployAttackDistanceMax)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tspawnPositions.Clear();\r\n\tbool flag = false;\r\n\tint num = 0;\r\n\tint num2 = 0;\r\n\tint layerMask = 8454144;\r\n\twhile (!flag)\r\n\t{\r\n\t\tif (UnityEngine.Physics.Raycast(ScientistSpawnPoints[num2 % ScientistSpawnPoints.Count].transform.position + UnityEngine.Vector3.up * 1f, UnityEngine.Vector3.down, out var hitInfo, 2f, layerMask) && UnityEngine.AI.NavMesh.SamplePosition(hitInfo.point + UnityEngine.Vector3.up * 0.3f, out var _, 6f, walkableAreaMask))\r\n\t\t{\r\n\t\t\tspawnPositions.Add(hitInfo.point + UnityEngine.Vector3.up * 0.1f);\r\n\t\t\tnum2++;\r\n\t\t\tif (num2 >= count)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnum++;\r\n\t\t\tif (num > count * 2)\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn !flag;\r\n}\r\n",
    "targetName": "BradleyAPC",
    "methodName": "CanDeployScientists",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnScientistInitialized",
    "fullName": "OnScientistInitialized [BradleyAPC]",
    "category": "NPC",
    "parameters": [
      {
        "name": "bradleyAPC",
        "type": "BradleyAPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "scientist",
        "type": "ScientistNPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "spawnPos",
        "type": "UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void InitScientist(ScientistNPC scientist, UnityEngine.Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing)\r\n{\r\n\tif (scientist == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tscientist.transform.position = spawnPos;\r\n\tif (!scientist.Brain.Navigator.PlaceOnNavMesh(0.2f))\r\n\t{\r\n\t\tactiveScientists.Remove(scientist);\r\n\t\tscientist.Kill();\r\n\t}\r\n\telse if (triggerPlayer != null)\r\n\t{\r\n\t\tscientist.Brain.Events.Memory.Entity.Set(triggerPlayer, 0);\r\n\t\tscientist.Brain.Senses.Memory.SetKnown(triggerPlayer, scientist, null);\r\n\t\tscientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 7);\r\n\t\tscientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 4);\r\n\t\tscientist.Brain.Events.Memory.Entity.Set(this, 7);\r\n\t\tAttackEntity attackEntity = scientist.GetAttackEntity();\r\n\t\tif (SetScientistChaseBasedOnWeapon && attackEntity != null && !attackEntity.CanUseAtLongRange)\r\n\t\t{\r\n\t\t\tstartChasing = true;\r\n\t\t}\r\n\t\tscientist.Brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint = startChasing;\r\n\t\tscientist.Brain.Navigator.CanUseRandomMovePointIfNonFound = !startChasing;\r\n\t\tif (startChasing)\r\n\t\t{\r\n\t\t\tscientist.Brain.SwitchToState(AIState.Chase, 6);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tscientist.Brain.SwitchToState(AIState.TakeCover, 4);\r\n\t\t}\r\n\t\tscientist.Brain.Think(0f);\r\n\t}\r\n}\r\n",
    "targetName": "BradleyAPC",
    "methodName": "InitScientist",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnScientistRecalled",
    "fullName": "OnScientistRecalled [BradleyAPC]",
    "category": "NPC",
    "parameters": [
      {
        "name": "bradleyAPC",
        "type": "BradleyAPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnScientistMounted(ScientistNPC scientist)\r\n{\r\n\tif (!(scientist == null))\r\n\t{\r\n\t\tif (scientistPrefabLookUp.TryGetValue(scientist.prefabID, out var value))\r\n\t\t{\r\n\t\t\tmountedScientistPrefabs.Add(value);\r\n\t\t}\r\n\t\tactiveScientists.Remove(scientist);\r\n\t\tnumberOfScientistsToSpawn++;\r\n\t}\r\n}\r\n",
    "targetName": "BradleyAPC",
    "methodName": "OnScientistMounted",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "IOnNpcTarget",
    "fullName": "IOnNpcTarget [SenseComponent]",
    "category": "NPC",
    "parameters": [
      {
        "name": "senseComponent",
        "type": "Rust.Ai.Gen2.SenseComponent, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanTarget(BaseEntity entity)\r\n{\r\n\tif (!entity.IsValid())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (entity.IsTransferProtected())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (entity.IsDestroyed)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!entity.IsNonNpcPlayer() && !entity.IsNpc)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (entity.IsNpcPlayer())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (entity is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (base.baseEntity.InSameNpcTeam(entity))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (entity is BasePlayer item)\r\n\t{\r\n\t\tif (ConVar.AI.ignoreplayers)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (Rust.Ai.SimpleAIMemory.PlayerIgnoreList.Contains(item))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "Rust.Ai.Gen2.SenseComponent",
    "methodName": "CanTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnNpcTarget",
    "fullName": "OnNpcTarget [AIBrainSenses]",
    "category": "NPC",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public BaseEntity GetNearest(System.Collections.Generic.List<BaseEntity> entities, float rangeFraction)\r\n{\r\n\tif (entities == null || entities.Count == 0)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tfloat num = float.PositiveInfinity;\r\n\tBaseEntity result = null;\r\n\tforeach (BaseEntity entity in entities)\r\n\t{\r\n\t\tif (!(entity == null) && !(entity.Health() <= 0f))\r\n\t\t{\r\n\t\t\tfloat num2 = UnityEngine.Vector3.Distance(entity.transform.position, owner.transform.position);\r\n\t\t\tif (num2 <= rangeFraction * maxRange && num2 < num)\r\n\t\t\t{\r\n\t\t\t\tresult = entity;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n",
    "targetName": "AIBrainSenses",
    "methodName": "GetNearest",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFrankensteinPetWake",
    "fullName": "OnFrankensteinPetWake [FrankensteinTable]",
    "category": "Pet",
    "parameters": [
      {
        "name": "frankensteinTable",
        "type": "FrankensteinTable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "owner",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void WakeFrankenstein(BasePlayer owner)\r\n{\r\n\tif (!(owner == null) && CanStartCreating(owner))\r\n\t{\r\n\t\twaking = true;\r\n\t\tbase.inventory.SetLocked(isLocked: true);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tStartCoroutine(DelayWakeFrankenstein(owner));\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"CL_WakeFrankenstein\"));\r\n\t}\r\n}\r\n",
    "targetName": "FrankensteinTable",
    "methodName": "WakeFrankenstein",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFrankensteinPetSleep",
    "fullName": "OnFrankensteinPetSleep [FrankensteinTable]",
    "category": "Pet",
    "parameters": [
      {
        "name": "local0",
        "type": "FrankensteinPet, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "frankensteinTable",
        "type": "FrankensteinTable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "owner",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SleepFrankenstein(BasePlayer owner)\r\n{\r\n\tif (IsInventoryEmpty() && !(owner == null) && !(owner.PetEntity == null))\r\n\t{\r\n\t\tFrankensteinPet frankensteinPet = owner.PetEntity as FrankensteinPet;\r\n\t\tif (!(frankensteinPet == null) && !(UnityEngine.Vector3.Distance(base.transform.position, frankensteinPet.transform.position) >= 5f))\r\n\t\t{\r\n\t\t\tReturnFrankensteinItems(frankensteinPet);\r\n\t\t\tItemManager.DoRemoves();\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t\tfrankensteinPet.Kill();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "FrankensteinTable",
    "methodName": "SleepFrankenstein",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPhoneAnswer",
    "fullName": "OnPhoneAnswer",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void AnswerPhone(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (IsInvoking(TimeOutDialing))\r\n\t{\r\n\t\tCancelInvoke(TimeOutDialing);\r\n\t}\r\n\tif (!(activeCallTo == null))\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tUpdateServerPlayer(player);\r\n\t\tBeginCall();\r\n\t\tactiveCallTo.BeginCall();\r\n\t}\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "AnswerPhone",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPhoneCallStart",
    "fullName": "OnPhoneCallStart",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self2",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void BeginCall()\r\n{\r\n\tif (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)\r\n\t{\r\n\t\t_ = currentPlayer != null;\r\n\t}\r\n\tSetPhoneStateWithPlayer(Telephone.CallState.InProcess);\r\n\tInvoke(TimeOutCall, TelephoneManager.MaxCallLength);\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "BeginCall",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPhoneCallStarted",
    "fullName": "OnPhoneCallStarted",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self2",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void BeginCall()\r\n{\r\n\tif (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)\r\n\t{\r\n\t\t_ = currentPlayer != null;\r\n\t}\r\n\tSetPhoneStateWithPlayer(Telephone.CallState.InProcess);\r\n\tInvoke(TimeOutCall, TelephoneManager.MaxCallLength);\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "BeginCall",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanReceiveCall",
    "fullName": "CanReceiveCall",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanReceiveCall()\r\n{\r\n\tif (RequirePower && !IsPowered())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (RequireParent && !base.baseEntity.HasParent())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "CanReceiveCall",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPhoneDial",
    "fullName": "OnPhoneDial",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CallPhone(int number)\r\n{\r\n\tif (number == PhoneNumber)\r\n\t{\r\n\t\tOnDialFailed(Telephone.DialFailReason.CallSelf);\r\n\t\treturn;\r\n\t}\r\n\tif (TelephoneManager.GetCurrentActiveCalls() + 1 > TelephoneManager.MaxConcurrentCalls)\r\n\t{\r\n\t\tOnDialFailed(Telephone.DialFailReason.NetworkBusy);\r\n\t\treturn;\r\n\t}\r\n\tPhoneController telephone = TelephoneManager.GetTelephone(number);\r\n\tif (telephone != null)\r\n\t{\r\n\t\tif (telephone.serverState == Telephone.CallState.Idle && telephone.CanReceiveCall())\r\n\t\t{\r\n\t\t\tSetPhoneState(Telephone.CallState.Dialing);\r\n\t\t\tlastDialedNumber = number;\r\n\t\t\tactiveCallTo = telephone;\r\n\t\t\tactiveCallTo.ReceiveCallFrom(this);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tOnDialFailed(Telephone.DialFailReason.Engaged);\r\n\t\t\ttelephone.OnIncomingCallWhileBusy();\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tOnDialFailed(Telephone.DialFailReason.WrongNumber);\r\n\t}\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "CallPhone",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPhoneDialFail",
    "fullName": "OnPhoneDialFail",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "reason",
        "type": "Telephone+DialFailReason, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnDialFailed(Telephone.DialFailReason reason)\r\n{\r\n\tSetPhoneState(Telephone.CallState.Idle);\r\n\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\"ClientOnDialFailed\"), (int)reason);\r\n\tactiveCallTo = null;\r\n\tif (IsInvoking(TimeOutCall))\r\n\t{\r\n\t\tCancelInvoke(TimeOutCall);\r\n\t}\r\n\tif (IsInvoking(TriggerTimeOut))\r\n\t{\r\n\t\tCancelInvoke(TriggerTimeOut);\r\n\t}\r\n\tif (IsInvoking(TimeOutDialing))\r\n\t{\r\n\t\tCancelInvoke(TimeOutDialing);\r\n\t}\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "OnDialFailed",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPhoneDialTimeout",
    "fullName": "OnPhoneDialTimeout",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self2",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TimeOutDialing()\r\n{\r\n\tif (activeCallTo != null)\r\n\t{\r\n\t\tactiveCallTo.ServerPlayAnsweringMessage(this);\r\n\t}\r\n\tSetPhoneState(Telephone.CallState.Idle);\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "TimeOutDialing",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPhoneDialFailed",
    "fullName": "OnPhoneDialFailed",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "reason",
        "type": "Telephone+DialFailReason, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnDialFailed(Telephone.DialFailReason reason)\r\n{\r\n\tSetPhoneState(Telephone.CallState.Idle);\r\n\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\"ClientOnDialFailed\"), (int)reason);\r\n\tactiveCallTo = null;\r\n\tif (IsInvoking(TimeOutCall))\r\n\t{\r\n\t\tCancelInvoke(TimeOutCall);\r\n\t}\r\n\tif (IsInvoking(TriggerTimeOut))\r\n\t{\r\n\t\tCancelInvoke(TriggerTimeOut);\r\n\t}\r\n\tif (IsInvoking(TimeOutDialing))\r\n\t{\r\n\t\tCancelInvoke(TimeOutDialing);\r\n\t}\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "OnDialFailed",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPhoneDialTimedOut",
    "fullName": "OnPhoneDialTimedOut",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self2",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TimeOutDialing()\r\n{\r\n\tif (activeCallTo != null)\r\n\t{\r\n\t\tactiveCallTo.ServerPlayAnsweringMessage(this);\r\n\t}\r\n\tSetPhoneState(Telephone.CallState.Idle);\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "TimeOutDialing",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPhoneAnswered",
    "fullName": "OnPhoneAnswered",
    "category": "Phone",
    "parameters": [
      {
        "name": "phoneController",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "PhoneController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void AnswerPhone(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (IsInvoking(TimeOutDialing))\r\n\t{\r\n\t\tCancelInvoke(TimeOutDialing);\r\n\t}\r\n\tif (!(activeCallTo == null))\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tUpdateServerPlayer(player);\r\n\t\tBeginCall();\r\n\t\tactiveCallTo.BeginCall();\r\n\t}\r\n}\r\n",
    "targetName": "PhoneController",
    "methodName": "AnswerPhone",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerDisconnected",
    "fullName": "OnPlayerDisconnected",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "strReason",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnDisconnected(string strReason, Network.Connection connection)\r\n{\r\n\tFacepunch.Rust.Analytics.Azure.OnPlayerDisconnected(connection, strReason);\r\n\tGlobalNetworkHandler.server.OnClientDisconnected(connection);\r\n\tconnectionQueue.TryAddReservedSlot(connection);\r\n\tconnectionQueue.RemoveConnection(connection);\r\n\tConnectionAuth.OnDisconnect(connection);\r\n\tif (connection.authStatusSteam == \"ok\")\r\n\t{\r\n\t\tPlatformService.Instance.EndPlayerSession(connection.userid);\r\n\t}\r\n\tEACServer.OnLeaveGame(connection);\r\n\tBasePlayer basePlayer = connection.player as BasePlayer;\r\n\tif (basePlayer != null)\r\n\t{\r\n\t\tbasePlayer.OnDisconnected();\r\n\t}\r\n\tif (connection.authStatusNexus == \"ok\")\r\n\t{\r\n\t\tNexusServer.Logout(connection.userid);\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "OnDisconnected",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnClientAuth",
    "fullName": "OnClientAuth",
    "category": "Player",
    "parameters": [
      {
        "name": "connection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnGiveUserInformation(Network.Message packet)\r\n{\r\n\tif (packet.connection.state != 0)\r\n\t{\r\n\t\tNetwork.Net.sv.Kick(packet.connection, \"Invalid connection state\");\r\n\t\treturn;\r\n\t}\r\n\tpacket.connection.state = Network.Connection.State.Connecting;\r\n\tif (packet.read.UInt8() != 228)\r\n\t{\r\n\t\tNetwork.Net.sv.Kick(packet.connection, \"Invalid Connection Protocol\");\r\n\t\treturn;\r\n\t}\r\n\tpacket.connection.userid = packet.read.UInt64();\r\n\tpacket.connection.protocol = packet.read.UInt32();\r\n\tpacket.connection.os = packet.read.String(128);\r\n\tpacket.connection.username = packet.read.String();\r\n\tif (string.IsNullOrEmpty(packet.connection.os))\r\n\t{\r\n\t\tthrow new System.Exception(\"Invalid OS\");\r\n\t}\r\n\tif (string.IsNullOrEmpty(packet.connection.username))\r\n\t{\r\n\t\tNetwork.Net.sv.Kick(packet.connection, \"Invalid Username\");\r\n\t\treturn;\r\n\t}\r\n\tpacket.connection.username = packet.connection.username.Replace('\\n', ' ').Replace('\\r', ' ').Replace('\\t', ' ')\r\n\t\t.Trim();\r\n\tif (string.IsNullOrEmpty(packet.connection.username))\r\n\t{\r\n\t\tNetwork.Net.sv.Kick(packet.connection, \"Invalid Username\");\r\n\t\treturn;\r\n\t}\r\n\tstring text = string.Empty;\r\n\tstring branch = ConVar.Server.branch;\r\n\tif (packet.read.Unread >= 4)\r\n\t{\r\n\t\ttext = packet.read.String(128);\r\n\t}\r\n\tif (branch != string.Empty && branch != text)\r\n\t{\r\n\t\tUnityEngine.DebugEx.Log(\"Kicking \" + packet.connection?.ToString() + \" - their branch is '\" + text + \"' not '\" + branch + \"'\");\r\n\t\tNetwork.Net.sv.Kick(packet.connection, \"Wrong Steam Beta: Requires '\" + branch + \"' branch!\");\r\n\t}\r\n\telse if (packet.connection.protocol > 2583)\r\n\t{\r\n\t\tUnityEngine.DebugEx.Log(\"Kicking \" + packet.connection?.ToString() + \" - their protocol is \" + packet.connection.protocol + \" not \" + 2583);\r\n\t\tNetwork.Net.sv.Kick(packet.connection, \"Wrong Connection Protocol: Server update required!\");\r\n\t}\r\n\telse if (packet.connection.protocol < 2583)\r\n\t{\r\n\t\tUnityEngine.DebugEx.Log(\"Kicking \" + packet.connection?.ToString() + \" - their protocol is \" + packet.connection.protocol + \" not \" + 2583);\r\n\t\tNetwork.Net.sv.Kick(packet.connection, \"Wrong Connection Protocol: Client update required!\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpacket.connection.token = packet.read.BytesWithSize(512u);\r\n\t\tif (packet.connection.token == null || packet.connection.token.Length < 1)\r\n\t\t{\r\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \"Invalid Token\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tpacket.connection.anticheatId = packet.read.StringRaw(128);\r\n\t\tpacket.connection.anticheatToken = packet.read.StringRaw(2048);\r\n\t\tpacket.connection.clientChangeset = packet.read.Int32();\r\n\t\tpacket.connection.clientBuildTime = packet.read.Int64();\r\n\t\tauth.OnNewConnection(packet.connection);\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "OnGiveUserInformation",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerSetInfo",
    "fullName": "OnPlayerSetInfo [server]",
    "category": "Player",
    "parameters": [
      {
        "name": "connection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "name",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "value",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ClientReady(Network.Message packet)\r\n{\r\n\tif (packet.connection.state != Network.Connection.State.Welcoming)\r\n\t{\r\n\t\tNetwork.Net.sv.Kick(packet.connection, \"Invalid connection state\");\r\n\t\treturn;\r\n\t}\r\n\tusing (ProtoBuf.ClientReady clientReady = ProtoBuf.ClientReady.Deserialize(packet.read))\r\n\t{\r\n\t\tforeach (ProtoBuf.ClientReady.ClientInfo item in clientReady.clientInfo)\r\n\t\t{\r\n\t\t\tpacket.connection.info.Set(item.name, item.value);\r\n\t\t}\r\n\t\tpacket.connection.globalNetworking = clientReady.globalNetworking;\r\n\t\tconnectionQueue.JoinedGame(packet.connection);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnPlayerConnected(packet.connection);\r\n\t\tusing (TimeWarning.New(\"ClientReady\"))\r\n\t\t{\r\n\t\t\tBasePlayer basePlayer;\r\n\t\t\tusing (TimeWarning.New(\"SpawnPlayerSleeping\"))\r\n\t\t\t{\r\n\t\t\t\tbasePlayer = SpawnPlayerSleeping(packet.connection);\r\n\t\t\t}\r\n\t\t\tif (basePlayer == null)\r\n\t\t\t{\r\n\t\t\t\tusing (TimeWarning.New(\"SpawnNewPlayer\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tbasePlayer = SpawnNewPlayer(packet.connection);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbasePlayer.SendRespawnOptions();\r\n\t\t\tbasePlayer.LoadClanInfo();\r\n\t\t\tif (basePlayer != null)\r\n\t\t\t{\r\n\t\t\t\tCompanionServer.Util.SendSignedInNotification(basePlayer);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tSendReplicatedVars(packet.connection);\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "ClientReady",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "IOnPlayerBanned",
    "fullName": "IOnPlayerBanned [Publisher/VAC]",
    "category": "Player",
    "parameters": [
      {
        "name": "local1",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "status",
        "type": "AuthResponse, Rust.Platform.Common, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)\r\n{\r\n\tif (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetwork.Connection connection = System.Linq.Enumerable.FirstOrDefault(Network.Net.sv.connections, (Network.Connection x) => x.userid == SteamId);\r\n\tif (connection == null)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning($\"Steam gave us a {Status} ticket response for unconnected id {SteamId}\");\r\n\t\treturn;\r\n\t}\r\n\tswitch (Status)\r\n\t{\r\n\tcase AuthResponse.OK:\r\n\t\tUnityEngine.Debug.LogWarning($\"Steam gave us a 'ok' ticket response for already connected id {SteamId}\");\r\n\t\treturn;\r\n\tcase AuthResponse.TimedOut:\r\n\t\treturn;\r\n\tcase AuthResponse.VACBanned:\r\n\tcase AuthResponse.PublisherBanned:\r\n\t\tif (!bannedPlayerNotices.Contains(SteamId))\r\n\t\t{\r\n\t\t\tConsoleNetwork.BroadcastToAllClients(\"chat.add\", 2, 0, \"<color=#fff>SERVER</color> Kicking \" + UnityEngine.StringEx.EscapeRichText(connection.username) + \" (banned by anticheat)\");\r\n\t\t\tbannedPlayerNotices.Add(SteamId);\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\tUnityEngine.Debug.Log($\"Kicking {connection.ipaddress}/{connection.userid}/{connection.username} (Steam Status \\\"{Status.ToString()}\\\")\");\r\n\tconnection.authStatusSteam = Status.ToString();\r\n\tNetwork.Net.sv.Kick(connection, \"Steam: \" + Status);\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "OnValidateAuthTicketResponse",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFindSpawnPoint",
    "fullName": "OnFindSpawnPoint",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null)\r\n{\r\n\tbool flag = false;\r\n\tif (forPlayer != null && forPlayer.IsInTutorial)\r\n\t{\r\n\t\tTutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();\r\n\t\tif (currentTutorialIsland != null)\r\n\t\t{\r\n\t\t\tBasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();\r\n\t\t\tif (forPlayer.CurrentTutorialAllowance > BasePlayer.TutorialItemAllowance.Level1_HatchetPickaxe)\r\n\t\t\t{\r\n\t\t\t\tspawnPoint.pos = currentTutorialIsland.MidMissionSpawnPoint.position;\r\n\t\t\t\tspawnPoint.rot = currentTutorialIsland.MidMissionSpawnPoint.rotation;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspawnPoint.pos = currentTutorialIsland.InitialSpawnPoint.position;\r\n\t\t\t\tspawnPoint.rot = currentTutorialIsland.InitialSpawnPoint.rotation;\r\n\t\t\t}\r\n\t\t\treturn spawnPoint;\r\n\t\t}\r\n\t}\r\n\tBaseGameMode baseGameMode = Gamemode();\r\n\tif ((bool)baseGameMode && baseGameMode.useCustomSpawns)\r\n\t{\r\n\t\tBasePlayer.SpawnPoint playerSpawn = baseGameMode.GetPlayerSpawn(forPlayer);\r\n\t\tif (playerSpawn != null)\r\n\t\t{\r\n\t\t\treturn playerSpawn;\r\n\t\t}\r\n\t}\r\n\tif (SingletonComponent<SpawnHandler>.Instance != null && !flag)\r\n\t{\r\n\t\tBasePlayer.SpawnPoint spawnPoint2 = SpawnHandler.GetSpawnPoint();\r\n\t\tif (spawnPoint2 != null)\r\n\t\t{\r\n\t\t\treturn spawnPoint2;\r\n\t\t}\r\n\t}\r\n\tBasePlayer.SpawnPoint spawnPoint3 = new BasePlayer.SpawnPoint();\r\n\tif (forPlayer != null && forPlayer.IsInTutorial)\r\n\t{\r\n\t\tTutorialIsland currentTutorialIsland2 = forPlayer.GetCurrentTutorialIsland();\r\n\t\tif (currentTutorialIsland2 != null)\r\n\t\t{\r\n\t\t\tspawnPoint3.pos = currentTutorialIsland2.InitialSpawnPoint.position;\r\n\t\t\tspawnPoint3.rot = currentTutorialIsland2.InitialSpawnPoint.rotation;\r\n\t\t\treturn spawnPoint3;\r\n\t\t}\r\n\t}\r\n\tUnityEngine.GameObject[] array = UnityEngine.GameObject.FindGameObjectsWithTag(\"spawnpoint\");\r\n\tif (array.Length != 0)\r\n\t{\r\n\t\tUnityEngine.GameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];\r\n\t\tspawnPoint3.pos = gameObject.transform.position;\r\n\t\tspawnPoint3.rot = gameObject.transform.rotation;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"Couldn't find an appropriate spawnpoint for the player - so spawning at camera\");\r\n\t\tif (MainCamera.mainCamera != null)\r\n\t\t{\r\n\t\t\tspawnPoint3.pos = MainCamera.position;\r\n\t\t\tspawnPoint3.rot = MainCamera.rotation;\r\n\t\t}\r\n\t}\r\n\tif (UnityEngine.Physics.Raycast(new UnityEngine.Ray(spawnPoint3.pos, UnityEngine.Vector3.down), out var hitInfo, 32f, 1537286401))\r\n\t{\r\n\t\tspawnPoint3.pos = hitInfo.point;\r\n\t}\r\n\treturn spawnPoint3;\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "FindSpawnPoint",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "BasePlayer+SpawnPoint"
  },
  {
    "name": "OnClientDisconnect",
    "fullName": "OnClientDisconnect",
    "category": "Player",
    "parameters": [
      {
        "name": "connection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ReadDisconnectReason(Network.Message packet)\r\n{\r\n\tstring text = packet.read.String(4096);\r\n\tstring text2 = packet.connection.ToString();\r\n\tif (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))\r\n\t{\r\n\t\tUnityEngine.DebugEx.Log(text2 + \" disconnecting: \" + text);\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "ReadDisconnectReason",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerSpawn",
    "fullName": "OnPlayerSpawn",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public BasePlayer SpawnNewPlayer(Network.Connection connection)\r\n{\r\n\tBasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();\r\n\tBasePlayer basePlayer = GameManager.server.CreateEntity(\"assets/prefabs/player/player.prefab\", spawnPoint.pos, spawnPoint.rot).ToPlayer();\r\n\tbasePlayer.health = 0f;\r\n\tbasePlayer.lifestate = BaseCombatEntity.LifeState.Dead;\r\n\tbasePlayer.ResetLifeStateOnSpawn = false;\r\n\tbasePlayer.limitNetworking = true;\r\n\tif (connection == null)\r\n\t{\r\n\t\tbasePlayer.EnableTransferProtection();\r\n\t}\r\n\tbasePlayer.Spawn();\r\n\tbasePlayer.limitNetworking = false;\r\n\tif (connection != null)\r\n\t{\r\n\t\tbasePlayer.PlayerInit(connection);\r\n\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\r\n\t\t{\r\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer);\r\n\t\t}\r\n\t\telse if (UnityEngine.Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife))\r\n\t\t{\r\n\t\t\tbasePlayer.Respawn();\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log($\"{basePlayer.displayName} with steamid {basePlayer.userID.Get()} joined from ip {basePlayer.net.connection.ipaddress}\");\r\n\t\tUnityEngine.DebugEx.Log($\"\\tNetworkId {basePlayer.userID.Get()} is {basePlayer.net.ID} ({basePlayer.displayName})\");\r\n\t\tif (basePlayer.net.connection.ownerid != 0L && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)\r\n\t\t{\r\n\t\t\tUnityEngine.DebugEx.Log($\"\\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}\");\r\n\t\t}\r\n\t}\r\n\treturn basePlayer;\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "SpawnNewPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanUseLockedEntity",
    "fullName": "CanUseLockedEntity [CodeLock, open]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "codeLock",
        "type": "CodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool OnTryToOpen(BasePlayer player)\r\n{\r\n\tif (!IsLocked())\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))\r\n\t{\r\n\t\tDoEffect(effectUnlocked.resourcePath);\r\n\t\treturn true;\r\n\t}\r\n\tDoEffect(effectDenied.resourcePath);\r\n\treturn false;\r\n}\r\n",
    "targetName": "CodeLock",
    "methodName": "OnTryToOpen",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanUseLockedEntity",
    "fullName": "CanUseLockedEntity [CodeLock, close]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "codeLock",
        "type": "CodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool OnTryToClose(BasePlayer player)\r\n{\r\n\tif (!IsLocked())\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))\r\n\t{\r\n\t\tDoEffect(effectUnlocked.resourcePath);\r\n\t\treturn true;\r\n\t}\r\n\tDoEffect(effectDenied.resourcePath);\r\n\treturn false;\r\n}\r\n",
    "targetName": "CodeLock",
    "methodName": "OnTryToClose",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanUnlock",
    "fullName": "CanUnlock [CodeLock]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "codeLock",
        "type": "CodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f, CheckParent = true)]\r\npublic void TryUnlock(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && IsLocked() && !IsCodeEntryBlocked() && whitelistPlayers.Contains(rpc.player.userID))\r\n\t{\r\n\t\tDoEffect(effectUnlocked.resourcePath);\r\n\t\tSetFlag(BaseEntity.Flags.Locked, b: false);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "CodeLock",
    "methodName": "TryUnlock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanLock",
    "fullName": "CanLock [code]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "codeLock",
        "type": "CodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f, CheckParent = true)]\r\npublic void TryLock(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && whitelistPlayers.Contains(rpc.player.userID))\r\n\t{\r\n\t\tDoEffect(effectLocked.resourcePath);\r\n\t\tSetFlag(BaseEntity.Flags.Locked, b: true);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "CodeLock",
    "methodName": "TryLock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanChangeCode",
    "fullName": "CanChangeCode",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "codeLock",
        "type": "CodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f, CheckParent = true)]\r\npublic void RPC_ChangeCode(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = rpc.read.String();\r\n\tbool flag = rpc.read.Bit();\r\n\tif (!IsLocked() && text.Length == 4 && UnityEngine.StringEx.IsNumeric(text) && !(!hasCode && flag))\r\n\t{\r\n\t\tif (!hasCode && !flag)\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Locked, b: true);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tcode = text;\r\n\t\t\thasCode = code.Length > 0;\r\n\t\t\twhitelistPlayers.Clear();\r\n\t\t\twhitelistPlayers.Add(rpc.player.userID);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tguestCode = text;\r\n\t\t\thasGuestCode = guestCode.Length > 0;\r\n\t\t\tguestPlayers.Clear();\r\n\t\t\tguestPlayers.Add(rpc.player.userID);\r\n\t\t}\r\n\t\tDoEffect(effectCodeChanged.resourcePath);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "CodeLock",
    "methodName": "RPC_ChangeCode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanUseLockedEntity",
    "fullName": "CanUseLockedEntity [KeyLock, close]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "keyLock",
        "type": "KeyLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool OnTryToClose(BasePlayer player)\r\n{\r\n\tif (HasLockPermission(player))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn !IsLocked();\r\n}\r\n",
    "targetName": "KeyLock",
    "methodName": "OnTryToClose",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanUseLockedEntity",
    "fullName": "CanUseLockedEntity [KeyLock, open]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "keyLock",
        "type": "KeyLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool OnTryToOpen(BasePlayer player)\r\n{\r\n\tif (HasLockPermission(player))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn !IsLocked();\r\n}\r\n",
    "targetName": "KeyLock",
    "methodName": "OnTryToOpen",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanUnlock",
    "fullName": "CanUnlock [KeyLock]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "keyLock",
        "type": "KeyLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f, CheckParent = true)]\r\npublic void RPC_Unlock(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && IsLocked() && HasLockPermission(rpc.player))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Locked, b: false);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "KeyLock",
    "methodName": "RPC_Unlock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanLock",
    "fullName": "CanLock [key]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "keyLock",
        "type": "KeyLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Lock(BasePlayer player)\r\n{\r\n\tif (!(player == null) && player.CanInteract() && !IsLocked() && HasLockPermission(player))\r\n\t{\r\n\t\tLockLock(player);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "KeyLock",
    "methodName": "Lock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLootEntity",
    "fullName": "OnLootEntity",
    "category": "Player",
    "parameters": [
      {
        "name": "playerLoot",
        "type": "PlayerLoot, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "targetEntity",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "#define UNITY_ASSERTIONS\r\npublic bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)\r\n{\r\n\tClear();\r\n\tif (!targetEntity)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!targetEntity.OnStartBeingLooted(base.baseEntity))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tUnityEngine.Assertions.Assert.IsTrue(targetEntity.isServer, \"Assure is server\");\r\n\tPositionChecks = doPositionChecks;\r\n\tentitySource = targetEntity;\r\n\titemSource = null;\r\n\tMarkDirty();\r\n\tif (targetEntity is ILootableEntity lootableEntity)\r\n\t{\r\n\t\tlootableEntity.LastLootedBy = base.baseEntity.userID;\r\n\t\tlootableEntity.LastLootedByPlayer = base.baseEntity;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "PlayerLoot",
    "methodName": "StartLootingEntity",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnLootItem",
    "fullName": "OnLootItem",
    "category": "Player",
    "parameters": [
      {
        "name": "playerLoot",
        "type": "PlayerLoot, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartLootingItem(Item item)\r\n{\r\n\tClear();\r\n\tif (item != null && item.contents != null)\r\n\t{\r\n\t\tPositionChecks = true;\r\n\t\tcontainers.Add(item.contents);\r\n\t\titem.contents.onDirty += MarkDirty;\r\n\t\titemSource = item;\r\n\t\tentitySource = item.GetWorldEntity();\r\n\t\tMarkDirty();\r\n\t}\r\n}\r\n",
    "targetName": "PlayerLoot",
    "methodName": "StartLootingItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerLootEnd",
    "fullName": "OnPlayerLootEnd",
    "category": "Player",
    "parameters": [
      {
        "name": "playerLoot",
        "type": "PlayerLoot, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Clear()\r\n{\r\n\tif (!IsLooting())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.baseEntity.HasClosedLoot();\r\n\tMarkDirty();\r\n\tif ((bool)entitySource)\r\n\t{\r\n\t\tentitySource.SendMessage(\"PlayerStoppedLooting\", base.baseEntity, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t}\r\n\tforeach (ItemContainer container in containers)\r\n\t{\r\n\t\tif (container != null)\r\n\t\t{\r\n\t\t\tcontainer.onDirty -= MarkDirty;\r\n\t\t}\r\n\t}\r\n\tClearContainers();\r\n\tentitySource = null;\r\n\titemSource = null;\r\n}\r\n",
    "targetName": "PlayerLoot",
    "methodName": "Clear",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnLootNetworkUpdate",
    "fullName": "OnLootNetworkUpdate",
    "category": "Player",
    "parameters": [
      {
        "name": "playerLoot",
        "type": "PlayerLoot, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendUpdate()\r\n{\r\n\tisInvokingSendUpdate = false;\r\n\tif (!base.baseEntity.IsValid())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing ProtoBuf.PlayerUpdateLoot playerUpdateLoot = Facepunch.Pool.Get<ProtoBuf.PlayerUpdateLoot>();\r\n\tif ((bool)entitySource && entitySource.net != null)\r\n\t{\r\n\t\tplayerUpdateLoot.entityID = entitySource.net.ID;\r\n\t}\r\n\tif (itemSource != null)\r\n\t{\r\n\t\tplayerUpdateLoot.itemID = itemSource.uid;\r\n\t}\r\n\tif (containers.Count > 0)\r\n\t{\r\n\t\tplayerUpdateLoot.containers = Facepunch.Pool.Get<System.Collections.Generic.List<ProtoBuf.ItemContainer>>();\r\n\t\tforeach (ItemContainer container in containers)\r\n\t\t{\r\n\t\t\tplayerUpdateLoot.containers.Add(container.Save());\r\n\t\t}\r\n\t}\r\n\tbase.baseEntity.ClientRPC(RpcTarget.Player(\"UpdateLoot\", base.baseEntity), playerUpdateLoot);\r\n}\r\n",
    "targetName": "PlayerLoot",
    "methodName": "SendUpdate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerAttack",
    "fullName": "OnPlayerAttack [Melee]",
    "category": "Player",
    "parameters": [
      {
        "name": "baseMelee",
        "type": "BaseMelee, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void DoAttackShared(HitInfo info)\r\n{\r\n\tGetAttackStats(info);\r\n\tif (info.HitEntity != null)\r\n\t{\r\n\t\tusing (TimeWarning.New(\"OnAttacked\", 50))\r\n\t\t{\r\n\t\t\tinfo.HitEntity.OnAttacked(info);\r\n\t\t}\r\n\t}\r\n\tif (info.DoHitEffects)\r\n\t{\r\n\t\tif (base.isServer)\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\"ImpactEffect\", 20))\r\n\t\t\t{\r\n\t\t\t\tEffect.server.ImpactEffect(info);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\"ImpactEffect\", 20))\r\n\t\t\t{\r\n\t\t\t\tEffect.client.ImpactEffect(info);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (base.isServer && !base.IsDestroyed)\r\n\t{\r\n\t\tusing (TimeWarning.New(\"UpdateItemCondition\", 50))\r\n\t\t{\r\n\t\t\tUpdateItemCondition(info);\r\n\t\t}\r\n\t\tStartAttackCooldown(repeatDelay);\r\n\t}\r\n}\r\n",
    "targetName": "BaseMelee",
    "methodName": "DoAttackShared",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMeleeAttack",
    "fullName": "OnMeleeAttack",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void PlayerAttack(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!VerifyClientAttack(player))\r\n\t{\r\n\t\tSendNetworkUpdate();\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"PlayerAttack\", 50))\r\n\t{\r\n\t\tusing ProtoBuf.PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);\r\n\t\tif (playerAttack == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tHitInfo obj = Facepunch.Pool.Get<HitInfo>();\r\n\t\tobj.LoadFromAttack(playerAttack.attack, serverSide: true);\r\n\t\tobj.Initiator = player;\r\n\t\tobj.Weapon = this;\r\n\t\tobj.WeaponPrefab = this;\r\n\t\tobj.Predicted = msg.connection;\r\n\t\tobj.damageProperties = damageProperties;\r\n\t\tif (obj.IsNaNOrInfinity())\r\n\t\t{\r\n\t\t\tstring shortPrefabName = base.ShortPrefabName;\r\n\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \"Contains NaN (\" + shortPrefabName + \")\");\r\n\t\t\tplayer.stats.combat.LogInvalid(obj, \"melee_nan\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBaseEntity hitEntity = obj.HitEntity;\r\n\t\tBasePlayer basePlayer = obj.HitEntity as BasePlayer;\r\n\t\tbool flag = basePlayer != null;\r\n\t\tbool flag2 = flag && basePlayer.IsSleeping();\r\n\t\tbool flag3 = flag && basePlayer.IsWounded();\r\n\t\tbool flag4 = flag && basePlayer.isMounted;\r\n\t\tbool flag5 = flag && basePlayer.HasParent();\r\n\t\tbool flag6 = hitEntity != null;\r\n\t\tbool flag7 = flag6 && hitEntity.IsNpc;\r\n\t\tbool flag8;\r\n\t\tint num5;\r\n\t\tUnityEngine.Vector3 center;\r\n\t\tUnityEngine.Vector3 position;\r\n\t\tUnityEngine.Vector3 pointStart;\r\n\t\tUnityEngine.Vector3 hitPositionWorld;\r\n\t\tUnityEngine.Vector3 vector;\r\n\t\tint num16;\r\n\t\tif (ConVar.AntiHack.melee_protection > 0)\r\n\t\t{\r\n\t\t\tflag8 = true;\r\n\t\t\tfloat num = 1f + ConVar.AntiHack.melee_forgiveness;\r\n\t\t\tfloat melee_clientframes = ConVar.AntiHack.melee_clientframes;\r\n\t\t\tfloat melee_serverframes = ConVar.AntiHack.melee_serverframes;\r\n\t\t\tfloat num2 = melee_clientframes / 60f;\r\n\t\t\tfloat num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\r\n\t\t\tfloat num4 = (player.desyncTimeClamped + num2 + num3) * num;\r\n\t\t\tnum5 = 1075904512;\r\n\t\t\tif (ConVar.AntiHack.melee_terraincheck)\r\n\t\t\t{\r\n\t\t\t\tnum5 |= 0x800000;\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.melee_vehiclecheck)\r\n\t\t\t{\r\n\t\t\t\tnum5 |= 0x8000000;\r\n\t\t\t}\r\n\t\t\tif (flag && obj.boneArea == (HitArea)(-1))\r\n\t\t\t{\r\n\t\t\t\tstring shortPrefabName2 = base.ShortPrefabName;\r\n\t\t\t\tstring shortPrefabName3 = basePlayer.ShortPrefabName;\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \"Bone is invalid  (\" + shortPrefabName2 + \" on \" + shortPrefabName3 + \" bone \" + obj.HitBone + \")\");\r\n\t\t\t\tplayer.stats.combat.LogInvalid(obj, \"melee_bone\");\r\n\t\t\t\tflag8 = false;\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.melee_protection >= 2)\r\n\t\t\t{\r\n\t\t\t\tif (flag6)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat num6 = hitEntity.MaxVelocity() + hitEntity.GetParentVelocity().magnitude;\r\n\t\t\t\t\tfloat num7 = hitEntity.BoundsPadding() + num4 * num6;\r\n\t\t\t\t\tfloat num8 = hitEntity.Distance(obj.HitPositionWorld);\r\n\t\t\t\t\tif (num8 > num7)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring shortPrefabName4 = base.ShortPrefabName;\r\n\t\t\t\t\t\tstring shortPrefabName5 = hitEntity.ShortPrefabName;\r\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \"Entity too far away (\" + shortPrefabName4 + \" on \" + shortPrefabName5 + \" with \" + num8 + \"m > \" + num7 + \"m in \" + num4 + \"s)\");\r\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \"melee_target\");\r\n\t\t\t\t\t\tflag8 = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (ConVar.AntiHack.melee_protection >= 4 && flag8 && flag && !flag7 && !flag2 && !flag3 && !flag4 && !flag5)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat magnitude = basePlayer.GetParentVelocity().magnitude;\r\n\t\t\t\t\tfloat num9 = basePlayer.BoundsPadding() + num4 * magnitude + ConVar.AntiHack.tickhistoryforgiveness;\r\n\t\t\t\t\tfloat num10 = basePlayer.tickHistory.Distance(basePlayer, obj.HitPositionWorld);\r\n\t\t\t\t\tif (num10 > num9)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring shortPrefabName6 = base.ShortPrefabName;\r\n\t\t\t\t\t\tstring shortPrefabName7 = basePlayer.ShortPrefabName;\r\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \"Player too far away (\" + shortPrefabName6 + \" on \" + shortPrefabName7 + \" with \" + num10 + \"m > \" + num9 + \"m in \" + num4 + \"s)\");\r\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \"player_distance\");\r\n\t\t\t\t\t\tflag8 = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.melee_protection >= 1)\r\n\t\t\t{\r\n\t\t\t\tif (ConVar.AntiHack.melee_protection >= 4)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat magnitude2 = player.GetParentVelocity().magnitude;\r\n\t\t\t\t\tfloat num11 = player.BoundsPadding() + num4 * magnitude2 + num * maxDistance;\r\n\t\t\t\t\tfloat num12 = player.tickHistory.Distance(player, obj.HitPositionWorld);\r\n\t\t\t\t\tif (num12 > num11)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring shortPrefabName8 = base.ShortPrefabName;\r\n\t\t\t\t\t\tstring text = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \"Initiator too far away (\" + shortPrefabName8 + \" on \" + text + \" with \" + num12 + \"m > \" + num11 + \"m in \" + num4 + \"s)\");\r\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \"melee_initiator\");\r\n\t\t\t\t\t\tflag8 = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat num13 = player.MaxVelocity() + player.GetParentVelocity().magnitude;\r\n\t\t\t\t\tfloat num14 = player.BoundsPadding() + num4 * num13 + num * maxDistance;\r\n\t\t\t\t\tfloat num15 = player.Distance(obj.HitPositionWorld);\r\n\t\t\t\t\tif (num15 > num14)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring shortPrefabName9 = base.ShortPrefabName;\r\n\t\t\t\t\t\tstring text2 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \"Initiator too far away (\" + shortPrefabName9 + \" on \" + text2 + \" with \" + num15 + \"m > \" + num14 + \"m in \" + num4 + \"s)\");\r\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(obj, \"melee_initiator\");\r\n\t\t\t\t\t\tflag8 = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.melee_protection >= 3)\r\n\t\t\t{\r\n\t\t\t\tif (flag6)\r\n\t\t\t\t{\r\n\t\t\t\t\tcenter = player.eyes.center;\r\n\t\t\t\t\tposition = player.eyes.position;\r\n\t\t\t\t\tpointStart = obj.PointStart;\r\n\t\t\t\t\thitPositionWorld = obj.HitPositionWorld;\r\n\t\t\t\t\thitPositionWorld -= (hitPositionWorld - pointStart).normalized * 0.001f;\r\n\t\t\t\t\tvector = obj.PositionOnRay(hitPositionWorld);\r\n\t\t\t\t\tUnityEngine.Vector3 vector2 = UnityEngine.Vector3.zero;\r\n\t\t\t\t\tUnityEngine.Vector3 vector3 = UnityEngine.Vector3.zero;\r\n\t\t\t\t\tUnityEngine.Vector3 vector4 = UnityEngine.Vector3.zero;\r\n\t\t\t\t\tif (ConVar.AntiHack.melee_backtracking > 0f)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvector2 = (position - center).normalized * ConVar.AntiHack.melee_backtracking;\r\n\t\t\t\t\t\tvector3 = (pointStart - position).normalized * ConVar.AntiHack.melee_backtracking;\r\n\t\t\t\t\t\tvector4 = (vector - pointStart).normalized * ConVar.AntiHack.melee_backtracking;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (GamePhysics.LineOfSight(center - vector2, position + vector2, num5) && GamePhysics.LineOfSight(position - vector3, pointStart + vector3, num5) && GamePhysics.LineOfSight(pointStart - vector4, vector, num5) && GamePhysics.LineOfSight(vector, hitPositionWorld, num5))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnum16 = (GamePhysics.LineOfSight(position, hitPositionWorld, num5) ? 1 : 0);\r\n\t\t\t\t\t\tif (num16 != 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tplayer.stats.Add(\"hit_\" + hitEntity.Categorize() + \"_direct_los\", 1, Stats.Server);\r\n\t\t\t\t\t\t\tgoto IL_07c5;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnum16 = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tplayer.stats.Add(\"hit_\" + hitEntity.Categorize() + \"_indirect_los\", 1, Stats.Server);\r\n\t\t\t\t\tgoto IL_07c5;\r\n\t\t\t\t}\r\n\t\t\t\tgoto IL_08b3;\r\n\t\t\t}\r\n\t\t\tgoto IL_0a1a;\r\n\t\t}\r\n\t\tgoto IL_0a2c;\r\n\t\tIL_0a1a:\r\n\t\tif (!flag8)\r\n\t\t{\r\n\t\t\tAntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tgoto IL_0a2c;\r\n\t\tIL_07c5:\r\n\t\tif (num16 == 0)\r\n\t\t{\r\n\t\t\tstring shortPrefabName10 = base.ShortPrefabName;\r\n\t\t\tstring shortPrefabName11 = hitEntity.ShortPrefabName;\r\n\t\t\tstring[] obj2 = new string[14]\r\n\t\t\t{\r\n\t\t\t\t\"Line of sight (\", shortPrefabName10, \" on \", shortPrefabName11, \") \", null, null, null, null, null,\r\n\t\t\t\tnull, null, null, null\r\n\t\t\t};\r\n\t\t\tUnityEngine.Vector3 vector5 = center;\r\n\t\t\tobj2[5] = vector5.ToString();\r\n\t\t\tobj2[6] = \" \";\r\n\t\t\tvector5 = position;\r\n\t\t\tobj2[7] = vector5.ToString();\r\n\t\t\tobj2[8] = \" \";\r\n\t\t\tvector5 = pointStart;\r\n\t\t\tobj2[9] = vector5.ToString();\r\n\t\t\tobj2[10] = \" \";\r\n\t\t\tvector5 = vector;\r\n\t\t\tobj2[11] = vector5.ToString();\r\n\t\t\tobj2[12] = \" \";\r\n\t\t\tvector5 = hitPositionWorld;\r\n\t\t\tobj2[13] = vector5.ToString();\r\n\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj2));\r\n\t\t\tplayer.stats.combat.LogInvalid(obj, \"melee_los\");\r\n\t\t\tflag8 = false;\r\n\t\t}\r\n\t\tgoto IL_08b3;\r\n\t\tIL_0a2c:\r\n\t\tplayer.metabolism.UseHeart(heartStress * 0.2f);\r\n\t\tusing (TimeWarning.New(\"DoAttackShared\", 50))\r\n\t\t{\r\n\t\t\tDoAttackShared(obj);\r\n\t\t}\r\n\t\tFacepunch.Pool.Free(ref obj);\r\n\t\treturn;\r\n\t\tIL_08b3:\r\n\t\tif (flag8 && flag && !flag7)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 hitPositionWorld2 = obj.HitPositionWorld;\r\n\t\t\tUnityEngine.Vector3 position2 = basePlayer.eyes.position;\r\n\t\t\tUnityEngine.Vector3 vector6 = basePlayer.CenterPoint();\r\n\t\t\tfloat melee_losforgiveness = ConVar.AntiHack.melee_losforgiveness;\r\n\t\t\tbool flag9 = GamePhysics.LineOfSight(hitPositionWorld2, position2, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(position2, hitPositionWorld2, num5, melee_losforgiveness, 0f);\r\n\t\t\tif (!flag9)\r\n\t\t\t{\r\n\t\t\t\tflag9 = GamePhysics.LineOfSight(hitPositionWorld2, vector6, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(vector6, hitPositionWorld2, num5, melee_losforgiveness, 0f);\r\n\t\t\t}\r\n\t\t\tif (!flag9)\r\n\t\t\t{\r\n\t\t\t\tstring shortPrefabName12 = base.ShortPrefabName;\r\n\t\t\t\tstring shortPrefabName13 = basePlayer.ShortPrefabName;\r\n\t\t\t\tstring[] obj3 = new string[12]\r\n\t\t\t\t{\r\n\t\t\t\t\t\"Line of sight (\", shortPrefabName12, \" on \", shortPrefabName13, \") \", null, null, null, null, null,\r\n\t\t\t\t\tnull, null\r\n\t\t\t\t};\r\n\t\t\t\tUnityEngine.Vector3 vector5 = hitPositionWorld2;\r\n\t\t\t\tobj3[5] = vector5.ToString();\r\n\t\t\t\tobj3[6] = \" \";\r\n\t\t\t\tvector5 = position2;\r\n\t\t\t\tobj3[7] = vector5.ToString();\r\n\t\t\t\tobj3[8] = \" or \";\r\n\t\t\t\tvector5 = hitPositionWorld2;\r\n\t\t\t\tobj3[9] = vector5.ToString();\r\n\t\t\t\tobj3[10] = \" \";\r\n\t\t\t\tvector5 = vector6;\r\n\t\t\t\tobj3[11] = vector5.ToString();\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj3));\r\n\t\t\t\tplayer.stats.combat.LogInvalid(obj, \"melee_los\");\r\n\t\t\t\tflag8 = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tgoto IL_0a1a;\r\n\t}\r\n}\r\n",
    "targetName": "BaseMelee",
    "methodName": "PlayerAttack",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerAttack",
    "fullName": "OnPlayerAttack [Projectile]",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\npublic void OnProjectileAttack(BaseEntity.RPCMessage msg)\r\n{\r\n\tProtoBuf.PlayerProjectileAttack playerProjectileAttack = ProtoBuf.PlayerProjectileAttack.Deserialize(msg.read);\r\n\tif (playerProjectileAttack == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PlayerAttack playerAttack = playerProjectileAttack.playerAttack;\r\n\tHitInfo hitInfo = new HitInfo();\r\n\thitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);\r\n\thitInfo.Initiator = this;\r\n\thitInfo.ProjectileID = playerAttack.projectileID;\r\n\thitInfo.ProjectileDistance = playerProjectileAttack.hitDistance;\r\n\thitInfo.ProjectileVelocity = playerProjectileAttack.hitVelocity;\r\n\thitInfo.ProjectileTravelTime = playerProjectileAttack.travelTime;\r\n\thitInfo.Predicted = msg.connection;\r\n\tif (hitInfo.IsNaNOrInfinity() || float.IsNaN(playerProjectileAttack.travelTime) || float.IsInfinity(playerProjectileAttack.travelTime))\r\n\t{\r\n\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Contains NaN (\" + playerAttack.projectileID + \")\");\r\n\t\tplayerProjectileAttack.ResetToPool();\r\n\t\tplayerProjectileAttack = null;\r\n\t\tstats.combat.LogInvalid(hitInfo, \"projectile_nan\");\r\n\t\treturn;\r\n\t}\r\n\tif (!firedProjectiles.TryGetValue(playerAttack.projectileID, out var value))\r\n\t{\r\n\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Missing ID (\" + playerAttack.projectileID + \")\", logToAnalytics: false);\r\n\t\tplayerProjectileAttack.ResetToPool();\r\n\t\tplayerProjectileAttack = null;\r\n\t\tstats.combat.LogInvalid(hitInfo, \"projectile_invalid\");\r\n\t\treturn;\r\n\t}\r\n\thitInfo.ProjectileHits = value.hits;\r\n\thitInfo.ProjectileIntegrity = value.integrity;\r\n\thitInfo.ProjectileTrajectoryMismatch = value.trajectoryMismatch;\r\n\tif (value.integrity <= 0f)\r\n\t{\r\n\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Integrity is zero (\" + playerAttack.projectileID + \")\");\r\n\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\tplayerProjectileAttack.ResetToPool();\r\n\t\tplayerProjectileAttack = null;\r\n\t\tstats.combat.LogInvalid(hitInfo, \"projectile_integrity\");\r\n\t\treturn;\r\n\t}\r\n\tif (value.firedTime < UnityEngine.Time.realtimeSinceStartup - 8f)\r\n\t{\r\n\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Lifetime is zero (\" + playerAttack.projectileID + \")\");\r\n\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\tplayerProjectileAttack.ResetToPool();\r\n\t\tplayerProjectileAttack = null;\r\n\t\tstats.combat.LogInvalid(hitInfo, \"projectile_lifetime\");\r\n\t\treturn;\r\n\t}\r\n\tif (value.ricochets > 0)\r\n\t{\r\n\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Projectile is ricochet (\" + playerAttack.projectileID + \")\");\r\n\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\tplayerProjectileAttack.ResetToPool();\r\n\t\tplayerProjectileAttack = null;\r\n\t\tstats.combat.LogInvalid(hitInfo, \"projectile_ricochet\");\r\n\t\treturn;\r\n\t}\r\n\thitInfo.Weapon = value.weaponSource;\r\n\thitInfo.WeaponPrefab = value.weaponPrefab;\r\n\thitInfo.ProjectilePrefab = value.projectilePrefab;\r\n\thitInfo.damageProperties = value.projectilePrefab.damageProperties;\r\n\tUnityEngine.Vector3 position = value.position;\r\n\tUnityEngine.Vector3 initialPositionOffset = value.initialPositionOffset;\r\n\tUnityEngine.Vector3 positionOffset = value.positionOffset;\r\n\tUnityEngine.Vector3 velocity = value.velocity;\r\n\tfloat partialTime = value.partialTime;\r\n\tfloat travelTime = value.travelTime;\r\n\tfloat num = UnityEngine.Mathf.Clamp(playerProjectileAttack.travelTime, value.travelTime, 8f);\r\n\tUnityEngine.Vector3 gravity = UnityEngine.Physics.gravity * value.projectilePrefab.gravityModifier;\r\n\tfloat drag = value.projectilePrefab.drag;\r\n\tBaseEntity hitEntity = hitInfo.HitEntity;\r\n\tBasePlayer basePlayer = hitEntity as BasePlayer;\r\n\tbool flag = basePlayer != null;\r\n\tbool flag2 = flag && basePlayer.IsSleeping();\r\n\tbool flag3 = flag && basePlayer.IsWounded();\r\n\tbool flag4 = flag && basePlayer.isMounted;\r\n\tbool flag5 = flag && basePlayer.HasParent();\r\n\tbool flag6 = hitEntity != null;\r\n\tbool flag7 = flag6 && hitEntity.IsNpc;\r\n\tbool flag8 = hitInfo.HitMaterial == Projectile.WaterMaterialID();\r\n\tbool flag9;\r\n\tint num15;\r\n\tUnityEngine.Vector3 position2;\r\n\tUnityEngine.Vector3 pointStart;\r\n\tUnityEngine.Vector3 hitPositionWorld;\r\n\tUnityEngine.Vector3 vector;\r\n\tbool flag10;\r\n\tint num32;\r\n\tif (value.protection > 0)\r\n\t{\r\n\t\tflag9 = true;\r\n\t\tfloat num2 = 1f + ConVar.AntiHack.projectile_forgiveness;\r\n\t\tfloat num3 = 1f - ConVar.AntiHack.projectile_forgiveness;\r\n\t\tfloat projectile_clientframes = ConVar.AntiHack.projectile_clientframes;\r\n\t\tfloat projectile_serverframes = ConVar.AntiHack.projectile_serverframes;\r\n\t\tfloat num4 = Mathx.Decrement(value.firedTime);\r\n\t\tfloat num5 = UnityEngine.Mathf.Clamp(Mathx.Increment(UnityEngine.Time.realtimeSinceStartup) - num4, 0f, 8f);\r\n\t\tfloat num6 = num;\r\n\t\tfloat num7 = (value.desyncLifeTime = UnityEngine.Mathf.Abs(num5 - num6));\r\n\t\tfloat num8 = UnityEngine.Mathf.Min(num5, num6);\r\n\t\tfloat num9 = projectile_clientframes / 60f;\r\n\t\tfloat num10 = projectile_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\r\n\t\tfloat num11 = (desyncTimeClamped + num8 + num9 + num10) * num2;\r\n\t\tfloat num12 = ((value.protection >= 6) ? ((desyncTimeClamped + num9 + num10) * num2) : num11);\r\n\t\tfloat num13 = (num5 - desyncTimeClamped - num9 - num10) * num3;\r\n\t\tfloat num14 = UnityEngine.Vector3.Distance(value.initialPosition, hitInfo.HitPositionWorld);\r\n\t\tnum15 = 1075904512;\r\n\t\tif (ConVar.AntiHack.projectile_terraincheck)\r\n\t\t{\r\n\t\t\tnum15 |= 0x800000;\r\n\t\t}\r\n\t\tif (ConVar.AntiHack.projectile_vehiclecheck)\r\n\t\t{\r\n\t\t\tnum15 |= 0x8000000;\r\n\t\t}\r\n\t\tif (flag6 && net.group != null && hitEntity.net != null && hitEntity.net.group != null && !net.subscriber.IsSubscribed(hitEntity.net.group))\r\n\t\t{\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Entity out of network range\");\r\n\t\t\tstats.combat.LogInvalid(hitInfo, \"projectile_network_range\");\r\n\t\t\tflag9 = false;\r\n\t\t}\r\n\t\tif (flag && hitInfo.boneArea == (HitArea)(-1))\r\n\t\t{\r\n\t\t\tstring text = hitInfo.ProjectilePrefab.name;\r\n\t\t\tstring text2 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Bone is invalid (\" + text + \" on \" + text2 + \" bone \" + hitInfo.HitBone + \")\");\r\n\t\t\tstats.combat.LogInvalid(hitInfo, \"projectile_bone\");\r\n\t\t\tflag9 = false;\r\n\t\t}\r\n\t\tif (flag8)\r\n\t\t{\r\n\t\t\tif (flag6)\r\n\t\t\t{\r\n\t\t\t\tstring text3 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\tstring text4 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Projectile water hit on entity (\" + text3 + \" on \" + text4 + \")\");\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \"water_entity\");\r\n\t\t\t\tflag9 = false;\r\n\t\t\t}\r\n\t\t\tif (!WaterLevel.Test(hitInfo.HitPositionWorld - 0.5f * UnityEngine.Vector3.up, waves: true, volumes: true, this))\r\n\t\t\t{\r\n\t\t\t\tstring text5 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\tstring text6 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Projectile water level (\" + text5 + \" on \" + text6 + \")\");\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \"water_level\");\r\n\t\t\t\tflag9 = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (value.protection >= 2)\r\n\t\t{\r\n\t\t\tif (flag6 || (value.protection < 6 && flag))\r\n\t\t\t{\r\n\t\t\t\tfloat num16 = hitEntity.MaxVelocity() + hitEntity.GetParentVelocity().magnitude;\r\n\t\t\t\tfloat num17 = hitEntity.BoundsPadding() + num12 * num16;\r\n\t\t\t\tfloat num18 = (value.entityDistance = hitEntity.Distance(hitInfo.HitPositionWorld));\r\n\t\t\t\tif (num18 > num17)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring text7 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\t\tstring shortPrefabName = hitEntity.ShortPrefabName;\r\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Entity too far away (\" + text7 + \" on \" + shortPrefabName + \" with \" + num18 + \"m > \" + num17 + \"m in \" + num12 + \"s)\");\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \"entity_distance\");\r\n\t\t\t\t\tflag9 = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value.protection >= 6 && flag9 && flag && !flag7 && !flag2 && !flag3 && !flag4 && !flag5)\r\n\t\t\t{\r\n\t\t\t\tfloat magnitude = basePlayer.GetParentVelocity().magnitude;\r\n\t\t\t\tfloat num19 = basePlayer.BoundsPadding() + num12 * magnitude + ConVar.AntiHack.tickhistoryforgiveness;\r\n\t\t\t\tfloat num20 = (value.entityDistance = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld));\r\n\t\t\t\tif (num20 > num19)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring text8 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\t\tstring shortPrefabName2 = basePlayer.ShortPrefabName;\r\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Player too far away (\" + text8 + \" on \" + shortPrefabName2 + \" with \" + num20 + \"m > \" + num19 + \"m in \" + num12 + \"s)\");\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \"player_distance\");\r\n\t\t\t\t\tflag9 = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (value.protection >= 1)\r\n\t\t{\r\n\t\t\tfloat num21 = (flag6 ? (hitEntity.MaxVelocity() + hitEntity.GetParentVelocity().magnitude) : 0f);\r\n\t\t\tfloat num22 = (flag6 ? (num12 * num21) : 0f);\r\n\t\t\tfloat magnitude2 = value.initialVelocity.magnitude;\r\n\t\t\tfloat num23 = hitInfo.ProjectilePrefab.initialDistance + num11 * magnitude2;\r\n\t\t\tfloat num24 = hitInfo.ProjectileDistance + 1f + positionOffset.magnitude + num22 + estimatedVelocity.magnitude;\r\n\t\t\tif (num14 > num23)\r\n\t\t\t{\r\n\t\t\t\tstring text9 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\tstring text10 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Projectile too fast (\" + text9 + \" on \" + text10 + \" with \" + num14 + \"m > \" + num23 + \"m in \" + num11 + \"s)\");\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \"projectile_maxspeed\");\r\n\t\t\t\tflag9 = false;\r\n\t\t\t}\r\n\t\t\tif (num14 > num24)\r\n\t\t\t{\r\n\t\t\t\tstring text11 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\tstring text12 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Projectile too far away (\" + text11 + \" on \" + text12 + \" with \" + num14 + \"m > \" + num24 + \"m in \" + num11 + \"s)\");\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \"projectile_distance\");\r\n\t\t\t\tflag9 = false;\r\n\t\t\t}\r\n\t\t\tif (num7 > ConVar.AntiHack.projectile_desync)\r\n\t\t\t{\r\n\t\t\t\tstring text13 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\tstring text14 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Projectile desync (\" + text13 + \" on \" + text14 + \" with \" + num7 + \"s > \" + ConVar.AntiHack.projectile_desync + \"s)\");\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \"projectile_desync\");\r\n\t\t\t\tflag9 = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (value.protection >= 4)\r\n\t\t{\r\n\t\t\tfloat num25 = 0f;\r\n\t\t\tif (flag6)\r\n\t\t\t{\r\n\t\t\t\tfloat num26 = hitEntity.GetParentVelocity().magnitude;\r\n\t\t\t\tif (hitEntity is CargoShip || hitEntity is Tugboat)\r\n\t\t\t\t{\r\n\t\t\t\t\tnum26 += hitEntity.MaxVelocity();\r\n\t\t\t\t}\r\n\t\t\t\tnum25 = num12 * num26;\r\n\t\t\t}\r\n\t\t\tSimulateProjectile(ref position, ref velocity, ref partialTime, num - travelTime, gravity, drag, out var prevPosition, out var prevVelocity);\r\n\t\t\tLine line = new Line(prevPosition - prevVelocity, position + prevVelocity);\r\n\t\t\tfloat num27 = (value.startPointMismatch = UnityEngine.Mathf.Max(line.Distance(hitInfo.PointStart) - initialPositionOffset.magnitude - num25, 0f));\r\n\t\t\tfloat num28 = (value.endPointMismatch = UnityEngine.Mathf.Max(line.Distance(hitInfo.HitPositionWorld) - initialPositionOffset.magnitude - num25, 0f));\r\n\t\t\tif (num27 > ConVar.AntiHack.projectile_trajectory)\r\n\t\t\t{\r\n\t\t\t\tstring text15 = value.projectilePrefab.name;\r\n\t\t\t\tstring text16 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Start position trajectory (\" + text15 + \" on \" + text16 + \" with \" + num27 + \"m > \" + ConVar.AntiHack.projectile_trajectory + \"m)\");\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \"trajectory_start\");\r\n\t\t\t\tflag9 = false;\r\n\t\t\t}\r\n\t\t\tif (num28 > ConVar.AntiHack.projectile_trajectory)\r\n\t\t\t{\r\n\t\t\t\tstring text17 = value.projectilePrefab.name;\r\n\t\t\t\tstring text18 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"End position trajectory (\" + text17 + \" on \" + text18 + \" with \" + num28 + \"m > \" + ConVar.AntiHack.projectile_trajectory + \"m)\");\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \"trajectory_end\");\r\n\t\t\t\tflag9 = false;\r\n\t\t\t}\r\n\t\t\tif (hitInfo.ProjectileTrajectoryMismatch > ConVar.AntiHack.projectile_trajectory_update)\r\n\t\t\t{\r\n\t\t\t\tstring text19 = value.projectilePrefab.name;\r\n\t\t\t\tstring text20 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Update position trajectory (\" + text19 + \" on \" + text20 + \" with \" + hitInfo.ProjectileTrajectoryMismatch + \"m > \" + ConVar.AntiHack.projectile_trajectory + \"m)\");\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \"trajectory_update_total\");\r\n\t\t\t\tflag9 = false;\r\n\t\t\t}\r\n\t\t\thitInfo.ProjectileVelocity = velocity;\r\n\t\t\tif (playerProjectileAttack.hitVelocity != UnityEngine.Vector3.zero && velocity != UnityEngine.Vector3.zero)\r\n\t\t\t{\r\n\t\t\t\tfloat num29 = UnityEngine.Vector3.Angle(playerProjectileAttack.hitVelocity, velocity);\r\n\t\t\t\tfloat num30 = playerProjectileAttack.hitVelocity.magnitude / velocity.magnitude;\r\n\t\t\t\tif (num29 > ConVar.AntiHack.projectile_anglechange)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring text21 = value.projectilePrefab.name;\r\n\t\t\t\t\tstring text22 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Trajectory angle change (\" + text21 + \" on \" + text22 + \" with \" + num29 + \"deg > \" + ConVar.AntiHack.projectile_anglechange + \"deg)\");\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \"angle_change\");\r\n\t\t\t\t\tflag9 = false;\r\n\t\t\t\t}\r\n\t\t\t\tif (num30 > ConVar.AntiHack.projectile_velocitychange)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring text23 = value.projectilePrefab.name;\r\n\t\t\t\t\tstring text24 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Trajectory velocity change (\" + text23 + \" on \" + text24 + \" with \" + num30 + \" > \" + ConVar.AntiHack.projectile_velocitychange + \")\");\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \"velocity_change\");\r\n\t\t\t\t\tflag9 = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfloat magnitude3 = velocity.magnitude;\r\n\t\t\tfloat num31 = num13 * magnitude3;\r\n\t\t\tif (num14 < num31)\r\n\t\t\t{\r\n\t\t\t\tstring text25 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\tstring text26 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Projectile too slow (\" + text25 + \" on \" + text26 + \" with \" + num14 + \"m < \" + num31 + \"m in \" + num13 + \"s)\");\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \"projectile_minspeed\");\r\n\t\t\t\tflag9 = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (value.protection >= 3)\r\n\t\t{\r\n\t\t\tposition2 = value.position;\r\n\t\t\tpointStart = hitInfo.PointStart;\r\n\t\t\thitPositionWorld = hitInfo.HitPositionWorld;\r\n\t\t\tif (!flag8)\r\n\t\t\t{\r\n\t\t\t\thitPositionWorld -= hitInfo.ProjectileVelocity.normalized * 0.001f;\r\n\t\t\t}\r\n\t\t\tvector = hitInfo.PositionOnRay(hitPositionWorld);\r\n\t\t\tUnityEngine.Vector3 vector2 = UnityEngine.Vector3.zero;\r\n\t\t\tUnityEngine.Vector3 vector3 = UnityEngine.Vector3.zero;\r\n\t\t\tif (ConVar.AntiHack.projectile_backtracking > 0f)\r\n\t\t\t{\r\n\t\t\t\tvector2 = (pointStart - position2).normalized * ConVar.AntiHack.projectile_backtracking;\r\n\t\t\t\tvector3 = (vector - pointStart).normalized * ConVar.AntiHack.projectile_backtracking;\r\n\t\t\t}\r\n\t\t\tflag10 = GamePhysics.LineOfSight(position2 - vector2, pointStart + vector2, num15, value.lastEntityHit) && GamePhysics.LineOfSight(pointStart - vector3, vector, num15, value.lastEntityHit) && GamePhysics.LineOfSight(vector, hitPositionWorld, num15, value.lastEntityHit);\r\n\t\t\tbool flag11 = true;\r\n\t\t\tif (flag10)\r\n\t\t\t{\r\n\t\t\t\tflag11 = GamePhysics.LineOfSight(position2, hitPositionWorld, num15, value.lastEntityHit) && GamePhysics.LineOfSight(hitPositionWorld, position2, num15, value.lastEntityHit);\r\n\t\t\t}\r\n\t\t\tbool flag12 = true;\r\n\t\t\tif (flag10)\r\n\t\t\t{\r\n\t\t\t\tSystem.Collections.Generic.List<UnityEngine.Vector3> simulatedPositions = value.simulatedPositions;\r\n\t\t\t\tif (simulatedPositions.Count > ConVar.AntiHack.projectile_update_limit)\r\n\t\t\t\t{\r\n\t\t\t\t\tflag12 = false;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tsimulatedPositions.Add(position2);\r\n\t\t\t\t\tfor (int i = 1; i < simulatedPositions.Count; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!GamePhysics.LineOfSight(simulatedPositions[i - 1], simulatedPositions[i], num15, value.lastEntityHit) || !GamePhysics.LineOfSight(simulatedPositions[i], simulatedPositions[i - 1], num15, value.lastEntityHit))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tflag12 = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (flag10)\r\n\t\t\t{\r\n\t\t\t\tif (!(value.simulatedPositions.Count > 1 && flag12))\r\n\t\t\t\t{\r\n\t\t\t\t\tnum32 = ((value.simulatedPositions.Count <= 1 && flag11) ? 1 : 0);\r\n\t\t\t\t\tif (num32 == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgoto IL_12c5;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tnum32 = 1;\r\n\t\t\t\t}\r\n\t\t\t\tstats.Add(\"hit_\" + (flag6 ? hitEntity.Categorize() : \"world\") + \"_direct_los\", 1, Stats.Server);\r\n\t\t\t\tgoto IL_1323;\r\n\t\t\t}\r\n\t\t\tnum32 = 0;\r\n\t\t\tgoto IL_12c5;\r\n\t\t}\r\n\t\tgoto IL_1595;\r\n\t}\r\n\tgoto IL_15ae;\r\n\tIL_15ae:\r\n\tvalue.position = hitInfo.HitPositionWorld;\r\n\tvalue.velocity = playerProjectileAttack.hitVelocity;\r\n\tvalue.travelTime = num;\r\n\tvalue.partialTime = partialTime;\r\n\tvalue.hits++;\r\n\tvalue.lastEntityHit = hitEntity;\r\n\tvalue.simulatedPositions.Clear();\r\n\tvalue.simulatedPositions.Add(position);\r\n\thitInfo.ProjectilePrefab.CalculateDamage(hitInfo, value.projectileModifier, value.integrity);\r\n\tif (flag8)\r\n\t{\r\n\t\tif (hitInfo.ProjectilePrefab.waterIntegrityLoss > 0f)\r\n\t\t{\r\n\t\t\tvalue.integrity = UnityEngine.Mathf.Clamp01(value.integrity - hitInfo.ProjectilePrefab.waterIntegrityLoss);\r\n\t\t}\r\n\t}\r\n\telse if (hitInfo.ProjectilePrefab.penetrationPower <= 0f || !flag6)\r\n\t{\r\n\t\tvalue.integrity = 0f;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfloat num33 = hitEntity.PenetrationResistance(hitInfo) / hitInfo.ProjectilePrefab.penetrationPower;\r\n\t\tvalue.integrity = UnityEngine.Mathf.Clamp01(value.integrity - num33);\r\n\t}\r\n\tif (flag6)\r\n\t{\r\n\t\tstats.Add(value.itemMod.category + \"_hit_\" + hitEntity.Categorize(), 1);\r\n\t}\r\n\tif (value.integrity <= 0f)\r\n\t{\r\n\t\tif (hitInfo.ProjectilePrefab.remainInWorld)\r\n\t\t{\r\n\t\t\tCreateWorldProjectile(hitInfo, value.itemDef, value.itemMod, hitInfo.ProjectilePrefab, value.pickupItem);\r\n\t\t}\r\n\t\tif (value.hits <= ConVar.AntiHack.projectile_impactspawndepth)\r\n\t\t{\r\n\t\t\tvalue.itemMod.ServerProjectileHit(hitInfo);\r\n\t\t}\r\n\t}\r\n\telse if (value.hits == ConVar.AntiHack.projectile_impactspawndepth)\r\n\t{\r\n\t\tvalue.itemMod.ServerProjectileHit(hitInfo);\r\n\t}\r\n\tfiredProjectiles[playerAttack.projectileID] = value;\r\n\tif (flag6)\r\n\t{\r\n\t\tif (value.hits <= ConVar.AntiHack.projectile_damagedepth)\r\n\t\t{\r\n\t\t\thitEntity.OnAttacked(hitInfo);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstats.combat.LogInvalid(hitInfo, \"ricochet\");\r\n\t\t}\r\n\t}\r\n\tProjectile.CustomEffectData clientEffectData = value.projectilePrefab.clientEffectData;\r\n\tbool playDefaultHitEffects = value.projectilePrefab.playDefaultHitEffects;\r\n\tGameObjectRef clientEffectPrefab = value.projectilePrefab.clientEffectPrefab;\r\n\tif (!clientEffectData.UseCustomEffect || playDefaultHitEffects)\r\n\t{\r\n\t\tEffect.server.ImpactEffect(hitInfo);\r\n\t}\r\n\tif (clientEffectData.UseCustomEffect)\r\n\t{\r\n\t\tstring text27 = null;\r\n\t\tif (clientEffectPrefab != null && clientEffectPrefab.isValid)\r\n\t\t{\r\n\t\t\ttext27 = clientEffectPrefab.resourcePath;\r\n\t\t}\r\n\t\tif (text27 != null)\r\n\t\t{\r\n\t\t\tEffect.server.ImpactEffect(hitInfo, text27);\r\n\t\t}\r\n\t}\r\n\thitInfo.DoHitEffects = hitInfo.ProjectilePrefab.doDefaultHitEffects;\r\n\tSingletonComponent<NpcNoiseManager>.Instance.OnProjectileHit(this, hitInfo);\r\n\tplayerProjectileAttack.ResetToPool();\r\n\tplayerProjectileAttack = null;\r\n\treturn;\r\n\tIL_12c5:\r\n\tstats.Add(\"hit_\" + (flag6 ? hitEntity.Categorize() : \"world\") + \"_indirect_los\", 1, Stats.Server);\r\n\tgoto IL_1323;\r\n\tIL_1323:\r\n\tif (num32 == 0)\r\n\t{\r\n\t\tstring text28 = hitInfo.ProjectilePrefab.name;\r\n\t\tstring text29 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\tstring description = ((!flag10) ? \"projectile_los\" : \"projectile_los_detailed\");\r\n\t\tstring[] obj = new string[12]\r\n\t\t{\r\n\t\t\t\"Line of sight (\", text28, \" on \", text29, \") \", null, null, null, null, null,\r\n\t\t\tnull, null\r\n\t\t};\r\n\t\tUnityEngine.Vector3 vector4 = position2;\r\n\t\tobj[5] = vector4.ToString();\r\n\t\tobj[6] = \" \";\r\n\t\tvector4 = pointStart;\r\n\t\tobj[7] = vector4.ToString();\r\n\t\tobj[8] = \" \";\r\n\t\tvector4 = vector;\r\n\t\tobj[9] = vector4.ToString();\r\n\t\tobj[10] = \" \";\r\n\t\tvector4 = hitPositionWorld;\r\n\t\tobj[11] = vector4.ToString();\r\n\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(obj));\r\n\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\tstats.combat.LogInvalid(hitInfo, description);\r\n\t\tflag9 = false;\r\n\t}\r\n\tif (flag9 && flag && !flag7)\r\n\t{\r\n\t\tUnityEngine.Vector3 hitPositionWorld2 = hitInfo.HitPositionWorld;\r\n\t\tUnityEngine.Vector3 position3 = basePlayer.eyes.position;\r\n\t\tUnityEngine.Vector3 vector5 = basePlayer.CenterPoint();\r\n\t\tfloat projectile_losforgiveness = ConVar.AntiHack.projectile_losforgiveness;\r\n\t\tbool flag13 = GamePhysics.LineOfSight(hitPositionWorld2, position3, num15, 0f, projectile_losforgiveness) && GamePhysics.LineOfSight(position3, hitPositionWorld2, num15, projectile_losforgiveness, 0f);\r\n\t\tif (!flag13)\r\n\t\t{\r\n\t\t\tflag13 = GamePhysics.LineOfSight(hitPositionWorld2, vector5, num15, 0f, projectile_losforgiveness) && GamePhysics.LineOfSight(vector5, hitPositionWorld2, num15, projectile_losforgiveness, 0f);\r\n\t\t}\r\n\t\tif (!flag13)\r\n\t\t{\r\n\t\t\tstring text30 = hitInfo.ProjectilePrefab.name;\r\n\t\t\tstring text31 = (flag6 ? hitEntity.ShortPrefabName : \"world\");\r\n\t\t\tstring[] obj2 = new string[12]\r\n\t\t\t{\r\n\t\t\t\t\"Line of sight (\", text30, \" on \", text31, \") \", null, null, null, null, null,\r\n\t\t\t\tnull, null\r\n\t\t\t};\r\n\t\t\tUnityEngine.Vector3 vector4 = hitPositionWorld2;\r\n\t\t\tobj2[5] = vector4.ToString();\r\n\t\t\tobj2[6] = \" \";\r\n\t\t\tvector4 = position3;\r\n\t\t\tobj2[7] = vector4.ToString();\r\n\t\t\tobj2[8] = \" or \";\r\n\t\t\tvector4 = hitPositionWorld2;\r\n\t\t\tobj2[9] = vector4.ToString();\r\n\t\t\tobj2[10] = \" \";\r\n\t\t\tvector4 = vector5;\r\n\t\t\tobj2[11] = vector4.ToString();\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(obj2));\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\r\n\t\t\tstats.combat.LogInvalid(hitInfo, \"projectile_los\");\r\n\t\t\tflag9 = false;\r\n\t\t}\r\n\t}\r\n\tgoto IL_1595;\r\n\tIL_1595:\r\n\tif (!flag9)\r\n\t{\r\n\t\tAntiHack.AddViolation(this, AntiHackType.ProjectileHack, ConVar.AntiHack.projectile_penalty);\r\n\t\tplayerProjectileAttack.ResetToPool();\r\n\t\tplayerProjectileAttack = null;\r\n\t\treturn;\r\n\t}\r\n\tgoto IL_15ae;\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnProjectileAttack",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerSleepEnd",
    "fullName": "OnPlayerSleepEnd",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void EndSleeping()\r\n{\r\n\tif (IsSleeping())\r\n\t{\r\n\t\tif (IsRestrained)\r\n\t\t{\r\n\t\t\tinventory.SetLockedByRestraint(flag: true);\r\n\t\t}\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, b: false);\r\n\t\tsleepStartTime = -1f;\r\n\t\tsleepingPlayerList.Remove(this);\r\n\t\tif ((ulong)userID < 10000000 && !bots.Contains(this))\r\n\t\t{\r\n\t\t\tbots.Add(this);\r\n\t\t}\r\n\t\tCancelInvoke(ScheduledDeath);\r\n\t\tInvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));\r\n\t\tif (RelationshipManager.TeamsEnabled())\r\n\t\t{\r\n\t\t\tInvokeRandomized(TeamUpdate, 1f, 4f, 1f);\r\n\t\t}\r\n\t\tInvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);\r\n\t\tEnablePlayerCollider();\r\n\t\tAddPlayerRigidbody();\r\n\t\tSetServerFall(wantsOn: false);\r\n\t\tif (HasParent())\r\n\t\t{\r\n\t\t\tSetParent(null, worldPositionStays: true);\r\n\t\t\tRemoveFromTriggers();\r\n\t\t\tForceUpdateTriggers();\r\n\t\t}\r\n\t\tinventory.containerMain.OnChanged();\r\n\t\tinventory.containerBelt.OnChanged();\r\n\t\tinventory.containerWear.OnChanged();\r\n\t\tEACServer.LogPlayerSpawn(this);\r\n\t\tif (TotalPingCount > 0)\r\n\t\t{\r\n\t\t\tSendPingsToClient();\r\n\t\t}\r\n\t\tif (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.Player(\"PromptToStartTutorial\", this));\r\n\t\t}\r\n\t\tif (AntiHack.TestNoClipping(this, base.transform.position, base.transform.position, NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _))\r\n\t\t{\r\n\t\t\tForceCastNoClip();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "EndSleeping",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerTick",
    "fullName": "OnPlayerTick",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)\r\n{\r\n\tif (msg.inputState != null)\r\n\t{\r\n\t\tserverInput.Flip(msg.inputState);\r\n\t}\r\n\tif (serverInput.current.buttons != serverInput.previous.buttons)\r\n\t{\r\n\t\tResetInputIdleTime();\r\n\t}\r\n\tif (IsReceivingSnapshot)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (IsSpectating())\r\n\t{\r\n\t\tusing (TimeWarning.New(\"Tick_Spectator\"))\r\n\t\t{\r\n\t\t\tTick_Spectator();\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (IsDead())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (IsSleeping())\r\n\t{\r\n\t\tif (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))\r\n\t\t{\r\n\t\t\tEndSleeping();\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t}\r\n\t\tUpdateActiveItem(default(ItemId));\r\n\t\treturn;\r\n\t}\r\n\tif (IsRestrained && restraintItemId.HasValue && restraintItemId.HasValue)\r\n\t{\r\n\t\tUpdateActiveItem(restraintItemId.Value);\r\n\t}\r\n\telse if (!Belt.CanHoldItem())\r\n\t{\r\n\t\tUpdateActiveItem(default(ItemId));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tUpdateActiveItem(msg.activeItem);\r\n\t}\r\n\tUpdateModelStateFromTick(msg);\r\n\tif (float.IsNaN(modelState.ducking) || float.IsInfinity(modelState.ducking))\r\n\t{\r\n\t\tKick(\"Kicked: invalid modelstate\");\r\n\t\treturn;\r\n\t}\r\n\tmodelState.ducking = UnityEngine.Mathf.Clamp01(modelState.ducking);\r\n\tif (IsIncapacitated())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (isMounted)\r\n\t{\r\n\t\tGetMounted().PlayerServerInput(serverInput, this);\r\n\t}\r\n\tUpdatePositionFromTick(msg, wasPlayerStalled);\r\n\tUpdateRotationFromTick(msg);\r\n\tint activeMission = GetActiveMission();\r\n\tif (activeMission >= 0 && activeMission < missions.Count)\r\n\t{\r\n\t\tBaseMission.MissionInstance missionInstance = missions[activeMission];\r\n\t\tif (missionInstance.status == BaseMission.MissionStatus.Active && missionInstance.NeedsPlayerInput())\r\n\t\t{\r\n\t\t\tProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);\r\n\t\t}\r\n\t}\r\n\tif (!TutorialIsland.EnforceTrespassChecks || IsAdmin || IsNpc || net == null || net.group == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (net.group.restricted)\r\n\t{\r\n\t\tbool flag = false;\r\n\t\tif (!IsInTutorial)\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tTutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();\r\n\t\t\tif (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\ttutorialKickTime += UnityEngine.Time.deltaTime;\r\n\t\t\tif (tutorialKickTime > 3f)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning($\"Killing player {displayName}/{userID.Get()} as they are on a tutorial island that doesn't belong them\");\r\n\t\t\t\tHurt(999f);\r\n\t\t\t\ttutorialKickTime = 0f;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ttutorialKickTime = 0f;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!IsInTutorial || net.group.restricted)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag2 = false;\r\n\t\tTutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();\r\n\t\tif (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)\r\n\t\t{\r\n\t\t\tflag2 = true;\r\n\t\t}\r\n\t\tif (flag2)\r\n\t\t{\r\n\t\t\ttutorialKickTime += UnityEngine.Time.deltaTime;\r\n\t\t\tif (tutorialKickTime > 3f)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning($\"Killing player {displayName}/{userID.Get()} as they are no longer on a tutorial island and are marked as being in a tutorial\");\r\n\t\t\t\tHurt(999f);\r\n\t\t\t\ttutorialKickTime = 0f;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ttutorialKickTime = 0f;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnReceiveTick",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "IOnBasePlayerAttacked",
    "fullName": "IOnBasePlayerAttacked",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnAttacked(HitInfo info)\r\n{\r\n\tfloat oldHealth = base.health;\r\n\tif (InSafeZone() && !IsHostile() && info.Initiator != null && info.Initiator != this)\r\n\t{\r\n\t\tinfo.damageTypes.ScaleAll(0f);\r\n\t}\r\n\tif (base.isServer)\r\n\t{\r\n\t\tHitArea boneArea = info.boneArea;\r\n\t\tif (boneArea != (HitArea)(-1))\r\n\t\t{\r\n\t\t\tSystem.Collections.Generic.List<Item> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Item>>();\r\n\t\t\tobj.AddRange(inventory.containerWear.itemList);\r\n\t\t\tfor (int i = 0; i < obj.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tItem item = obj[i];\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tItemModWearable component = item.info.GetComponent<ItemModWearable>();\r\n\t\t\t\t\tif (!(component == null) && component.ProtectsArea(boneArea))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem.OnAttacked(info);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\r\n\t\t\tinventory.ServerUpdate(0f);\r\n\t\t}\r\n\t}\r\n\tbase.OnAttacked(info);\r\n\tif (base.isServer && base.isServer && info.hasDamage)\r\n\t{\r\n\t\tif (!info.damageTypes.Has(Rust.DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortalTo(info))\r\n\t\t{\r\n\t\t\tfloat num = ((modifiers != null) ? UnityEngine.Mathf.Clamp01(1f - modifiers.GetValue(Modifier.ModifierType.Clotting)) : 1f);\r\n\t\t\tmetabolism.bleeding.Add(info.damageTypes.Total() * 0.2f * num);\r\n\t\t}\r\n\t\tif (isMounted)\r\n\t\t{\r\n\t\t\tGetMounted().MounteeTookDamage(this, info);\r\n\t\t}\r\n\t\tCheckDeathCondition(info);\r\n\t\tif (net != null && net.connection != null)\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.Player(\"TakeDamageHit\", this));\r\n\t\t}\r\n\t\tstring text = StringPool.Get(info.HitBone);\r\n\t\tbool flag = UnityEngine.Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) > 0.4f;\r\n\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\r\n\t\tif ((bool)initiatorPlayer && !info.damageTypes.IsMeleeType())\r\n\t\t{\r\n\t\t\tinitiatorPlayer.LifeStoryShotHit(info.Weapon);\r\n\t\t}\r\n\t\tif (info.isHeadshot)\r\n\t\t{\r\n\t\t\tif (flag)\r\n\t\t\t{\r\n\t\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_RearHead, string.Empty);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_Head, string.Empty);\r\n\t\t\t}\r\n\t\t\tEffect.server.Run(\"assets/bundled/prefabs/fx/headshot.prefab\", this, 0u, new UnityEngine.Vector3(0f, 2f, 0f), UnityEngine.Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);\r\n\t\t\tif ((bool)initiatorPlayer)\r\n\t\t\t{\r\n\t\t\t\tinitiatorPlayer.stats.Add(\"headshot\", 1, (Stats)5);\r\n\t\t\t\tif (initiatorPlayer.IsBeingSpectated)\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (BaseEntity child in initiatorPlayer.children)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (child is BasePlayer basePlayer)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbasePlayer.ClientRPC(RpcTarget.Player(\"SpectatedPlayerHeadshot\", basePlayer));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (flag)\r\n\t\t{\r\n\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_RearTorso, string.Empty);\r\n\t\t}\r\n\t\telse if (text == \"spine\" || text == \"spine2\")\r\n\t\t{\r\n\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_Stomach, string.Empty);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_Chest, string.Empty);\r\n\t\t}\r\n\t}\r\n\tif (stats != null)\r\n\t{\r\n\t\tif (IsWounded())\r\n\t\t{\r\n\t\t\tstats.combat.LogAttack(info, \"wounded\", oldHealth);\r\n\t\t}\r\n\t\telse if (IsDead())\r\n\t\t{\r\n\t\t\tstats.combat.LogAttack(info, \"killed\", oldHealth);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstats.combat.LogAttack(info, \"\", oldHealth);\r\n\t\t}\r\n\t}\r\n\tif (ConVar.Global.cinematicGingerbreadCorpses)\r\n\t{\r\n\t\tinfo.HitMaterial = ConVar.Global.GingerbreadMaterialID();\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnAttacked",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "IOnBasePlayerHurt",
    "fullName": "IOnBasePlayerHurt",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void Hurt(HitInfo info)\r\n{\r\n\tif (IsDead() || IsTransferProtected() || (IsImmortalTo(info) && info.damageTypes.Total() >= 0f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool wasWounded = IsWounded();\r\n\tif (ConVar.Server.pve && !IsNpc && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)\r\n\t{\r\n\t\t(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), Rust.DamageType.Generic);\r\n\t\treturn;\r\n\t}\r\n\tif (info.damageTypes.Has(Rust.DamageType.Fun_Water))\r\n\t{\r\n\t\tbool flag = true;\r\n\t\tItem activeItem = GetActiveItem();\r\n\t\tif (activeItem != null && (activeItem.info.shortname == \"gun.water\" || activeItem.info.shortname == \"pistol.water\"))\r\n\t\t{\r\n\t\t\tfloat value = metabolism.wetness.value;\r\n\t\t\tmetabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);\r\n\t\t\tbool flag2 = metabolism.wetness.value >= ConVar.Server.funWaterDamageThreshold;\r\n\t\t\tflag = !flag2;\r\n\t\t\tif (info.InitiatorPlayer != null)\r\n\t\t\t{\r\n\t\t\t\tif (flag2 && value < ConVar.Server.funWaterDamageThreshold)\r\n\t\t\t\t{\r\n\t\t\t\t\tinfo.InitiatorPlayer.GiveAchievement(\"SUMMER_SOAKED\");\r\n\t\t\t\t}\r\n\t\t\t\tif (metabolism.radiation_level.Fraction() > 0.2f && !string.IsNullOrEmpty(\"SUMMER_RADICAL\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tinfo.InitiatorPlayer.GiveAchievement(\"SUMMER_RADICAL\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tinfo.damageTypes.Scale(Rust.DamageType.Fun_Water, 0f);\r\n\t\t}\r\n\t}\r\n\tif (info.damageTypes.Get(Rust.DamageType.Drowned) > 5f && drownEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(drownEffect.resourcePath, this, StringPool.Get(\"head\"), UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t}\r\n\tif (modifiers != null)\r\n\t{\r\n\t\tif (info.damageTypes.Has(Rust.DamageType.Radiation))\r\n\t\t{\r\n\t\t\tinfo.damageTypes.Scale(Rust.DamageType.Radiation, 1f - UnityEngine.Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));\r\n\t\t}\r\n\t\tif (info.damageTypes.Has(Rust.DamageType.RadiationExposure))\r\n\t\t{\r\n\t\t\tinfo.damageTypes.Scale(Rust.DamageType.RadiationExposure, 1f - UnityEngine.Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));\r\n\t\t}\r\n\t}\r\n\tmetabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);\r\n\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\r\n\tif ((bool)initiatorPlayer && initiatorPlayer != this)\r\n\t{\r\n\t\tif (initiatorPlayer.InSafeZone() || InSafeZone())\r\n\t\t{\r\n\t\t\tinitiatorPlayer.MarkHostileFor(300f);\r\n\t\t}\r\n\t\tif (initiatorPlayer.InSafeZone() && !initiatorPlayer.IsNpc)\r\n\t\t{\r\n\t\t\tinfo.damageTypes.ScaleAll(0f);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (initiatorPlayer.IsNpc && initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer && info.damageTypes.Get(Rust.DamageType.Explosion) > 0f)\r\n\t\t{\r\n\t\t\tinfo.damageTypes.ScaleAll(ConVar.Halloween.scarecrow_beancan_vs_player_dmg_modifier);\r\n\t\t}\r\n\t}\r\n\tbase.Hurt(info);\r\n\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\r\n\t{\r\n\t\tBasePlayer instigator = info?.InitiatorPlayer;\r\n\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerHurt(instigator, this, info);\r\n\t}\r\n\tif (IsRestrained && Rust.DamageTypeEx.InterruptsRestraintMinigame(info.damageTypes.GetMajorityDamageType()))\r\n\t{\r\n\t\tHandcuffs handcuffs = GetHeldEntity() as Handcuffs;\r\n\t\tif (handcuffs != null)\r\n\t\t{\r\n\t\t\thandcuffs.InterruptUnlockMiniGame(wasPushedOrDamaged: true);\r\n\t\t}\r\n\t}\r\n\tEACServer.LogPlayerTakeDamage(this, info, wasWounded);\r\n\tmetabolism.SendChangesToClient();\r\n\tif (info.PointStart != UnityEngine.Vector3.zero && (info.damageTypes.Total() >= 0f || IsGod()))\r\n\t{\r\n\t\tint arg = (int)info.damageTypes.GetMajorityDamageType();\r\n\t\tif (info.Weapon != null && info.damageTypes.Has(Rust.DamageType.Bullet))\r\n\t\t{\r\n\t\t\tBaseProjectile component = info.Weapon.GetComponent<BaseProjectile>();\r\n\t\t\tif (component != null && component.IsSilenced())\r\n\t\t\t{\r\n\t\t\t\targ = 12;\r\n\t\t\t}\r\n\t\t}\r\n\t\tClientRPC(RpcTarget.PlayerAndSpectators(\"DirectionalDamage\", this), info.PointStart, arg, UnityEngine.Mathf.CeilToInt(info.damageTypes.Total()));\r\n\t}\r\n\tBasePlayer.DeathBlow.From(info, out cachedNonSuicideHit);\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "Hurt",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanLootPlayer",
    "fullName": "CanLootPlayer",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool CanBeLooted(BasePlayer player)\r\n{\r\n\tif (player == this)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif ((IsWounded() || IsSleeping() || CurrentGestureIsSurrendering || IsRestrainedOrSurrendering) && !IsLoadingAfterTransfer())\r\n\t{\r\n\t\treturn !IsTransferring();\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "CanBeLooted",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeWounded",
    "fullName": "CanBeWounded",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool EligibleForWounding(HitInfo info)\r\n{\r\n\tif (!ConVar.Server.woundingenabled)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (IsWounded())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (IsSleeping())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (isMounted)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (info == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!IsWounded() && UnityEngine.Time.realtimeSinceStartup - lastWoundedStartTime < ConVar.Server.rewounddelay)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\r\n\tif ((bool)activeGameMode && !activeGameMode.allowWounding)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (triggers != null)\r\n\t{\r\n\t\tfor (int i = 0; i < triggers.Count; i++)\r\n\t\t{\r\n\t\t\tif (triggers[i] is IHurtTrigger)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (info.WeaponPrefab is BaseMelee)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (info.WeaponPrefab is BaseProjectile)\r\n\t{\r\n\t\treturn !info.isHeadshot;\r\n\t}\r\n\treturn info.damageTypes.GetMajorityDamageType() switch\r\n\t{\r\n\t\tRust.DamageType.Suicide => false, \r\n\t\tRust.DamageType.Fall => true, \r\n\t\tRust.DamageType.Bite => true, \r\n\t\tRust.DamageType.Bleeding => true, \r\n\t\tRust.DamageType.Hunger => true, \r\n\t\tRust.DamageType.Thirst => true, \r\n\t\tRust.DamageType.Poison => true, \r\n\t\t_ => false, \r\n\t};\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "EligibleForWounding",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPlayerRespawned",
    "fullName": "OnPlayerRespawned",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RespawnAt(UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, BaseEntity spawnPointEntity = null)\r\n{\r\n\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\r\n\tif ((bool)activeGameMode && !activeGameMode.CanPlayerRespawn(this))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Wounded, b: false);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Unused2, b: false);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Unused1, b: false);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.DisplaySash, b: false);\r\n\trespawnId = System.Guid.NewGuid().ToString(\"N\");\r\n\tServerPerformance.spawns++;\r\n\tSetParent(null, worldPositionStays: true);\r\n\tbase.transform.SetPositionAndRotation(position, rotation);\r\n\ttickInterpolator.Reset(position);\r\n\ttickHistory.Reset(position);\r\n\teyeHistory.Clear();\r\n\testimatedVelocity = UnityEngine.Vector3.zero;\r\n\testimatedSpeed = 0f;\r\n\testimatedSpeed2D = 0f;\r\n\tlastTickTime = 0f;\r\n\tStopWounded();\r\n\tResetWoundingVars();\r\n\tStopSpectating();\r\n\tUpdateNetworkGroup();\r\n\tEnablePlayerCollider();\r\n\tRemovePlayerRigidbody();\r\n\tStartSleeping();\r\n\tLifeStoryStart();\r\n\tmetabolism.Reset();\r\n\tif (modifiers != null)\r\n\t{\r\n\t\tmodifiers.RemoveAll();\r\n\t}\r\n\tInitializeHealth(StartHealth(), StartMaxHealth());\r\n\tbool flag = false;\r\n\tif (ConVar.Server.respawnWithLoadout)\r\n\t{\r\n\t\tstring infoString = GetInfoString(\"client.respawnloadout\", string.Empty);\r\n\t\tif (!string.IsNullOrEmpty(infoString) && ConVar.Inventory.LoadLoadout(infoString, out var so))\r\n\t\t{\r\n\t\t\tso.LoadItemsOnTo(this);\r\n\t\t\tflag = true;\r\n\t\t}\r\n\t}\r\n\tif (!flag)\r\n\t{\r\n\t\tinventory.GiveDefaultItems();\r\n\t}\r\n\tSendNetworkUpdateImmediate();\r\n\tClientRPC(RpcTarget.Player(\"StartLoading\", this));\r\n\tFacepunch.Rust.Analytics.Azure.OnPlayerRespawned(this, spawnPointEntity);\r\n\tif ((bool)activeGameMode)\r\n\t{\r\n\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);\r\n\t}\r\n\tif (IsConnected)\r\n\t{\r\n\t\tEACServer.OnStartLoading(net.connection);\r\n\t}\r\n\tProcessMissionEvent(BaseMission.MissionEventType.RESPAWN, 0, 0f);\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "RespawnAt",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerSpectate",
    "fullName": "OnPlayerSpectate",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartSpectating()\r\n{\r\n\tif (!IsSpectating())\r\n\t{\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.Spectating, b: true);\r\n\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);\r\n\t\tCancelInvoke(InventoryUpdate);\r\n\t\tChatMessage(\"Becoming Spectator\");\r\n\t\tUpdateSpectateTarget(spectateFilter);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "StartSpectating",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerSpectateEnd",
    "fullName": "OnPlayerSpectateEnd",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StopSpectating()\r\n{\r\n\tif (IsSpectating())\r\n\t{\r\n\t\tSetParent(null);\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.Spectating, b: false);\r\n\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "StopSpectating",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerHealthChange",
    "fullName": "OnPlayerHealthChange",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "oldvalue",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "newvalue",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnHealthChanged(float oldvalue, float newvalue)\r\n{\r\n\tbase.OnHealthChanged(oldvalue, newvalue);\r\n\tif (base.isServer)\r\n\t{\r\n\t\tif (oldvalue > newvalue)\r\n\t\t{\r\n\t\t\tLifeStoryHurt(oldvalue - newvalue);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLifeStoryHeal(newvalue - oldvalue);\r\n\t\t}\r\n\t\tmetabolism.isDirty = true;\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnHealthChanged",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerSleep",
    "fullName": "OnPlayerSleep",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void StartSleeping()\r\n{\r\n\tif (!IsSleeping())\r\n\t{\r\n\t\tif (IsRestrained)\r\n\t\t{\r\n\t\t\tinventory.SetLockedByRestraint(flag: false);\r\n\t\t}\r\n\t\tif (InSafeZone() && !IsInvoking(ScheduledDeath))\r\n\t\t{\r\n\t\t\tInvoke(ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);\r\n\t\t}\r\n\t\tBaseMountable baseMountable = GetMounted();\r\n\t\tif (baseMountable != null && !AllowSleeperMounting(baseMountable))\r\n\t\t{\r\n\t\t\tEnsureDismounted();\r\n\t\t}\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, b: true);\r\n\t\tsleepStartTime = UnityEngine.Time.time;\r\n\t\tsleepingPlayerList.TryAdd(this);\r\n\t\tbots.Remove(this);\r\n\t\tCancelInvoke(InventoryUpdate);\r\n\t\tCancelInvoke(TeamUpdate);\r\n\t\tCancelInvoke(UpdateClanLastSeen);\r\n\t\tinventory.loot.Clear();\r\n\t\tinventory.containerMain.OnChanged();\r\n\t\tinventory.containerBelt.OnChanged();\r\n\t\tinventory.containerWear.OnChanged();\r\n\t\tEnablePlayerCollider();\r\n\t\tif (!IsLoadingAfterTransfer())\r\n\t\t{\r\n\t\t\tRemovePlayerRigidbody();\r\n\t\t\tTurnOffAllLights();\r\n\t\t}\r\n\t\tSetServerFall(wantsOn: true);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "StartSleeping",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerDeath",
    "fullName": "OnPlayerDeath",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void Die(HitInfo info = null)\r\n{\r\n\tusing (TimeWarning.New(\"Player.Die\"))\r\n\t{\r\n\t\tif (!IsDead())\r\n\t\t{\r\n\t\t\tHandcuffs restraintItem = Belt.GetRestraintItem();\r\n\t\t\tif (restraintItem != null)\r\n\t\t\t{\r\n\t\t\t\trestraintItem.HeldWhenOwnerDied(this);\r\n\t\t\t}\r\n\t\t\tif (InGesture)\r\n\t\t\t{\r\n\t\t\t\tServer_CancelGesture();\r\n\t\t\t}\r\n\t\t\tif (Belt != null && ShouldDropActiveItem())\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));\r\n\t\t\t\tBelt.DropActive(GetDropPosition(), GetInheritedDropVelocity() + vector.normalized * 3f);\r\n\t\t\t\tinventory.DropBackpackOnDeath();\r\n\t\t\t}\r\n\t\t\tif (!WoundInsteadOfDying(info))\r\n\t\t\t{\r\n\t\t\t\tSleepingBag.OnPlayerDeath(this);\r\n\t\t\t\tbase.Die(info);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "Die",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerRespawn",
    "fullName": "OnPlayerRespawn",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer+SpawnPoint, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Respawn()\r\n{\r\n\tBasePlayer.SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(this);\r\n\tif (ConVar.Server.respawnAtDeathPosition && ServerCurrentDeathNote != null)\r\n\t{\r\n\t\tspawnPoint.pos = ServerCurrentDeathNote.worldPosition;\r\n\t}\r\n\tRespawnAt(spawnPoint.pos, spawnPoint.rot);\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "Respawn",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerKicked",
    "fullName": "OnPlayerKicked",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Kick(string reason, bool reserveSlot = true)\r\n{\r\n\tif (IsConnected)\r\n\t{\r\n\t\tnet.connection.canReserveSlot = reserveSlot;\r\n\t\tNetwork.Net.sv.Kick(net.connection, reason);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "Kick",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanDropActiveItem",
    "fullName": "CanDropActiveItem",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool ShouldDropActiveItem()\r\n{\r\n\treturn true;\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "ShouldDropActiveItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnActiveItemChange",
    "fullName": "OnActiveItemChange",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "itemID",
        "type": "ItemId, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "#define UNITY_ASSERTIONS\r\npublic void UpdateActiveItem(ItemId itemID)\r\n{\r\n\tUnityEngine.Assertions.Assert.IsTrue(base.isServer, \"Realm should be server!\");\r\n\tif (svActiveItemID == itemID)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (equippingBlocked)\r\n\t{\r\n\t\titemID = default(ItemId);\r\n\t}\r\n\tItem item = inventory.containerBelt.FindItemByUID(itemID);\r\n\tif (IsItemHoldRestricted(item))\r\n\t{\r\n\t\titemID = default(ItemId);\r\n\t}\r\n\tItem activeItem = GetActiveItem();\r\n\tsvActiveItemID = default(ItemId);\r\n\tif (activeItem != null)\r\n\t{\r\n\t\tHeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;\r\n\t\tif (heldEntity != null)\r\n\t\t{\r\n\t\t\theldEntity.SetHeld(bHeld: false);\r\n\t\t}\r\n\t}\r\n\tsvActiveItemID = itemID;\r\n\tSendNetworkUpdate();\r\n\tItem activeItem2 = GetActiveItem();\r\n\tif (activeItem2 != null)\r\n\t{\r\n\t\tHeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;\r\n\t\tif (heldEntity2 != null)\r\n\t\t{\r\n\t\t\theldEntity2.SetHeld(bHeld: true);\r\n\t\t}\r\n\t\tNotifyGesturesNewItemEquipped();\r\n\t}\r\n\tinventory.UpdatedVisibleHolsteredItems();\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "UpdateActiveItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerVoice",
    "fullName": "OnPlayerVoice",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnReceivedVoice(byte[] data)\r\n{\r\n\tNetwork.NetWrite netWrite = Network.Net.sv.StartWrite();\r\n\tnetWrite.PacketID(Network.Message.Type.VoiceData);\r\n\tnetWrite.EntityID(net.ID);\r\n\tnetWrite.BytesWithSize(data);\r\n\tfloat num = 0f;\r\n\tif (HasPlayerFlag(BasePlayer.PlayerFlags.VoiceRangeBoost))\r\n\t{\r\n\t\tnum = ConVar.Voice.voiceRangeBoostAmount;\r\n\t}\r\n\tnetWrite.Send(new Network.SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f + num, addSecondaryConnections: true))\r\n\t{\r\n\t\tpriority = Network.Priority.Immediate\r\n\t});\r\n\tif (activeTelephone != null)\r\n\t{\r\n\t\tactiveTelephone.OnReceivedVoiceFromUser(data);\r\n\t}\r\n\tif (SingletonComponent<NpcNoiseManager>.Instance != null)\r\n\t{\r\n\t\tSingletonComponent<NpcNoiseManager>.Instance.OnVoiceChat(this);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnReceivedVoice",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerInput",
    "fullName": "OnPlayerInput",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)\r\n{\r\n\tif (msg.inputState != null)\r\n\t{\r\n\t\tserverInput.Flip(msg.inputState);\r\n\t}\r\n\tif (serverInput.current.buttons != serverInput.previous.buttons)\r\n\t{\r\n\t\tResetInputIdleTime();\r\n\t}\r\n\tif (IsReceivingSnapshot)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (IsSpectating())\r\n\t{\r\n\t\tusing (TimeWarning.New(\"Tick_Spectator\"))\r\n\t\t{\r\n\t\t\tTick_Spectator();\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (IsDead())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (IsSleeping())\r\n\t{\r\n\t\tif (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))\r\n\t\t{\r\n\t\t\tEndSleeping();\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t}\r\n\t\tUpdateActiveItem(default(ItemId));\r\n\t\treturn;\r\n\t}\r\n\tif (IsRestrained && restraintItemId.HasValue && restraintItemId.HasValue)\r\n\t{\r\n\t\tUpdateActiveItem(restraintItemId.Value);\r\n\t}\r\n\telse if (!Belt.CanHoldItem())\r\n\t{\r\n\t\tUpdateActiveItem(default(ItemId));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tUpdateActiveItem(msg.activeItem);\r\n\t}\r\n\tUpdateModelStateFromTick(msg);\r\n\tif (float.IsNaN(modelState.ducking) || float.IsInfinity(modelState.ducking))\r\n\t{\r\n\t\tKick(\"Kicked: invalid modelstate\");\r\n\t\treturn;\r\n\t}\r\n\tmodelState.ducking = UnityEngine.Mathf.Clamp01(modelState.ducking);\r\n\tif (IsIncapacitated())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (isMounted)\r\n\t{\r\n\t\tGetMounted().PlayerServerInput(serverInput, this);\r\n\t}\r\n\tUpdatePositionFromTick(msg, wasPlayerStalled);\r\n\tUpdateRotationFromTick(msg);\r\n\tint activeMission = GetActiveMission();\r\n\tif (activeMission >= 0 && activeMission < missions.Count)\r\n\t{\r\n\t\tBaseMission.MissionInstance missionInstance = missions[activeMission];\r\n\t\tif (missionInstance.status == BaseMission.MissionStatus.Active && missionInstance.NeedsPlayerInput())\r\n\t\t{\r\n\t\t\tProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);\r\n\t\t}\r\n\t}\r\n\tif (!TutorialIsland.EnforceTrespassChecks || IsAdmin || IsNpc || net == null || net.group == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (net.group.restricted)\r\n\t{\r\n\t\tbool flag = false;\r\n\t\tif (!IsInTutorial)\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tTutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();\r\n\t\t\tif (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\ttutorialKickTime += UnityEngine.Time.deltaTime;\r\n\t\t\tif (tutorialKickTime > 3f)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning($\"Killing player {displayName}/{userID.Get()} as they are on a tutorial island that doesn't belong them\");\r\n\t\t\t\tHurt(999f);\r\n\t\t\t\ttutorialKickTime = 0f;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ttutorialKickTime = 0f;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!IsInTutorial || net.group.restricted)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag2 = false;\r\n\t\tTutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();\r\n\t\tif (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)\r\n\t\t{\r\n\t\t\tflag2 = true;\r\n\t\t}\r\n\t\tif (flag2)\r\n\t\t{\r\n\t\t\ttutorialKickTime += UnityEngine.Time.deltaTime;\r\n\t\t\tif (tutorialKickTime > 3f)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning($\"Killing player {displayName}/{userID.Get()} as they are no longer on a tutorial island and are marked as being in a tutorial\");\r\n\t\t\t\tHurt(999f);\r\n\t\t\t\ttutorialKickTime = 0f;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ttutorialKickTime = 0f;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnReceiveTick",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLootPlayer",
    "fullName": "OnLootPlayer",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_LootPlayer(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif ((bool)player && player.CanInteract() && CanBeLooted(player) && player.inventory.loot.StartLootingEntity(this))\r\n\t{\r\n\t\tplayer.inventory.loot.AddContainer(inventory.containerMain);\r\n\t\tplayer.inventory.loot.AddContainer(inventory.containerWear);\r\n\t\tplayer.inventory.loot.AddContainer(inventory.containerBelt);\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tplayer.RadioactiveLootCheck(player.inventory.loot.containers);\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"RPC_OpenLootPanel\", player), \"player_corpse\");\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "RPC_LootPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerLand",
    "fullName": "OnPlayerLand",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ApplyFallDamageFromVelocity(float velocity)\r\n{\r\n\tif (IsGod())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = UnityEngine.Mathf.InverseLerp(-15f, -100f, velocity);\r\n\tif (num != 0f)\r\n\t{\r\n\t\tfloat num2 = ((modifiers != null) ? UnityEngine.Mathf.Clamp01(1f - modifiers.GetValue(Modifier.ModifierType.Clotting)) : 1f);\r\n\t\tmetabolism.bleeding.Add(num * 0.5f * num2);\r\n\t\tfloat num3 = num * 500f;\r\n\t\tFacepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num3);\r\n\t\tHurt(num3, Rust.DamageType.Fall);\r\n\t\tif (num3 > 20f && fallDamageEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "ApplyFallDamageFromVelocity",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerLanded",
    "fullName": "OnPlayerLanded",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ApplyFallDamageFromVelocity(float velocity)\r\n{\r\n\tif (IsGod())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = UnityEngine.Mathf.InverseLerp(-15f, -100f, velocity);\r\n\tif (num != 0f)\r\n\t{\r\n\t\tfloat num2 = ((modifiers != null) ? UnityEngine.Mathf.Clamp01(1f - modifiers.GetValue(Modifier.ModifierType.Clotting)) : 1f);\r\n\t\tmetabolism.bleeding.Add(num * 0.5f * num2);\r\n\t\tfloat num3 = num * 500f;\r\n\t\tFacepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num3);\r\n\t\tHurt(num3, Rust.DamageType.Fall);\r\n\t\tif (num3 > 20f && fallDamageEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "ApplyFallDamageFromVelocity",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanSpectateTarget",
    "fullName": "CanSpectateTarget",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "strName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateSpectateTarget(string strName)\r\n{\r\n\tspectateFilter = strName;\r\n\tSystem.Collections.Generic.IEnumerable<BaseEntity> enumerable = null;\r\n\tif (spectateFilter.StartsWith(\"@\"))\r\n\t{\r\n\t\tstring filter = spectateFilter.Substring(1);\r\n\t\tenumerable = System.Linq.Enumerable.Cast<BaseEntity>(System.Linq.Enumerable.Where(System.Linq.Enumerable.Where(BaseNetworkable.serverEntities, (BaseNetworkable x) => UnityEngine.StringEx.Contains(x.name, filter, System.Globalization.CompareOptions.IgnoreCase)), (BaseNetworkable x) => x != this));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tSystem.Collections.Generic.IEnumerable<BasePlayer> source = System.Linq.Enumerable.Where(activePlayerList, (BasePlayer x) => !x.IsSpectating() && !x.IsDead() && !x.IsSleeping());\r\n\t\tif (strName.Length > 0)\r\n\t\t{\r\n\t\t\tsource = System.Linq.Enumerable.Where(System.Linq.Enumerable.Where(source, (BasePlayer x) => UnityEngine.StringEx.Contains(x.displayName, spectateFilter, System.Globalization.CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)), (BasePlayer x) => x != this);\r\n\t\t}\r\n\t\tsource = System.Linq.Enumerable.OrderBy(source, (BasePlayer x) => x.displayName);\r\n\t\tenumerable = System.Linq.Enumerable.Cast<BaseEntity>(source);\r\n\t}\r\n\tBaseEntity[] array = System.Linq.Enumerable.ToArray(enumerable);\r\n\tif (array.Length == 0)\r\n\t{\r\n\t\tChatMessage(\"No valid spectate targets!\");\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity baseEntity = array[SpectateOffset % array.Length];\r\n\tif (baseEntity != null)\r\n\t{\r\n\t\tSpectatePlayer(baseEntity);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "UpdateSpectateTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerSetInfo",
    "fullName": "OnPlayerSetInfo",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "key",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "val",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void SetInfo(string key, string val)\r\n{\r\n\tif (IsConnected)\r\n\t{\r\n\t\tnet.connection.info.Set(key, val);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "SetInfo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerAssist",
    "fullName": "OnPlayerAssist",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Assist(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && !(msg.player == this) && IsWounded())\r\n\t{\r\n\t\tStopWounded(msg.player);\r\n\t\tmsg.player.stats.Add(\"wounded_assisted\", 1, (Stats)5);\r\n\t\tstats.Add(\"wounded_healed\", 1);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "RPC_Assist",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerKeepAlive",
    "fullName": "OnPlayerKeepAlive",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_KeepAlive(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && !(msg.player == this) && IsWounded())\r\n\t{\r\n\t\tProlongWounding(10f);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "RPC_KeepAlive",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnActiveItemChanged",
    "fullName": "OnActiveItemChanged",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "#define UNITY_ASSERTIONS\r\npublic void UpdateActiveItem(ItemId itemID)\r\n{\r\n\tUnityEngine.Assertions.Assert.IsTrue(base.isServer, \"Realm should be server!\");\r\n\tif (svActiveItemID == itemID)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (equippingBlocked)\r\n\t{\r\n\t\titemID = default(ItemId);\r\n\t}\r\n\tItem item = inventory.containerBelt.FindItemByUID(itemID);\r\n\tif (IsItemHoldRestricted(item))\r\n\t{\r\n\t\titemID = default(ItemId);\r\n\t}\r\n\tItem activeItem = GetActiveItem();\r\n\tsvActiveItemID = default(ItemId);\r\n\tif (activeItem != null)\r\n\t{\r\n\t\tHeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;\r\n\t\tif (heldEntity != null)\r\n\t\t{\r\n\t\t\theldEntity.SetHeld(bHeld: false);\r\n\t\t}\r\n\t}\r\n\tsvActiveItemID = itemID;\r\n\tSendNetworkUpdate();\r\n\tItem activeItem2 = GetActiveItem();\r\n\tif (activeItem2 != null)\r\n\t{\r\n\t\tHeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;\r\n\t\tif (heldEntity2 != null)\r\n\t\t{\r\n\t\t\theldEntity2.SetHeld(bHeld: true);\r\n\t\t}\r\n\t\tNotifyGesturesNewItemEquipped();\r\n\t}\r\n\tinventory.UpdatedVisibleHolsteredItems();\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "UpdateActiveItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMapMarkersClear",
    "fullName": "OnMapMarkersClear",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void Server_ClearMapMarkers(BaseEntity.RPCMessage msg)\r\n{\r\n\tServerCurrentDeathNote?.Dispose();\r\n\tServerCurrentDeathNote = null;\r\n\tif (State.pointsOfInterest != null)\r\n\t{\r\n\t\tforeach (ProtoBuf.MapNote item in State.pointsOfInterest)\r\n\t\t{\r\n\t\t\titem?.Dispose();\r\n\t\t}\r\n\t\tState.pointsOfInterest.Clear();\r\n\t}\r\n\tDirtyPlayerState();\r\n\tTeamUpdate();\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "Server_ClearMapMarkers",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMapMarkersCleared",
    "fullName": "OnMapMarkersCleared",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void Server_ClearMapMarkers(BaseEntity.RPCMessage msg)\r\n{\r\n\tServerCurrentDeathNote?.Dispose();\r\n\tServerCurrentDeathNote = null;\r\n\tif (State.pointsOfInterest != null)\r\n\t{\r\n\t\tforeach (ProtoBuf.MapNote item in State.pointsOfInterest)\r\n\t\t{\r\n\t\t\titem?.Dispose();\r\n\t\t}\r\n\t\tState.pointsOfInterest.Clear();\r\n\t}\r\n\tDirtyPlayerState();\r\n\tTeamUpdate();\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "Server_ClearMapMarkers",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerReported",
    "fullName": "OnPlayerReported",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local3",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local2",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void OnPlayerReported(BaseEntity.RPCMessage msg)\r\n{\r\n\tstring text = msg.read.String();\r\n\tstring message = msg.read.StringMultiLine();\r\n\tstring type = msg.read.String();\r\n\tstring text2 = msg.read.String();\r\n\tstring text3 = msg.read.String();\r\n\tUnityEngine.DebugEx.Log($\"[PlayerReport] {this} reported {text3}[{text2}] - \\\"{text}\\\"\");\r\n\tFacepunch.RCon.Broadcast(Facepunch.RCon.LogType.Report, new\r\n\t{\r\n\t\tPlayerId = UserIDString,\r\n\t\tPlayerName = displayName,\r\n\t\tTargetId = text2,\r\n\t\tTargetName = text3,\r\n\t\tSubject = text,\r\n\t\tMessage = message,\r\n\t\tType = type\r\n\t});\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnPlayerReported",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanNetworkTo",
    "fullName": "CanNetworkTo [BasePlayer]",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool ShouldNetworkTo(BasePlayer player)\r\n{\r\n\tif (player == this)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (IsSpectating() && player != this)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tbool flag = base.ShouldNetworkTo(player);\r\n\tif (ServerOcclusion.OcclusionEnabled && flag)\r\n\t{\r\n\t\tbool flag2 = IsBot || IsNpc;\r\n\t\tbool flag3 = player.GetMounted() is ComputerStation;\r\n\t\tflag = OcclusionLineOfSight(player, flag3 || flag2);\r\n\t}\r\n\treturn flag;\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "ShouldNetworkTo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "IOnPlayerConnected",
    "fullName": "IOnPlayerConnected",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void PlayerInit(Network.Connection c)\r\n{\r\n\tusing (TimeWarning.New(\"PlayerInit\", 10))\r\n\t{\r\n\t\tCancelInvoke(base.KillMessage);\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.Connected, b: true);\r\n\t\tactivePlayerList.Add(this);\r\n\t\tbots.Remove(this);\r\n\t\tuserID = c.userid;\r\n\t\tUserIDString = userID.Get().ToString();\r\n\t\tdisplayName = c.username;\r\n\t\tc.player = this;\r\n\t\tsecondsConnected = 0;\r\n\t\tcurrentTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userID)?.teamID ?? 0;\r\n\t\tSingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(userID, displayName);\r\n\t\ttickInterpolator.Reset(base.transform.position);\r\n\t\ttickHistory.Reset(base.transform.position);\r\n\t\teyeHistory.Clear();\r\n\t\tlastTickTime = 0f;\r\n\t\tlastInputTime = 0f;\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\r\n\t\tstats.Init();\r\n\t\tInvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));\r\n\t\tpreviousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, c.authLevel != 0);\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));\r\n\t\tif (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))\r\n\t\t{\r\n\t\t\tSendNetworkGroupChange();\r\n\t\t}\r\n\t\tnet.OnConnected(c);\r\n\t\tnet.StartSubscriber();\r\n\t\tSendAsSnapshot(net.connection);\r\n\t\tGlobalNetworkHandler.server.StartSendingSnapshot(this);\r\n\t\tClientRPC(RpcTarget.Player(\"StartLoading\", this));\r\n\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\r\n\t\t{\r\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);\r\n\t\t}\r\n\t\tif (net != null)\r\n\t\t{\r\n\t\t\tEACServer.OnStartLoading(net.connection);\r\n\t\t}\r\n\t\tif (IsAdmin)\r\n\t\t{\r\n\t\t\tif (ConVar.AntiHack.noclip_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.noclip_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.speedhack_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.speedhack_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.flyhack_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.flyhack_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.projectile_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.projectile_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.melee_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.melee_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.eye_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.eye_protection is disabled!\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tinventory.crafting.SendToOwner();\r\n\t\tif (TerrainMeta.Path != null && TerrainMeta.Path.OceanPatrolFar != null)\r\n\t\t{\r\n\t\t\tSendCargoPatrolPath();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "PlayerInit",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMapMarkerRemove",
    "fullName": "OnMapMarkerRemove",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(10uL)]\r\npublic void Server_RemovePointOfInterest(BaseEntity.RPCMessage msg)\r\n{\r\n\tint num = msg.read.Int32();\r\n\tif (State.pointsOfInterest != null && State.pointsOfInterest.Count > num && num >= 0)\r\n\t{\r\n\t\tState.pointsOfInterest[num].Dispose();\r\n\t\tState.pointsOfInterest.RemoveAt(num);\r\n\t\tDirtyPlayerState();\r\n\t\tSendMarkersToClient();\r\n\t\tTeamUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "Server_RemovePointOfInterest",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMapMarkerAdded",
    "fullName": "OnMapMarkerAdded",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ProtoBuf.MapNote, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(8uL)]\r\npublic void Server_AddMarker(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (State.pointsOfInterest == null)\r\n\t{\r\n\t\tState.pointsOfInterest = Facepunch.Pool.Get<System.Collections.Generic.List<ProtoBuf.MapNote>>();\r\n\t}\r\n\tif (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)\r\n\t{\r\n\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, false, ConVar.Server.maximumMapMarkers.ToString());\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.MapNote mapNote = ProtoBuf.MapNote.Deserialize(msg.read);\r\n\tif (mapNote.label == \"auto-name\")\r\n\t{\r\n\t\tint num = FindUnusedNumberName();\r\n\t\tif (num != -1)\r\n\t\t{\r\n\t\t\tmapNote.label = num.ToString();\r\n\t\t}\r\n\t}\r\n\tValidateMapNote(mapNote);\r\n\tif (mapNote.colourIndex == -1)\r\n\t{\r\n\t\tmapNote.colourIndex = FindUnusedPointOfInterestColour();\r\n\t}\r\n\tState.pointsOfInterest.Add(mapNote);\r\n\tDirtyPlayerState();\r\n\tSendMarkersToClient();\r\n\tTeamUpdate();\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "Server_AddMarker",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerCorpseSpawned",
    "fullName": "OnPlayerCorpseSpawned",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "PlayerCorpse, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual BaseCorpse CreateCorpse(BasePlayer.PlayerFlags flagsOnDeath, UnityEngine.Vector3 posOnDeath, UnityEngine.Quaternion rotOnDeath, System.Collections.Generic.List<TriggerBase> triggersOnDeath, bool forceServerSide = false)\r\n{\r\n\tusing (TimeWarning.New(\"Create corpse\"))\r\n\t{\r\n\t\tstring strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? \"assets/prefabs/player/player_corpse.prefab\" : \"assets/prefabs/player/player_corpse_new.prefab\");\r\n\t\tbool flag = false;\r\n\t\tif (ConVar.Global.cinematicGingerbreadCorpses)\r\n\t\t{\r\n\t\t\tforeach (Item item in inventory.containerWear.itemList)\r\n\t\t\t{\r\n\t\t\t\tif (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))\r\n\t\t\t\t{\r\n\t\t\t\t\tstrCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);\r\n\t\t\t\t\tflag = component.BlockWearableCopy;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tPlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;\r\n\t\tif ((bool)playerCorpse)\r\n\t\t{\r\n\t\t\tplayerCorpse.SetFlag(BaseEntity.Flags.Reserved5, HasPlayerFlag(BasePlayer.PlayerFlags.DisplaySash));\r\n\t\t\tif (!flag)\r\n\t\t\t{\r\n\t\t\t\tplayerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);\r\n\t\t\t}\r\n\t\t\tplayerCorpse.playerName = displayName;\r\n\t\t\tplayerCorpse.streamerName = Facepunch.RandomUsernames.Get(userID);\r\n\t\t\tplayerCorpse.playerSteamID = userID;\r\n\t\t\tplayerCorpse.underwearSkin = GetUnderwearSkin();\r\n\t\t\tif (!triggersOnDeath.IsNullOrEmpty())\r\n\t\t\t{\r\n\t\t\t\tforeach (TriggerBase item2 in triggersOnDeath)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (item2 is TriggerParent triggerParent)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttriggerParent.ForceParentEarly(playerCorpse);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tplayerCorpse.Spawn();\r\n\t\t\tplayerCorpse.TakeChildren(this);\r\n\t\t\tResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();\r\n\t\t\tint num = 2;\r\n\t\t\tif (lifeStory != null)\r\n\t\t\t{\r\n\t\t\t\tnum += UnityEngine.Mathf.Clamp(UnityEngine.Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);\r\n\t\t\t}\r\n\t\t\tcomponent2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition(\"fat.animal\"), num));\r\n\t\t\treturn playerCorpse;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n\tstatic float GetFloatBasedOnUserID(ulong steamid, ulong seed)\r\n\t{\r\n\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\r\n\t\tUnityEngine.Random.InitState((int)(seed + steamid));\r\n\t\tfloat result = UnityEngine.Random.Range(0f, 1f);\r\n\t\tUnityEngine.Random.state = state;\r\n\t\treturn result;\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "CreateCorpse",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDemoRecordingStart",
    "fullName": "OnDemoRecordingStart",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartDemoRecording()\r\n{\r\n\tif (net != null && net.connection != null && !net.connection.IsRecording)\r\n\t{\r\n\t\tstring text = $\"demos/{UserIDString}/{System.DateTime.Now:yyyy-MM-dd-hhmmss}.dem\";\r\n\t\tUnityEngine.Debug.Log(ToString() + \" recording started: \" + text);\r\n\t\tnet.connection.StartRecording(text, new ConVar.Demo.Header\r\n\t\t{\r\n\t\t\tversion = ConVar.Demo.Version,\r\n\t\t\tlevel = UnityEngine.Application.loadedLevelName,\r\n\t\t\tlevelSeed = World.Seed,\r\n\t\t\tlevelSize = World.Size,\r\n\t\t\tchecksum = World.Checksum,\r\n\t\t\tlocalclient = userID,\r\n\t\t\tposition = eyes.position,\r\n\t\t\trotation = eyes.HeadForward(),\r\n\t\t\tlevelUrl = World.Url,\r\n\t\t\trecordedTime = System.DateTime.Now.ToBinary()\r\n\t\t});\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tSendGlobalSnapshot();\r\n\t\tSendFullSnapshot();\r\n\t\tSendEntityUpdate();\r\n\t\tTreeManager.SendSnapshot(this);\r\n\t\tServerMgr.SendReplicatedVars(net.connection);\r\n\t\tInvokeRepeating(MonitorDemoRecording, 10f, 10f);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "StartDemoRecording",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDemoRecordingStarted",
    "fullName": "OnDemoRecordingStarted",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartDemoRecording()\r\n{\r\n\tif (net != null && net.connection != null && !net.connection.IsRecording)\r\n\t{\r\n\t\tstring text = $\"demos/{UserIDString}/{System.DateTime.Now:yyyy-MM-dd-hhmmss}.dem\";\r\n\t\tUnityEngine.Debug.Log(ToString() + \" recording started: \" + text);\r\n\t\tnet.connection.StartRecording(text, new ConVar.Demo.Header\r\n\t\t{\r\n\t\t\tversion = ConVar.Demo.Version,\r\n\t\t\tlevel = UnityEngine.Application.loadedLevelName,\r\n\t\t\tlevelSeed = World.Seed,\r\n\t\t\tlevelSize = World.Size,\r\n\t\t\tchecksum = World.Checksum,\r\n\t\t\tlocalclient = userID,\r\n\t\t\tposition = eyes.position,\r\n\t\t\trotation = eyes.HeadForward(),\r\n\t\t\tlevelUrl = World.Url,\r\n\t\t\trecordedTime = System.DateTime.Now.ToBinary()\r\n\t\t});\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tSendGlobalSnapshot();\r\n\t\tSendFullSnapshot();\r\n\t\tSendEntityUpdate();\r\n\t\tTreeManager.SendSnapshot(this);\r\n\t\tServerMgr.SendReplicatedVars(net.connection);\r\n\t\tInvokeRepeating(MonitorDemoRecording, 10f, 10f);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "StartDemoRecording",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDemoRecordingStop",
    "fullName": "OnDemoRecordingStop",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StopDemoRecording()\r\n{\r\n\tif (net != null && net.connection != null && net.connection.IsRecording)\r\n\t{\r\n\t\tUnityEngine.Debug.Log(ToString() + \" recording stopped: \" + net.connection.RecordFilename);\r\n\t\tnet.connection.StopRecording();\r\n\t\tCancelInvoke(MonitorDemoRecording);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "StopDemoRecording",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDemoRecordingStopped",
    "fullName": "OnDemoRecordingStopped",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StopDemoRecording()\r\n{\r\n\tif (net != null && net.connection != null && net.connection.IsRecording)\r\n\t{\r\n\t\tUnityEngine.Debug.Log(ToString() + \" recording stopped: \" + net.connection.RecordFilename);\r\n\t\tnet.connection.StopRecording();\r\n\t\tCancelInvoke(MonitorDemoRecording);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "StopDemoRecording",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnThreatLevelUpdate",
    "fullName": "OnThreatLevelUpdate",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void EnsureUpdated()\r\n{\r\n\tif (UnityEngine.Time.realtimeSinceStartup - lastUpdateTime < 30f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tlastUpdateTime = UnityEngine.Time.realtimeSinceStartup;\r\n\tcachedThreatLevel = 0f;\r\n\tif (IsSleeping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (inventory.containerWear.itemList.Count > 2)\r\n\t{\r\n\t\tcachedThreatLevel += 1f;\r\n\t}\r\n\tforeach (Item item in inventory.containerBelt.itemList)\r\n\t{\r\n\t\tBaseEntity heldEntity = item.GetHeldEntity();\r\n\t\tif ((bool)heldEntity && heldEntity is BaseProjectile && !(heldEntity is BowWeapon))\r\n\t\t{\r\n\t\t\tcachedThreatLevel += 2f;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "EnsureUpdated",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRespawnInformationGiven",
    "fullName": "OnRespawnInformationGiven",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Collections.Generic.List`1[[ProtoBuf.RespawnInformation+SpawnOptions, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendRespawnOptions()\r\n{\r\n\tif (NexusServer.Started && ZoneController.Instance.CanRespawnAcrossZones(this))\r\n\t{\r\n\t\tCollectExternalAndSend();\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions> spawnOptions2 = Facepunch.Pool.Get<System.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions>>();\r\n\tGetRespawnOptionsForPlayer(spawnOptions2, userID);\r\n\tSendToPlayer(spawnOptions2, loading: false);\r\n\tasync void CollectExternalAndSend()\r\n\t{\r\n\t\tSystem.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions> list = Facepunch.Pool.Get<System.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions>>();\r\n\t\tGetRespawnOptionsForPlayer(list, userID);\r\n\t\tSystem.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions> allSpawnOptions = Facepunch.Pool.Get<System.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions>>();\r\n\t\tforeach (ProtoBuf.RespawnInformation.SpawnOptions item in list)\r\n\t\t{\r\n\t\t\tallSpawnOptions.Add(item.Copy());\r\n\t\t}\r\n\t\tSendToPlayer(list, loading: true);\r\n\t\ttry\r\n\t\t{\r\n\t\t\tProtoBuf.Nexus.Request request = Facepunch.Pool.Get<ProtoBuf.Nexus.Request>();\r\n\t\t\trequest.spawnOptions = Facepunch.Pool.Get<ProtoBuf.Nexus.SpawnOptionsRequest>();\r\n\t\t\trequest.spawnOptions.userId = userID;\r\n\t\t\tusing (NexusRpcResult nexusRpcResult = await NexusServer.BroadcastRpc(request, 10f))\r\n\t\t\t{\r\n\t\t\t\tforeach (System.Collections.Generic.KeyValuePair<string, ProtoBuf.Nexus.Response> response in nexusRpcResult.Responses)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring key = response.Key;\r\n\t\t\t\t\tProtoBuf.Nexus.SpawnOptionsResponse spawnOptions3 = response.Value.spawnOptions;\r\n\t\t\t\t\tif (spawnOptions3 != null && spawnOptions3.spawnOptions.Count != 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tforeach (ProtoBuf.RespawnInformation.SpawnOptions spawnOption in spawnOptions3.spawnOptions)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tProtoBuf.RespawnInformation.SpawnOptions spawnOptions4 = spawnOption.Copy();\r\n\t\t\t\t\t\t\tspawnOptions4.nexusZone = key;\r\n\t\t\t\t\t\t\tallSpawnOptions.Add(spawnOptions4);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSendToPlayer(allSpawnOptions, loading: false);\r\n\t\t}\r\n\t\tcatch (System.Exception exception)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogException(exception);\r\n\t\t}\r\n\t}\r\n\tvoid SendToPlayer(System.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions> spawnOptions, bool loading)\r\n\t{\r\n\t\tusing ProtoBuf.RespawnInformation respawnInformation = Facepunch.Pool.Get<ProtoBuf.RespawnInformation>();\r\n\t\trespawnInformation.spawnOptions = spawnOptions;\r\n\t\trespawnInformation.loading = loading;\r\n\t\tif (LegacyShelter.max_shelters == LegacyShelter.FpShelterDefault && LegacyShelter.SheltersPerPlayer.ContainsKey(userID) && LegacyShelter.SheltersPerPlayer[userID].Count > 0)\r\n\t\t{\r\n\t\t\trespawnInformation.shelterPositions = Facepunch.Pool.Get<System.Collections.Generic.List<UnityEngine.Vector3>>();\r\n\t\t\tforeach (LegacyShelter item2 in LegacyShelter.SheltersPerPlayer[userID])\r\n\t\t\t{\r\n\t\t\t\trespawnInformation.shelterPositions.Add(item2.transform.position);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (IsDead())\r\n\t\t{\r\n\t\t\trespawnInformation.previousLife = previousLifeStory;\r\n\t\t\tif (!ConVar.Server.skipDeathScreenFade)\r\n\t\t\t{\r\n\t\t\t\trespawnInformation.fadeIn = previousLifeStory != null && previousLifeStory.timeDied > Facepunch.Math.Epoch.Current - 5;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\trespawnInformation.fadeIn = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tClientRPC(RpcTarget.Player(\"OnRespawnInformation\", this), respawnInformation);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "SendRespawnOptions",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerRecover",
    "fullName": "OnPlayerRecover",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RecoverFromWounded()\r\n{\r\n\tif (IsCrawling())\r\n\t{\r\n\t\tbase.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;\r\n\t}\r\n\thealingWhileCrawling = 0f;\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Wounded, b: false);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Incapacitated, b: false);\r\n\tif ((bool)BaseGameMode.GetActiveGameMode(base.isServer))\r\n\t{\r\n\t\tBaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "RecoverFromWounded",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerWound",
    "fullName": "OnPlayerWound",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void BecomeWounded(HitInfo info = null)\r\n{\r\n\tif (IsWounded())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = info != null && info.damageTypes.GetMajorityDamageType() == Rust.DamageType.Fall;\r\n\tif (IsCrawling())\r\n\t{\r\n\t\twoundedByFallDamage |= flag;\r\n\t\tGoToIncapacitated(info);\r\n\t\treturn;\r\n\t}\r\n\twoundedByFallDamage = flag;\r\n\tif (flag || !ConVar.Server.crawlingenabled)\r\n\t{\r\n\t\tGoToIncapacitated(info);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tGoToCrawling(info);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "BecomeWounded",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerRecovered",
    "fullName": "OnPlayerRecovered",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RecoverFromWounded()\r\n{\r\n\tif (IsCrawling())\r\n\t{\r\n\t\tbase.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;\r\n\t}\r\n\thealingWhileCrawling = 0f;\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Wounded, b: false);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Incapacitated, b: false);\r\n\tif ((bool)BaseGameMode.GetActiveGameMode(base.isServer))\r\n\t{\r\n\t\tBaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "RecoverFromWounded",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerColliderEnable",
    "fullName": "OnPlayerColliderEnable",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void EnablePlayerCollider()\r\n{\r\n\tif (!playerCollider.enabled)\r\n\t{\r\n\t\tRefreshColliderSize(forced: true);\r\n\t\tplayerCollider.enabled = true;\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "EnablePlayerCollider",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerSleepEnded",
    "fullName": "OnPlayerSleepEnded",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void EndSleeping()\r\n{\r\n\tif (IsSleeping())\r\n\t{\r\n\t\tif (IsRestrained)\r\n\t\t{\r\n\t\t\tinventory.SetLockedByRestraint(flag: true);\r\n\t\t}\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, b: false);\r\n\t\tsleepStartTime = -1f;\r\n\t\tsleepingPlayerList.Remove(this);\r\n\t\tif ((ulong)userID < 10000000 && !bots.Contains(this))\r\n\t\t{\r\n\t\t\tbots.Add(this);\r\n\t\t}\r\n\t\tCancelInvoke(ScheduledDeath);\r\n\t\tInvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));\r\n\t\tif (RelationshipManager.TeamsEnabled())\r\n\t\t{\r\n\t\t\tInvokeRandomized(TeamUpdate, 1f, 4f, 1f);\r\n\t\t}\r\n\t\tInvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);\r\n\t\tEnablePlayerCollider();\r\n\t\tAddPlayerRigidbody();\r\n\t\tSetServerFall(wantsOn: false);\r\n\t\tif (HasParent())\r\n\t\t{\r\n\t\t\tSetParent(null, worldPositionStays: true);\r\n\t\t\tRemoveFromTriggers();\r\n\t\t\tForceUpdateTriggers();\r\n\t\t}\r\n\t\tinventory.containerMain.OnChanged();\r\n\t\tinventory.containerBelt.OnChanged();\r\n\t\tinventory.containerWear.OnChanged();\r\n\t\tEACServer.LogPlayerSpawn(this);\r\n\t\tif (TotalPingCount > 0)\r\n\t\t{\r\n\t\t\tSendPingsToClient();\r\n\t\t}\r\n\t\tif (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.Player(\"PromptToStartTutorial\", this));\r\n\t\t}\r\n\t\tif (AntiHack.TestNoClipping(this, base.transform.position, base.transform.position, NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _))\r\n\t\t{\r\n\t\t\tForceCastNoClip();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "EndSleeping",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFeedbackReported",
    "fullName": "OnFeedbackReported",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local2",
        "type": "Facepunch.Models.ReportType, Facepunch.Unity, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void OnFeedbackReport(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (ConVar.Server.printReportsToConsole || !string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))\r\n\t{\r\n\t\tstring text = msg.read.String();\r\n\t\tstring text2 = msg.read.StringMultiLine();\r\n\t\tFacepunch.Models.ReportType reportType = (Facepunch.Models.ReportType)UnityEngine.Mathf.Clamp(msg.read.Int32(), 0, 5);\r\n\t\tif (ConVar.Server.printReportsToConsole)\r\n\t\t{\r\n\t\t\tUnityEngine.DebugEx.Log($\"[FeedbackReport] {this} reported {reportType} - \\\"{text}\\\" \\\"{text2}\\\"\");\r\n\t\t\tFacepunch.RCon.Broadcast(Facepunch.RCon.LogType.Report, new\r\n\t\t\t{\r\n\t\t\t\tPlayerId = UserIDString,\r\n\t\t\t\tPlayerName = displayName,\r\n\t\t\t\tSubject = text,\r\n\t\t\t\tMessage = text2,\r\n\t\t\t\tType = reportType\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint) && reportType != Facepunch.Models.ReportType.BreakingServerRules)\r\n\t\t{\r\n\t\t\tstring image = msg.read.StringMultiLine(60000);\r\n\t\t\tFacepunch.Models.Feedback feedback = default(Facepunch.Models.Feedback);\r\n\t\t\tfeedback.Type = reportType;\r\n\t\t\tfeedback.Message = text2;\r\n\t\t\tfeedback.Subject = text;\r\n\t\t\tFacepunch.Models.Feedback feedback2 = feedback;\r\n\t\t\tfeedback2.AppInfo.Image = image;\r\n\t\t\tFacepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, userID, ConVar.Server.reportsServerEndpointKey, feedback2);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnFeedbackReport",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerMarkersSend",
    "fullName": "OnPlayerMarkersSend",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ProtoBuf.MapNoteList, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendMarkersToClient()\r\n{\r\n\tusing ProtoBuf.MapNoteList mapNoteList = Facepunch.Pool.Get<ProtoBuf.MapNoteList>();\r\n\tmapNoteList.notes = Facepunch.Pool.Get<System.Collections.Generic.List<ProtoBuf.MapNote>>();\r\n\tif (ServerCurrentDeathNote != null)\r\n\t{\r\n\t\tmapNoteList.notes.Add(ServerCurrentDeathNote);\r\n\t}\r\n\tif (State.pointsOfInterest != null)\r\n\t{\r\n\t\tmapNoteList.notes.AddRange(State.pointsOfInterest);\r\n\t}\r\n\tClientRPC(RpcTarget.Player(\"Client_ReceiveMarkers\", this), mapNoteList);\r\n\tmapNoteList.notes.Clear();\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "SendMarkersToClient",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerPingsSend",
    "fullName": "OnPlayerPingsSend",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ProtoBuf.MapNoteList, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendPingsToClient()\r\n{\r\n\tusing ProtoBuf.MapNoteList mapNoteList = Facepunch.Pool.Get<ProtoBuf.MapNoteList>();\r\n\tmapNoteList.notes = Facepunch.Pool.Get<System.Collections.Generic.List<ProtoBuf.MapNote>>();\r\n\tmapNoteList.notes.AddRange(State.pings);\r\n\tClientRPC(RpcTarget.Player(\"Client_ReceivePings\", this), mapNoteList);\r\n\tmapNoteList.notes.Clear();\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "SendPingsToClient",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnActiveTelephoneUpdated",
    "fullName": "OnActiveTelephoneUpdated [BasePlayer]",
    "category": "Player",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetActiveTelephone(PhoneController t)\r\n{\r\n\tactiveTelephone = t;\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "SetActiveTelephone",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMapMarkerAdd",
    "fullName": "OnMapMarkerAdd",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(8uL)]\r\npublic void Server_AddMarker(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (State.pointsOfInterest == null)\r\n\t{\r\n\t\tState.pointsOfInterest = Facepunch.Pool.Get<System.Collections.Generic.List<ProtoBuf.MapNote>>();\r\n\t}\r\n\tif (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)\r\n\t{\r\n\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, false, ConVar.Server.maximumMapMarkers.ToString());\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.MapNote mapNote = ProtoBuf.MapNote.Deserialize(msg.read);\r\n\tif (mapNote.label == \"auto-name\")\r\n\t{\r\n\t\tint num = FindUnusedNumberName();\r\n\t\tif (num != -1)\r\n\t\t{\r\n\t\t\tmapNote.label = num.ToString();\r\n\t\t}\r\n\t}\r\n\tValidateMapNote(mapNote);\r\n\tif (mapNote.colourIndex == -1)\r\n\t{\r\n\t\tmapNote.colourIndex = FindUnusedPointOfInterestColour();\r\n\t}\r\n\tState.pointsOfInterest.Add(mapNote);\r\n\tDirtyPlayerState();\r\n\tSendMarkersToClient();\r\n\tTeamUpdate();\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "Server_AddMarker",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerCorpseSpawn",
    "fullName": "OnPlayerCorpseSpawn",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual BaseCorpse CreateCorpse(BasePlayer.PlayerFlags flagsOnDeath, UnityEngine.Vector3 posOnDeath, UnityEngine.Quaternion rotOnDeath, System.Collections.Generic.List<TriggerBase> triggersOnDeath, bool forceServerSide = false)\r\n{\r\n\tusing (TimeWarning.New(\"Create corpse\"))\r\n\t{\r\n\t\tstring strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? \"assets/prefabs/player/player_corpse.prefab\" : \"assets/prefabs/player/player_corpse_new.prefab\");\r\n\t\tbool flag = false;\r\n\t\tif (ConVar.Global.cinematicGingerbreadCorpses)\r\n\t\t{\r\n\t\t\tforeach (Item item in inventory.containerWear.itemList)\r\n\t\t\t{\r\n\t\t\t\tif (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))\r\n\t\t\t\t{\r\n\t\t\t\t\tstrCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);\r\n\t\t\t\t\tflag = component.BlockWearableCopy;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tPlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;\r\n\t\tif ((bool)playerCorpse)\r\n\t\t{\r\n\t\t\tplayerCorpse.SetFlag(BaseEntity.Flags.Reserved5, HasPlayerFlag(BasePlayer.PlayerFlags.DisplaySash));\r\n\t\t\tif (!flag)\r\n\t\t\t{\r\n\t\t\t\tplayerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);\r\n\t\t\t}\r\n\t\t\tplayerCorpse.playerName = displayName;\r\n\t\t\tplayerCorpse.streamerName = Facepunch.RandomUsernames.Get(userID);\r\n\t\t\tplayerCorpse.playerSteamID = userID;\r\n\t\t\tplayerCorpse.underwearSkin = GetUnderwearSkin();\r\n\t\t\tif (!triggersOnDeath.IsNullOrEmpty())\r\n\t\t\t{\r\n\t\t\t\tforeach (TriggerBase item2 in triggersOnDeath)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (item2 is TriggerParent triggerParent)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttriggerParent.ForceParentEarly(playerCorpse);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tplayerCorpse.Spawn();\r\n\t\t\tplayerCorpse.TakeChildren(this);\r\n\t\t\tResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();\r\n\t\t\tint num = 2;\r\n\t\t\tif (lifeStory != null)\r\n\t\t\t{\r\n\t\t\t\tnum += UnityEngine.Mathf.Clamp(UnityEngine.Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);\r\n\t\t\t}\r\n\t\t\tcomponent2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition(\"fat.animal\"), num));\r\n\t\t\treturn playerCorpse;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n\tstatic float GetFloatBasedOnUserID(ulong steamid, ulong seed)\r\n\t{\r\n\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\r\n\t\tUnityEngine.Random.InitState((int)(seed + steamid));\r\n\t\tfloat result = UnityEngine.Random.Range(0f, 1f);\r\n\t\tUnityEngine.Random.state = state;\r\n\t\treturn result;\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "CreateCorpse",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSendModelState",
    "fullName": "OnSendModelState",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendModelState(bool force = false)\r\n{\r\n\tif (force || (wantsSendModelState && !(nextModelStateUpdate > UnityEngine.Time.time)))\r\n\t{\r\n\t\twantsSendModelState = false;\r\n\t\tnextModelStateUpdate = UnityEngine.Time.time + 0.1f;\r\n\t\tif (!IsDead() && !IsSpectating())\r\n\t\t{\r\n\t\t\tmodelState.sleeping = IsSleeping();\r\n\t\t\tmodelState.mounted = isMounted;\r\n\t\t\tmodelState.ragdolling = IsRagdolling();\r\n\t\t\tmodelState.relaxed = IsRelaxed();\r\n\t\t\tmodelState.onPhone = HasActiveTelephone && !activeTelephone.IsMobile;\r\n\t\t\tmodelState.crawling = IsCrawling();\r\n\t\t\tmodelState.loading = IsLoadingAfterTransfer();\r\n\t\t\tClientRPC(RpcTarget.NetworkGroup(\"OnModelState\"), modelState);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "SendModelState",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRunPlayerMetabolism",
    "fullName": "OnRunPlayerMetabolism",
    "category": "Player",
    "parameters": [
      {
        "name": "playerMetabolism",
        "type": "PlayerMetabolism, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)\r\n{\r\n\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\r\n\tfloat num = owner.currentTemperature;\r\n\tfloat fTarget = owner.currentComfort;\r\n\tUpdateWorkbenchFlags();\r\n\towner.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, owner.InSafeZone());\r\n\towner.SetPlayerFlag(BasePlayer.PlayerFlags.NoRespawnZone, owner.InNoRespawnZone());\r\n\towner.SetPlayerFlag(BasePlayer.PlayerFlags.ModifyClan, ConVar.Clan.editsRequireClanTable && owner.CanModifyClan());\r\n\tbool num2 = activeGameMode == null || activeGameMode.allowTemperature;\r\n\tif (owner.IsInTutorial)\r\n\t{\r\n\t\tnum = 25f;\r\n\t}\r\n\tif (num2)\r\n\t{\r\n\t\tfloat num3 = num + GetCoreTempAdjustment() - DeltaWet() * 34f;\r\n\t\tfloat num4 = UnityEngine.Mathf.Clamp(owner.baseProtection.amounts[18] * 1.5f, -1f, 1f);\r\n\t\tfloat num5 = UnityEngine.Mathf.InverseLerp(20f, -50f, num);\r\n\t\tfloat num6 = UnityEngine.Mathf.InverseLerp(20f, 30f, num);\r\n\t\tfloat fTarget2 = UnityEngine.Mathf.Clamp(num3 + num5 * 70f * num4 + num6 * 10f * UnityEngine.Mathf.Abs(num4) + heartrate.value * 5f, GetCoreTempMin(), GetCoreTempMax());\r\n\t\ttemperature.MoveTowards(fTarget2, delta * 5f);\r\n\t}\r\n\telse\r\n\t{\r\n\t\ttemperature.value = 25f;\r\n\t}\r\n\tif (temperature.value >= 40f)\r\n\t{\r\n\t\tfTarget = 0f;\r\n\t}\r\n\tcomfort.MoveTowards(fTarget, delta / 5f);\r\n\tfloat num7 = 0.6f + 0.4f * comfort.value;\r\n\tif (calories.value > 100f && owner.healthFraction < num7 && radiation_poison.Fraction() < 0.25f && owner.SecondsSinceAttacked > 10f && !SignificantBleeding() && temperature.value >= 10f && hydration.value > 40f)\r\n\t{\r\n\t\tfloat num8 = UnityEngine.Mathf.InverseLerp(calories.min, calories.max, calories.value);\r\n\t\tfloat num9 = 5f;\r\n\t\tfloat num10 = num9 * owner.MaxHealth() * 0.8f / 600f;\r\n\t\tnum10 += num10 * num8 * 0.5f;\r\n\t\tfloat num11 = num10 / num9;\r\n\t\tnum11 += num11 * comfort.value * 6f;\r\n\t\townerEntity.Heal(num11 * delta);\r\n\t\tcalories.Subtract(num10 * delta);\r\n\t\thydration.Subtract(num10 * delta * 0.2f);\r\n\t}\r\n\tfloat num12 = owner.estimatedSpeed2D / owner.GetMaxSpeed() * 0.75f;\r\n\tfloat fTarget3 = UnityEngine.Mathf.Clamp(0.05f + num12, 0f, 1f);\r\n\theartrate.MoveTowards(fTarget3, delta * 0.1f);\r\n\tif (!owner.IsGod())\r\n\t{\r\n\t\tfloat num13 = heartrate.Fraction() * 0.375f;\r\n\t\tcalories.MoveTowards(0f, delta * num13);\r\n\t\tfloat num14 = 1f / 120f;\r\n\t\tnum14 += UnityEngine.Mathf.InverseLerp(40f, 60f, temperature.value) * (1f / 12f);\r\n\t\tnum14 += heartrate.value * (1f / 15f);\r\n\t\thydration.MoveTowards(0f, delta * num14);\r\n\t}\r\n\tbool b = hydration.Fraction() <= 0f || radiation_poison.value >= 100f;\r\n\towner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, b);\r\n\tif (temperature.value > 40f)\r\n\t{\r\n\t\thydration.Add(UnityEngine.Mathf.InverseLerp(40f, 200f, temperature.value) * delta * -1f);\r\n\t}\r\n\tif (temperature.value < 10f)\r\n\t{\r\n\t\tfloat num15 = UnityEngine.Mathf.InverseLerp(20f, -100f, temperature.value);\r\n\t\theartrate.MoveTowards(UnityEngine.Mathf.Lerp(0.2f, 1f, num15), delta * 2f * num15);\r\n\t}\r\n\tfloat num16 = owner.AirFactor();\r\n\tfloat num17 = ((num16 > oxygen.value) ? 1f : 0.1f);\r\n\toxygen.MoveTowards(num16, delta * num17);\r\n\tfloat f = 0f;\r\n\tfloat f2 = 0f;\r\n\tif (owner.IsOutside(owner.eyes.position))\r\n\t{\r\n\t\tf = Climate.GetRain(owner.eyes.position) * ConVar.Weather.wetness_rain;\r\n\t\tf2 = Climate.GetSnow(owner.eyes.position) * ConVar.Weather.wetness_snow;\r\n\t}\r\n\tbool flag = owner.baseProtection.amounts[4] > 0f;\r\n\tfloat currentEnvironmentalWetness = owner.currentEnvironmentalWetness;\r\n\tcurrentEnvironmentalWetness = UnityEngine.Mathf.Clamp(currentEnvironmentalWetness, 0f, 0.8f);\r\n\tfloat num18 = owner.WaterFactor();\r\n\tif (!flag && num18 > 0f)\r\n\t{\r\n\t\twetness.value = UnityEngine.Mathf.Max(wetness.value, UnityEngine.Mathf.Clamp(num18, wetness.min, wetness.max));\r\n\t}\r\n\tfloat num19 = Mathx.Max(wetness.value, f, f2, currentEnvironmentalWetness);\r\n\tnum19 = UnityEngine.Mathf.Min(num19, flag ? 0f : num19);\r\n\twetness.MoveTowards(num19, delta * 0.05f);\r\n\tif (num18 < wetness.value && currentEnvironmentalWetness <= 0f)\r\n\t{\r\n\t\twetness.MoveTowards(0f, delta * 0.2f * UnityEngine.Mathf.InverseLerp(0f, 100f, num));\r\n\t}\r\n\tpoison.MoveTowards(0f, delta * (5f / 9f));\r\n\tif (wetness.Fraction() > 0.4f && owner.estimatedSpeed > 0.25f && radiation_level.Fraction() == 0f)\r\n\t{\r\n\t\tradiation_poison.Subtract(radiation_poison.value * 0.2f * wetness.Fraction() * delta * 0.2f);\r\n\t}\r\n\tif (ConVar.Server.radiation)\r\n\t{\r\n\t\tif (!owner.IsGod())\r\n\t\t{\r\n\t\t\tradiation_level.value = owner.radiationLevel;\r\n\t\t\tif (radiation_level.value > 0f)\r\n\t\t\t{\r\n\t\t\t\tradiation_poison.Add(radiation_level.value * delta);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (radiation_level.value > 0f)\r\n\t\t{\r\n\t\t\tradiation_level.value = 0f;\r\n\t\t\tradiation_poison.value = 0f;\r\n\t\t}\r\n\t}\r\n\tif (pending_health.value > 0f)\r\n\t{\r\n\t\tfloat num20 = 1f + owner.modifiers.GetValue(Modifier.ModifierType.MetabolismBooster);\r\n\t\tfloat num21 = UnityEngine.Mathf.Min(1f * delta * num20, pending_health.value);\r\n\t\townerEntity.Heal(num21);\r\n\t\tif (ownerEntity.healthFraction == 1f)\r\n\t\t{\r\n\t\t\tpending_health.value = 0f;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpending_health.Subtract(num21);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "PlayerMetabolism",
    "methodName": "RunMetabolism",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerMetabolize",
    "fullName": "OnPlayerMetabolize",
    "category": "Player",
    "parameters": [
      {
        "name": "playerMetabolism",
        "type": "PlayerMetabolism, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "ownerEntity",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "delta",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void ServerUpdate(BaseCombatEntity ownerEntity, float delta)\r\n{\r\n\tbase.ServerUpdate(ownerEntity, delta);\r\n\tSendChangesToClient();\r\n}\r\n",
    "targetName": "PlayerMetabolism",
    "methodName": "ServerUpdate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "IOnUserApprove",
    "fullName": "IOnUserApprove",
    "category": "Player",
    "parameters": [
      {
        "name": "connection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnNewConnection(Network.Connection connection)\r\n{\r\n\tconnection.connected = false;\r\n\tif (connection.token == null || connection.token.Length < 32)\r\n\t{\r\n\t\tReject(connection, \"Invalid Token\");\r\n\t\treturn;\r\n\t}\r\n\tif (connection.userid == 0L)\r\n\t{\r\n\t\tReject(connection, \"Invalid SteamID\");\r\n\t\treturn;\r\n\t}\r\n\tif (connection.protocol != 2583)\r\n\t{\r\n\t\tif (!DeveloperList.Contains(connection.userid))\r\n\t\t{\r\n\t\t\tReject(connection, \"Incompatible Version\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"Not kicking \" + connection.userid + \" for incompatible protocol (is a developer)\");\r\n\t}\r\n\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))\r\n\t{\r\n\t\tServerUsers.User user = ServerUsers.Get(connection.userid);\r\n\t\tstring text = user?.notes ?? \"no reason given\";\r\n\t\tstring text2 = ((user != null && user.expiry > 0) ? (\" for \" + Facepunch.Extend.NumberExtensions.FormatSecondsLong(user.expiry - Facepunch.Math.Epoch.Current)) : \"\");\r\n\t\tReject(connection, \"You are banned from this server\" + text2 + \" (\" + text + \")\");\r\n\t\treturn;\r\n\t}\r\n\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))\r\n\t{\r\n\t\tUnityEngine.DebugEx.Log(connection.ToString() + \" has auth level 1\");\r\n\t\tconnection.authLevel = 1u;\r\n\t}\r\n\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))\r\n\t{\r\n\t\tUnityEngine.DebugEx.Log(connection.ToString() + \" has auth level 2\");\r\n\t\tconnection.authLevel = 2u;\r\n\t}\r\n\tif (DeveloperList.Contains(connection.userid))\r\n\t{\r\n\t\tUnityEngine.DebugEx.Log(connection.ToString() + \" is a developer\");\r\n\t\tconnection.authLevel = 3u;\r\n\t}\r\n\tm_AuthConnection.Add(connection);\r\n\tStartCoroutine(AuthorisationRoutine(connection));\r\n}\r\n",
    "targetName": "ConnectionAuth",
    "methodName": "OnNewConnection",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanUpdateSign",
    "fullName": "CanUpdateSign [Signage]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "signage",
        "type": "Signage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CanUpdateSign(BasePlayer player)\r\n{\r\n\tif (player.IsAdmin || player.IsDeveloper)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (!player.CanBuild())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (IsLocked())\r\n\t{\r\n\t\treturn (ulong)player.userID == base.OwnerID;\r\n\t}\r\n\tif (!HeldEntityCheck(player))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "Signage",
    "methodName": "CanUpdateSign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanResearchItem",
    "fullName": "CanResearchItem",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void DoResearch(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (IsResearching())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = msg.player;\r\n\tItem targetItem = GetTargetItem();\r\n\tif (targetItem != null && targetItem.amount <= 1 && IsItemResearchable(targetItem))\r\n\t{\r\n\t\ttargetItem.CollectedForCrafting(player);\r\n\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;\r\n\t\tInvoke(ResearchAttemptFinished, researchDuration);\r\n\t\tbase.inventory.SetLocked(isLocked: true);\r\n\t\tint scrapCost = ScrapForResearch(targetItem);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\tSendNetworkUpdate();\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tif (researchStartEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\t}\r\n\t\tmsg.player.GiveAchievement(\"RESEARCH_ITEM\");\r\n\t}\r\n}\r\n",
    "targetName": "ResearchTable",
    "methodName": "DoResearch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanBeTargeted",
    "fullName": "CanBeTargeted [AutoTurret]",
    "category": "Player",
    "parameters": [
      {
        "name": "obj",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool ObjectVisible(BaseCombatEntity obj)\r\n{\r\n\tSystem.Collections.Generic.List<UnityEngine.RaycastHit> obj2 = Facepunch.Pool.Get<System.Collections.Generic.List<UnityEngine.RaycastHit>>();\r\n\tUnityEngine.Vector3 position = eyePos.transform.position;\r\n\tif (GamePhysics.CheckSphere(position, 0.1f, 2097152))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tUnityEngine.Vector3 vector = AimOffset(obj);\r\n\tfloat num = UnityEngine.Vector3.Distance(vector, position);\r\n\tUnityEngine.Vector3 vector2 = UnityEngine.Vector3.Cross((vector - position).normalized, UnityEngine.Vector3.up);\r\n\tfor (int i = 0; (float)i < (CheckPeekers() ? 3f : 1f); i++)\r\n\t{\r\n\t\tUnityEngine.Vector3 normalized = (vector + vector2 * visibilityOffsets[i] - position).normalized;\r\n\t\tobj2.Clear();\r\n\t\tGamePhysics.TraceAll(new UnityEngine.Ray(position, normalized), 0f, obj2, num * 1.1f, 1218652417);\r\n\t\tfor (int j = 0; j < obj2.Count; j++)\r\n\t\t{\r\n\t\t\tBaseEntity entity = obj2[j].GetEntity();\r\n\t\t\tif ((!(entity != null) || !entity.isClient) && (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) && (!(entity != null) || !entity.EqualNetID(this)))\r\n\t\t\t{\r\n\t\t\t\tif (entity != null && (entity == obj || entity.EqualNetID(obj)))\r\n\t\t\t\t{\r\n\t\t\t\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\r\n\t\t\t\t\tpeekIndex = i;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj2);\r\n\treturn false;\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "ObjectVisible",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeTargeted",
    "fullName": "CanBeTargeted [HelicopterTurret]",
    "category": "Player",
    "parameters": [
      {
        "name": "potentialtarget",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "helicopterTurret",
        "type": "HelicopterTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool InFiringArc(BaseCombatEntity potentialtarget)\r\n{\r\n\treturn AngleToTarget(potentialtarget) < 80f;\r\n}\r\n",
    "targetName": "HelicopterTurret",
    "methodName": "InFiringArc",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnLootEntityEnd",
    "fullName": "OnLootEntityEnd [LootableCorpse]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "lootableCorpse",
        "type": "LootableCorpse, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void PlayerStoppedLooting(BasePlayer player)\r\n{\r\n\tResetRemovalTime();\r\n\tSetFlag(BaseEntity.Flags.Open, b: false);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "LootableCorpse",
    "methodName": "PlayerStoppedLooting",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanLootEntity",
    "fullName": "CanLootEntity [LootableCorpse]",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "lootableCorpse",
        "type": "LootableCorpse, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_LootCorpse(BaseEntity.RPCMessage rpc)\r\n{\r\n\tBasePlayer player = rpc.player;\r\n\tif (!player || !player.CanInteract() || !CanLoot() || containers == null || !player.inventory.loot.StartLootingEntity(this))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.Open, b: true);\r\n\tfor (int i = 0; i < containers.Length; i++)\r\n\t{\r\n\t\tItemContainer itemContainer = containers[i];\r\n\t\tif (CanLootContainer(itemContainer, i))\r\n\t\t{\r\n\t\t\tplayer.inventory.loot.AddContainer(itemContainer);\r\n\t\t}\r\n\t}\r\n\tplayer.inventory.loot.SendImmediate();\r\n\tplayer.RadioactiveLootCheck(player.inventory.loot.containers);\r\n\tClientRPC(RpcTarget.Player(\"RPC_ClientLootCorpse\", player));\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "LootableCorpse",
    "methodName": "RPC_LootCorpse",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLootEntityEnd",
    "fullName": "OnLootEntityEnd [StorageContainer]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "storageContainer",
        "type": "StorageContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void PlayerStoppedLooting(BasePlayer player)\r\n{\r\n\tSetFlag(BaseEntity.Flags.Open, b: false);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "StorageContainer",
    "methodName": "PlayerStoppedLooting",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanLootEntity",
    "fullName": "CanLootEntity [StorageContainer]",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (IsLocked() || IsTransferring())\r\n\t{\r\n\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, LockedMessage, false);\r\n\t\treturn false;\r\n\t}\r\n\tif (onlyOneUser && IsOpen())\r\n\t{\r\n\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, InUseMessage, false);\r\n\t\treturn false;\r\n\t}\r\n\tif (panelToOpen == \"\")\r\n\t{\r\n\t\tpanelToOpen = panelName;\r\n\t}\r\n\tif (!CanOpenLootPanel(player, panelToOpen))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Open, b: true);\r\n\t\tAddContainers(player.inventory.loot);\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"RPC_OpenLootPanel\", player), panelToOpen);\r\n\t\tSendNetworkUpdate();\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "StorageContainer",
    "methodName": "PlayerOpenLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanBypassQueue",
    "fullName": "CanBypassQueue",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanJumpQueue(Network.Connection connection)\r\n{\r\n\tif (DeveloperList.Contains(connection.userid))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tServerUsers.User user = ServerUsers.Get(connection.userid);\r\n\tif (user != null && user.group == ServerUsers.UserGroup.Moderator)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (user != null && user.group == ServerUsers.UserGroup.Owner)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (user != null && user.group == ServerUsers.UserGroup.SkipQueue)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tfor (int i = 0; i < reservedSlots.Count; i++)\r\n\t{\r\n\t\tif (reservedSlots[i].UserId == connection.userid && reservedSlots[i].Expiry > UnityEngine.Time.realtimeSinceStartup)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "ConnectionQueue",
    "methodName": "CanJumpQueue",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPlayerRevive",
    "fullName": "OnPlayerRevive",
    "category": "Player",
    "parameters": [
      {
        "name": "medicalTool",
        "type": "MedicalTool, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GiveEffectsTo(BasePlayer player)\r\n{\r\n\tif (!player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemDefinition ownerItemDefinition = GetOwnerItemDefinition();\r\n\tItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();\r\n\tif (!component)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"No consumable for medicaltool :\" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\r\n\tif (player != ownerPlayer && player.IsWounded() && canRevive)\r\n\t{\r\n\t\tplayer.StopWounded(ownerPlayer);\r\n\t}\r\n\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\r\n\t{\r\n\t\tif (effect.type == MetabolismAttribute.Type.Health)\r\n\t\t{\r\n\t\t\tplayer.health += effect.amount;\r\n\t\t\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\r\n\t\t}\r\n\t}\r\n\tif (player is BasePet)\r\n\t{\r\n\t\tplayer.SendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "MedicalTool",
    "methodName": "GiveEffectsTo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanBeTargeted",
    "fullName": "CanBeTargeted [FlameTurret]",
    "category": "Player",
    "parameters": [
      {
        "name": "local4",
        "type": "System.Collections.Generic.HashSet`1[[BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "flameTurret",
        "type": "FlameTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CheckTrigger()\r\n{\r\n\tif (UnityEngine.Time.realtimeSinceStartup < nextTriggerCheckTime)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tnextTriggerCheckTime = UnityEngine.Time.realtimeSinceStartup + 1f / triggerCheckRate;\r\n\tSystem.Collections.Generic.List<UnityEngine.RaycastHit> obj = Facepunch.Pool.Get<System.Collections.Generic.List<UnityEngine.RaycastHit>>();\r\n\tSystem.Collections.Generic.HashSet<BaseEntity> entityContents = trigger.entityContents;\r\n\tBuildingPrivlidge cachedTc = GetCachedTc();\r\n\tbool flag = false;\r\n\tif (entityContents != null)\r\n\t{\r\n\t\tforeach (BaseEntity item in entityContents)\r\n\t\t{\r\n\t\t\tBasePlayer component = item.GetComponent<BasePlayer>();\r\n\t\t\tif (component.IsSleeping() || !component.IsAlive() || !(component.transform.position.y <= GetEyePosition().y + 0.5f) || (!(cachedTc == null) && cachedTc.IsAuthed(component)))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tobj.Clear();\r\n\t\t\tGamePhysics.TraceAll(new UnityEngine.Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\r\n\t\t\tfor (int i = 0; i < obj.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tBaseEntity entity = obj[i].GetEntity();\r\n\t\t\t\tif (entity != null && (entity == this || entity.EqualNetID(this)))\r\n\t\t\t\t{\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (flag)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\treturn flag;\r\n}\r\n",
    "targetName": "FlameTurret",
    "methodName": "CheckTrigger",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeTargeted [patch]",
    "fullName": "CanBeTargeted [FlameTurret] [cleanup]",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CheckTrigger()\r\n{\r\n\tif (UnityEngine.Time.realtimeSinceStartup < nextTriggerCheckTime)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tnextTriggerCheckTime = UnityEngine.Time.realtimeSinceStartup + 1f / triggerCheckRate;\r\n\tSystem.Collections.Generic.List<UnityEngine.RaycastHit> obj = Facepunch.Pool.Get<System.Collections.Generic.List<UnityEngine.RaycastHit>>();\r\n\tSystem.Collections.Generic.HashSet<BaseEntity> entityContents = trigger.entityContents;\r\n\tBuildingPrivlidge cachedTc = GetCachedTc();\r\n\tbool flag = false;\r\n\tif (entityContents != null)\r\n\t{\r\n\t\tforeach (BaseEntity item in entityContents)\r\n\t\t{\r\n\t\t\tBasePlayer component = item.GetComponent<BasePlayer>();\r\n\t\t\tif (component.IsSleeping() || !component.IsAlive() || !(component.transform.position.y <= GetEyePosition().y + 0.5f) || (!(cachedTc == null) && cachedTc.IsAuthed(component)))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tobj.Clear();\r\n\t\t\tGamePhysics.TraceAll(new UnityEngine.Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\r\n\t\t\tfor (int i = 0; i < obj.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tBaseEntity entity = obj[i].GetEntity();\r\n\t\t\t\tif (entity != null && (entity == this || entity.EqualNetID(this)))\r\n\t\t\t\t{\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (flag)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\treturn flag;\r\n}\r\n",
    "targetName": "FlameTurret",
    "methodName": "CheckTrigger",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanPickupEntity",
    "fullName": "CanPickupEntity",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseCombatEntity",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CanPickup(BasePlayer player)\r\n{\r\n\tif (pickup.enabled && (!pickup.requireBuildingPrivilege || player.CanBuild()) && (!pickup.requireHammer || player.IsHoldingEntity<Hammer>()))\r\n\t{\r\n\t\tif (player != null)\r\n\t\t{\r\n\t\t\treturn !player.IsInTutorial;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "BaseCombatEntity",
    "methodName": "CanPickup",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanAssignBed",
    "fullName": "CanAssignBed",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "sleepingBag",
        "type": "SleepingBag, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void AssignToFriend(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!msg.player.CanInteract() || deployerUserID != (ulong)msg.player.userID)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tulong num = msg.read.UInt64();\r\n\tif (num == 0L)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (ConVar.Server.max_sleeping_bags > 0)\r\n\t{\r\n\t\tSleepingBag.CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, num);\r\n\t\tif (canAssignBedResult.HasValue)\r\n\t\t{\r\n\t\t\tBasePlayer basePlayer = RelationshipManager.FindByID(num);\r\n\t\t\tif (canAssignBedResult.Value.Result == SleepingBag.BagResultType.TooManyBags)\r\n\t\t\t{\r\n\t\t\t\tif (basePlayer == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedNoPlayerPhrase, false);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tstring playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);\r\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedPhrase, false, playerNameStreamSafe);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (canAssignBedResult.Value.Result == SleepingBag.BagResultType.BagBlocked)\r\n\t\t\t{\r\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, bedAssigningBlocked, false);\r\n\t\t\t}\r\n\t\t\telse if (canAssignBedResult.Value.Result == SleepingBag.BagResultType.TargetIsPlayingTutorial)\r\n\t\t\t{\r\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, tutorialPhrase, false);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbasePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\r\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, (GetSleepingBagCount(msg.player.userID) - 1).ToString(), canAssignBedResult.Value.Max.ToString());\r\n\t\t\t}\r\n\t\t\tif (canAssignBedResult.Value.Result != 0)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tulong num2 = deployerUserID;\r\n\tdeployerUserID = num;\r\n\tNotifyPlayer(num2);\r\n\tNotifyPlayer(deployerUserID);\r\n\tOnBagChangedOwnership(this, num2);\r\n\tFacepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "SleepingBag",
    "methodName": "AssignToFriend",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanSetBedPublic",
    "fullName": "CanSetBedPublic",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "sleepingBag",
        "type": "SleepingBag, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic virtual void RPC_MakePublic(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!canBePublic || !msg.player.CanInteract() || (deployerUserID != (ulong)msg.player.userID && !msg.player.CanBuild()))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == IsPublic())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSetPublic(flag);\r\n\tif (!IsPublic())\r\n\t{\r\n\t\tif (ConVar.Server.max_sleeping_bags > 0)\r\n\t\t{\r\n\t\t\tSleepingBag.CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);\r\n\t\t\tif (canAssignBedResult.HasValue)\r\n\t\t\t{\r\n\t\t\t\tif (canAssignBedResult.Value.Result == SleepingBag.BagResultType.Ok)\r\n\t\t\t\t{\r\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\r\n\t\t\t\t}\r\n\t\t\t\tif (canAssignBedResult.Value.Result != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tulong num = deployerUserID;\r\n\t\tdeployerUserID = msg.player.userID;\r\n\t\tNotifyPlayer(num);\r\n\t\tNotifyPlayer(deployerUserID);\r\n\t\tOnBagChangedOwnership(this, num);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);\r\n\t}\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "SleepingBag",
    "methodName": "RPC_MakePublic",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanRenameBed",
    "fullName": "CanRenameBed",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "sleepingBag",
        "type": "SleepingBag, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void Rename(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract())\r\n\t{\r\n\t\tstring str = msg.read.String();\r\n\t\tstr = WordFilter.Filter(str);\r\n\t\tif (string.IsNullOrEmpty(str))\r\n\t\t{\r\n\t\t\tstr = \"Unnamed Sleeping Bag\";\r\n\t\t}\r\n\t\tif (str.Length > 24)\r\n\t\t{\r\n\t\t\tstr = str.Substring(0, 22) + \"..\";\r\n\t\t}\r\n\t\tniceName = str;\r\n\t\tSendNetworkUpdate();\r\n\t\tNotifyPlayer(deployerUserID);\r\n\t}\r\n}\r\n",
    "targetName": "SleepingBag",
    "methodName": "Rename",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerRespawn",
    "fullName": "OnPlayerRespawn [SleepingBag]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "SleepingBag, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)\r\n{\r\n\tSleepingBag[] array = FindForPlayer(player.userID, ignoreTimers: true);\r\n\tSleepingBag sleepingBag2 = System.Linq.Enumerable.FirstOrDefault(array, (SleepingBag x) => x.ValidForPlayer(player.userID, ignoreTimers: false) && x.net.ID == sleepingBag && x.unlockTime < UnityEngine.Time.realtimeSinceStartup);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (sleepingBag2.GetRespawnState(player.userID) != ProtoBuf.RespawnInformation.SpawnOptions.RespawnState.OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tsleepingBag2.GetSpawnPos(out var pos, out var rot);\r\n\tplayer.RespawnAt(pos, rot, sleepingBag2);\r\n\tsleepingBag2.PostPlayerSpawn(player);\r\n\tSleepingBag[] array2 = array;\r\n\tfor (int i = 0; i < array2.Length; i++)\r\n\t{\r\n\t\tSetBagTimer(array2[i], pos, SleepingBag.SleepingBagResetReason.Respawned, player);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "SleepingBag",
    "methodName": "SpawnPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanHideStash",
    "fullName": "CanHideStash",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "stashContainer",
        "type": "StashContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_HideStash(BaseEntity.RPCMessage rpc)\r\n{\r\n\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\r\n\tSetHidden(isHidden: true);\r\n}\r\n",
    "targetName": "StashContainer",
    "methodName": "RPC_HideStash",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerViolation",
    "fullName": "OnPlayerViolation",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void AddViolation(BasePlayer ply, AntiHackType type, float amount)\r\n{\r\n\tusing (TimeWarning.New(\"AntiHack.AddViolation\"))\r\n\t{\r\n\t\tply.lastViolationType = type;\r\n\t\tply.lastViolationTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\tply.violationLevel += amount;\r\n\t\tif (type == AntiHackType.NoClip || type == AntiHackType.FlyHack || type == AntiHackType.SpeedHack || type == AntiHackType.InsideGeometry || type == AntiHackType.InsideTerrain || type == AntiHackType.Ticks)\r\n\t\t{\r\n\t\t\tply.lastMovementViolationTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\t}\r\n\t\tif ((ConVar.AntiHack.debuglevel >= 2 && amount > 0f) || (ConVar.AntiHack.debuglevel >= 3 && type != AntiHackType.NoClip) || ConVar.AntiHack.debuglevel >= 4)\r\n\t\t{\r\n\t\t\tLogToConsole(ply, type, \"Added violation of \" + amount + \" in frame \" + UnityEngine.Time.frameCount + \" (now has \" + ply.violationLevel + \")\");\r\n\t\t}\r\n\t\tEnforceViolations(ply);\r\n\t}\r\n}\r\n",
    "targetName": "AntiHack",
    "methodName": "AddViolation",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanUseMailbox",
    "fullName": "CanUseMailbox",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "mailbox",
        "type": "Mailbox, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool PlayerIsOwner(BasePlayer player)\r\n{\r\n\treturn player.CanBuild();\r\n}\r\n",
    "targetName": "Mailbox",
    "methodName": "PlayerIsOwner",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnSpinWheel",
    "fullName": "OnSpinWheel",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "spinnerWheel",
        "type": "SpinnerWheel, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_Spin(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && AllowPlayerSpins() && (AnyoneSpin() || rpc.player.CanBuild()) && !(velocity > 15f))\r\n\t{\r\n\t\tvelocity += UnityEngine.Random.Range(4f, 7f);\r\n\t\tToggleChildEntityColliders(state: false);\r\n\t}\r\n}\r\n",
    "targetName": "SpinnerWheel",
    "methodName": "RPC_Spin",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanBeTargeted",
    "fullName": "CanBeTargeted [GunTrap]",
    "category": "Player",
    "parameters": [
      {
        "name": "local5",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "gunTrap",
        "type": "GunTrap, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CheckTrigger()\r\n{\r\n\tSystem.Collections.Generic.HashSet<BaseEntity> entityContents = trigger.entityContents;\r\n\tif (entityContents == null || entityContents.Count == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!CanFire())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tSystem.Collections.Generic.List<UnityEngine.RaycastHit> obj = Facepunch.Pool.Get<System.Collections.Generic.List<UnityEngine.RaycastHit>>();\r\n\tBuildingPrivlidge cachedTc = GetCachedTc();\r\n\tbool flag = false;\r\n\tforeach (BaseEntity item in entityContents)\r\n\t{\r\n\t\tBasePlayer component = item.GetComponent<BasePlayer>();\r\n\t\tif (component.IsSleeping() || !component.IsAlive() || (!(cachedTc == null) && cachedTc.IsAuthed(component)))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tobj.Clear();\r\n\t\tGamePhysics.TraceAll(new UnityEngine.Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\r\n\t\tfor (int i = 0; i < obj.Count; i++)\r\n\t\t{\r\n\t\t\tBaseEntity entity = obj[i].GetEntity();\r\n\t\t\tif (entity != null && (entity == this || entity.EqualNetID(this)))\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\treturn flag;\r\n}\r\n",
    "targetName": "GunTrap",
    "methodName": "CheckTrigger",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeTargeted [patch]",
    "fullName": "CanBeTargeted [GunTrap] [cleanup]",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CheckTrigger()\r\n{\r\n\tSystem.Collections.Generic.HashSet<BaseEntity> entityContents = trigger.entityContents;\r\n\tif (entityContents == null || entityContents.Count == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!CanFire())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tSystem.Collections.Generic.List<UnityEngine.RaycastHit> obj = Facepunch.Pool.Get<System.Collections.Generic.List<UnityEngine.RaycastHit>>();\r\n\tBuildingPrivlidge cachedTc = GetCachedTc();\r\n\tbool flag = false;\r\n\tforeach (BaseEntity item in entityContents)\r\n\t{\r\n\t\tBasePlayer component = item.GetComponent<BasePlayer>();\r\n\t\tif (component.IsSleeping() || !component.IsAlive() || (!(cachedTc == null) && cachedTc.IsAuthed(component)))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tobj.Clear();\r\n\t\tGamePhysics.TraceAll(new UnityEngine.Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\r\n\t\tfor (int i = 0; i < obj.Count; i++)\r\n\t\t{\r\n\t\t\tBaseEntity entity = obj[i].GetEntity();\r\n\t\t\tif (entity != null && (entity == this || entity.EqualNetID(this)))\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\treturn flag;\r\n}\r\n",
    "targetName": "GunTrap",
    "methodName": "CheckTrigger",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanPickupLock",
    "fullName": "CanPickupLock",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseLock",
        "type": "BaseLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f, CheckParent = true)]\r\npublic void RPC_TakeLock(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && CanRemove && !IsLocked())\r\n\t{\r\n\t\tItem item = ItemManager.Create(itemType, 1, skinID);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\trpc.player.GiveItem(item);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityPickedUp(rpc.player, this);\r\n\t\tBaseEntity baseEntity = GetParentEntity();\r\n\t\tif (baseEntity != null && baseEntity.GetSlot(BaseEntity.Slot.Lock) == this)\r\n\t\t{\r\n\t\t\tbaseEntity.SetSlot(BaseEntity.Slot.Lock, null);\r\n\t\t}\r\n\t\tKill();\r\n\t}\r\n}\r\n",
    "targetName": "BaseLock",
    "methodName": "RPC_TakeLock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanDismountEntity",
    "fullName": "CanDismountEntity",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseMountable",
        "type": "BaseMountable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DismountPlayer(BasePlayer player, bool lite = false)\r\n{\r\n\tif (_mounted == null || _mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseVehicle baseVehicle = VehicleParent();\r\n\tif (lite)\r\n\t{\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PrePlayerDismount(player, this);\r\n\t\t}\r\n\t\t_mounted.DismountObject();\r\n\t\t_mounted = null;\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t\t}\r\n\t\tOnPlayerDismounted(player);\r\n\t\treturn;\r\n\t}\r\n\tif (!GetDismountPosition(player, out var res) || Distance(res) > 10f)\r\n\t{\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PrePlayerDismount(player, this);\r\n\t\t}\r\n\t\tres = player.transform.position;\r\n\t\t_mounted.DismountObject();\r\n\t\t_mounted.MovePosition(res);\r\n\t\t_mounted.transform.rotation = UnityEngine.Quaternion.identity;\r\n\t\t_mounted.ClientRPC(RpcTarget.Player(\"ForcePositionTo\", _mounted), res);\r\n\t\tBasePlayer mounted = _mounted;\r\n\t\t_mounted = null;\r\n\t\tUnityEngine.Debug.LogWarning(\"Killing player due to invalid dismount point :\" + player.displayName + \" / \" + player.userID.Get() + \" on obj : \" + base.gameObject.name);\r\n\t\tmounted.Hurt(1000f, Rust.DamageType.Suicide, mounted, useProtection: false);\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t\t}\r\n\t\tOnPlayerDismounted(player);\r\n\t\treturn;\r\n\t}\r\n\tif (baseVehicle != null)\r\n\t{\r\n\t\tbaseVehicle.PrePlayerDismount(player, this);\r\n\t}\r\n\tif (AntiHack.TestNoClipping(_mounted, res, res, _mounted.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _, vehicleLayer: true))\r\n\t{\r\n\t\t_mounted.PauseVehicleNoClipDetection(5f);\r\n\t}\r\n\t_mounted.DismountObject();\r\n\t_mounted.transform.rotation = UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3.forward, UnityEngine.Vector3.up);\r\n\t_mounted.OverrideViewAngles(UnityEngine.Vector3.zero);\r\n\t_mounted.MovePosition(res);\r\n\t_mounted.SendNetworkUpdateImmediate();\r\n\t_mounted.SendModelState(force: true);\r\n\t_mounted = null;\r\n\tif (baseVehicle != null)\r\n\t{\r\n\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t}\r\n\tplayer.ForceUpdateTriggers();\r\n\tif ((bool)player.GetParentEntity())\r\n\t{\r\n\t\tBaseEntity baseEntity = player.GetParentEntity();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"ForcePositionToParentOffset\", player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"ForcePositionTo\", player), res);\r\n\t\tplayer.ClientRPC(RpcTarget.NetworkGroup(\"ForceResetRotation\", player));\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);\r\n\tOnPlayerDismounted(player);\r\n}\r\n",
    "targetName": "BaseMountable",
    "methodName": "DismountPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanMountEntity",
    "fullName": "CanMountEntity",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseMountable",
        "type": "BaseMountable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void MountPlayer(BasePlayer player)\r\n{\r\n\tif (!(_mounted != null) && !(mountAnchor == null))\r\n\t{\r\n\t\tplayer.EnsureDismounted();\r\n\t\t_mounted = player;\r\n\t\tUnityEngine.Transform transform = mountAnchor;\r\n\t\tplayer.SetMounted(this);\r\n\t\tplayer.MovePosition(transform.position);\r\n\t\tplayer.transform.rotation = transform.rotation;\r\n\t\tplayer.ServerRotation = transform.rotation;\r\n\t\tplayer.OverrideViewAngles(transform.rotation.eulerAngles);\r\n\t\t_mounted.eyes.NetworkUpdate(transform.rotation);\r\n\t\tplayer.SendNetworkUpdateImmediate();\r\n\t\tFacepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());\r\n\t\tOnPlayerMounted();\r\n\t\tif (this.IsValid() && player.IsValid())\r\n\t\t{\r\n\t\t\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseMountable",
    "methodName": "MountPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityMounted",
    "fullName": "OnEntityMounted",
    "category": "Player",
    "parameters": [
      {
        "name": "baseMountable",
        "type": "BaseMountable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void MountPlayer(BasePlayer player)\r\n{\r\n\tif (!(_mounted != null) && !(mountAnchor == null))\r\n\t{\r\n\t\tplayer.EnsureDismounted();\r\n\t\t_mounted = player;\r\n\t\tUnityEngine.Transform transform = mountAnchor;\r\n\t\tplayer.SetMounted(this);\r\n\t\tplayer.MovePosition(transform.position);\r\n\t\tplayer.transform.rotation = transform.rotation;\r\n\t\tplayer.ServerRotation = transform.rotation;\r\n\t\tplayer.OverrideViewAngles(transform.rotation.eulerAngles);\r\n\t\t_mounted.eyes.NetworkUpdate(transform.rotation);\r\n\t\tplayer.SendNetworkUpdateImmediate();\r\n\t\tFacepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());\r\n\t\tOnPlayerMounted();\r\n\t\tif (this.IsValid() && player.IsValid())\r\n\t\t{\r\n\t\t\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseMountable",
    "methodName": "MountPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerWantsDismount",
    "fullName": "OnPlayerWantsDismount",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseMountable",
        "type": "BaseMountable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void RPC_WantsDismount(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (HasValidDismountPosition(player) && (!(player != null) || !player.IsRestrained))\r\n\t{\r\n\t\tAttemptDismount(player);\r\n\t}\r\n}\r\n",
    "targetName": "BaseMountable",
    "methodName": "RPC_WantsDismount",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerWantsMount",
    "fullName": "OnPlayerWantsMount",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseMountable",
        "type": "BaseMountable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void WantsMount(BasePlayer player)\r\n{\r\n\tif (!player.IsValid() || !player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!DirectlyMountable())\r\n\t{\r\n\t\tBaseVehicle baseVehicle = VehicleParent();\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.WantsMount(player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tAttemptMount(player);\r\n}\r\n",
    "targetName": "BaseMountable",
    "methodName": "WantsMount",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanSwapToSeat",
    "fullName": "CanSwapToSeat [BaseMountable]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseMountable",
        "type": "BaseMountable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CanSwapToThis(BasePlayer player)\r\n{\r\n\treturn true;\r\n}\r\n",
    "targetName": "BaseMountable",
    "methodName": "CanSwapToThis",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPlayerDismountFailed",
    "fullName": "OnPlayerDismountFailed",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseMountable",
        "type": "BaseMountable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void RPC_WantsDismount(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (HasValidDismountPosition(player) && (!(player != null) || !player.IsRestrained))\r\n\t{\r\n\t\tAttemptDismount(player);\r\n\t}\r\n}\r\n",
    "targetName": "BaseMountable",
    "methodName": "RPC_WantsDismount",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerActiveShieldDrop",
    "fullName": "OnPlayerActiveShieldDrop",
    "category": "Player",
    "parameters": [
      {
        "name": "playerBelt",
        "type": "PlayerBelt, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Shield, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DropActive(UnityEngine.Vector3 position, UnityEngine.Vector3 velocity)\r\n{\r\n\tif (player.GetActiveShield(out var foundShield))\r\n\t{\r\n\t\tDroppedItem droppedItem = foundShield.GetItem().Drop(position, velocity) as DroppedItem;\r\n\t\tif (droppedItem != null)\r\n\t\t{\r\n\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Death;\r\n\t\t\tdroppedItem.DroppedBy = player.userID;\r\n\t\t\tdroppedItem.DroppedTime = System.DateTime.UtcNow;\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(player, droppedItem, DroppedItem.DropReasonEnum.Death);\r\n\t\t}\r\n\t}\r\n\tItem activeItem = player.GetActiveItem();\r\n\tif (activeItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"PlayerBelt.DropActive\"))\r\n\t{\r\n\t\tDroppedItem droppedItem2 = activeItem.Drop(position, velocity) as DroppedItem;\r\n\t\tif (droppedItem2 != null)\r\n\t\t{\r\n\t\t\tdroppedItem2.DropReason = DroppedItem.DropReasonEnum.Death;\r\n\t\t\tdroppedItem2.DroppedBy = player.userID;\r\n\t\t\tdroppedItem2.DroppedTime = System.DateTime.UtcNow;\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(player, droppedItem2, DroppedItem.DropReasonEnum.Death);\r\n\t\t}\r\n\t\tplayer.svActiveItemID = default(ItemId);\r\n\t\tplayer.SendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "PlayerBelt",
    "methodName": "DropActive",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerDropActiveItem",
    "fullName": "OnPlayerDropActiveItem",
    "category": "Player",
    "parameters": [
      {
        "name": "playerBelt",
        "type": "PlayerBelt, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DropActive(UnityEngine.Vector3 position, UnityEngine.Vector3 velocity)\r\n{\r\n\tif (player.GetActiveShield(out var foundShield))\r\n\t{\r\n\t\tDroppedItem droppedItem = foundShield.GetItem().Drop(position, velocity) as DroppedItem;\r\n\t\tif (droppedItem != null)\r\n\t\t{\r\n\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Death;\r\n\t\t\tdroppedItem.DroppedBy = player.userID;\r\n\t\t\tdroppedItem.DroppedTime = System.DateTime.UtcNow;\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(player, droppedItem, DroppedItem.DropReasonEnum.Death);\r\n\t\t}\r\n\t}\r\n\tItem activeItem = player.GetActiveItem();\r\n\tif (activeItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"PlayerBelt.DropActive\"))\r\n\t{\r\n\t\tDroppedItem droppedItem2 = activeItem.Drop(position, velocity) as DroppedItem;\r\n\t\tif (droppedItem2 != null)\r\n\t\t{\r\n\t\t\tdroppedItem2.DropReason = DroppedItem.DropReasonEnum.Death;\r\n\t\t\tdroppedItem2.DroppedBy = player.userID;\r\n\t\t\tdroppedItem2.DroppedTime = System.DateTime.UtcNow;\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(player, droppedItem2, DroppedItem.DropReasonEnum.Death);\r\n\t\t}\r\n\t\tplayer.svActiveItemID = default(ItemId);\r\n\t\tplayer.SendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "PlayerBelt",
    "methodName": "DropActive",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanLootEntity",
    "fullName": "CanLootEntity [ResourceContainer]",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "resourceContainer",
        "type": "ResourceContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void StartLootingContainer(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif ((bool)player && player.CanInteract() && lootable && player.inventory.loot.StartLootingEntity(base.baseEntity))\r\n\t{\r\n\t\tlastAccessTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\tplayer.inventory.loot.AddContainer(container);\r\n\t}\r\n}\r\n",
    "targetName": "ResourceContainer",
    "methodName": "StartLootingContainer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanLootEntity",
    "fullName": "CanLootEntity [DroppedItemContainer]",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "droppedItemContainer",
        "type": "DroppedItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_OpenLoot(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (inventory != null)\r\n\t{\r\n\t\tBasePlayer player = rpc.player;\r\n\t\tif ((bool)player && player.CanInteract() && player.inventory.loot.StartLootingEntity(this))\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Open, b: true);\r\n\t\t\tplayer.inventory.loot.AddContainer(inventory);\r\n\t\t\tplayer.inventory.loot.SendImmediate();\r\n\t\t\tplayer.ClientRPC(RpcTarget.Player(\"RPC_OpenLootPanel\", player), lootPanelName);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "DroppedItemContainer",
    "methodName": "RPC_OpenLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLootEntityEnd",
    "fullName": "OnLootEntityEnd [DroppedItemContainer]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "droppedItemContainer",
        "type": "DroppedItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void PlayerStoppedLooting(BasePlayer player)\r\n{\r\n\tif (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)\r\n\t{\r\n\t\tKill();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tResetRemovalTime();\r\n\t\tSetFlag(BaseEntity.Flags.Open, b: false);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n\tEvaluateBagConditions();\r\n}\r\n",
    "targetName": "DroppedItemContainer",
    "methodName": "PlayerStoppedLooting",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanHackCrate",
    "fullName": "CanHackCrate",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "hackableLockedCrate",
        "type": "HackableLockedCrate, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Hack(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!IsBeingHacked())\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);\r\n\t\toriginalHackerPlayerId = msg.player.userID;\r\n\t\toriginalHackerPlayer = msg.player;\r\n\t\tStartHacking();\r\n\t}\r\n}\r\n",
    "targetName": "HackableLockedCrate",
    "methodName": "RPC_Hack",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnExperimentStart",
    "fullName": "OnExperimentStart",
    "category": "Player",
    "parameters": [
      {
        "name": "workbench",
        "type": "Workbench, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_BeginExperiment(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (player == null || IsWorking())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;\r\n\tint num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);\r\n\tfor (int i = 0; i < experimentalItems.subSpawn.Length; i++)\r\n\t{\r\n\t\tint num2 = i + num;\r\n\t\tif (num2 >= experimentalItems.subSpawn.Length)\r\n\t\t{\r\n\t\t\tnum2 -= experimentalItems.subSpawn.Length;\r\n\t\t}\r\n\t\tItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;\r\n\t\tif ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))\r\n\t\t{\r\n\t\t\tpendingBlueprint = itemDef;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (pendingBlueprint == null)\r\n\t{\r\n\t\tplayer.ChatMessage(\"You have already unlocked everything for this workbench tier.\");\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(0);\r\n\tif (slot != null)\r\n\t{\r\n\t\tif (!slot.MoveToContainer(player.inventory.containerMain))\r\n\t\t{\r\n\t\t\tslot.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t}\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t}\r\n\tif (experimentStartEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(experimentStartEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\tbase.inventory.SetLocked(isLocked: true);\r\n\tCancelInvoke(ExperimentComplete);\r\n\tInvoke(ExperimentComplete, 5f);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "Workbench",
    "methodName": "RPC_BeginExperiment",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnExperimentStarted",
    "fullName": "OnExperimentStarted",
    "category": "Player",
    "parameters": [
      {
        "name": "workbench",
        "type": "Workbench, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_BeginExperiment(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (player == null || IsWorking())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;\r\n\tint num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);\r\n\tfor (int i = 0; i < experimentalItems.subSpawn.Length; i++)\r\n\t{\r\n\t\tint num2 = i + num;\r\n\t\tif (num2 >= experimentalItems.subSpawn.Length)\r\n\t\t{\r\n\t\t\tnum2 -= experimentalItems.subSpawn.Length;\r\n\t\t}\r\n\t\tItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;\r\n\t\tif ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))\r\n\t\t{\r\n\t\t\tpendingBlueprint = itemDef;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (pendingBlueprint == null)\r\n\t{\r\n\t\tplayer.ChatMessage(\"You have already unlocked everything for this workbench tier.\");\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(0);\r\n\tif (slot != null)\r\n\t{\r\n\t\tif (!slot.MoveToContainer(player.inventory.containerMain))\r\n\t\t{\r\n\t\t\tslot.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t}\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t}\r\n\tif (experimentStartEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(experimentStartEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\tbase.inventory.SetLocked(isLocked: true);\r\n\tCancelInvoke(ExperimentComplete);\r\n\tInvoke(ExperimentComplete, 5f);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "Workbench",
    "methodName": "RPC_BeginExperiment",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnExperimentEnd",
    "fullName": "OnExperimentEnd",
    "category": "Player",
    "parameters": [
      {
        "name": "workbench",
        "type": "Workbench, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ExperimentComplete()\r\n{\r\n\tItem experimentResourceItem = GetExperimentResourceItem();\r\n\tint scrapForExperiment = GetScrapForExperiment();\r\n\tif (pendingBlueprint == null)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Pending blueprint was null!\");\r\n\t}\r\n\tif (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)\r\n\t{\r\n\t\texperimentResourceItem.UseItem(scrapForExperiment);\r\n\t\tItem item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);\r\n\t\titem.blueprintTarget = pendingBlueprint.itemid;\r\n\t\tcreatingBlueprint = true;\r\n\t\tif (!item.MoveToContainer(base.inventory, 0))\r\n\t\t{\r\n\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t}\r\n\t\tcreatingBlueprint = false;\r\n\t\tif (experimentSuccessEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\t}\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.On, b: false);\r\n\tpendingBlueprint = null;\r\n\tbase.inventory.SetLocked(isLocked: false);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "Workbench",
    "methodName": "ExperimentComplete",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnExperimentEnded",
    "fullName": "OnExperimentEnded",
    "category": "Player",
    "parameters": [
      {
        "name": "workbench",
        "type": "Workbench, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ExperimentComplete()\r\n{\r\n\tItem experimentResourceItem = GetExperimentResourceItem();\r\n\tint scrapForExperiment = GetScrapForExperiment();\r\n\tif (pendingBlueprint == null)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Pending blueprint was null!\");\r\n\t}\r\n\tif (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)\r\n\t{\r\n\t\texperimentResourceItem.UseItem(scrapForExperiment);\r\n\t\tItem item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);\r\n\t\titem.blueprintTarget = pendingBlueprint.itemid;\r\n\t\tcreatingBlueprint = true;\r\n\t\tif (!item.MoveToContainer(base.inventory, 0))\r\n\t\t{\r\n\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t}\r\n\t\tcreatingBlueprint = false;\r\n\t\tif (experimentSuccessEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\t}\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.On, b: false);\r\n\tpendingBlueprint = null;\r\n\tbase.inventory.SetLocked(isLocked: false);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "Workbench",
    "methodName": "ExperimentComplete",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "ICanPickupEntity",
    "fullName": "ICanPickupEntity [DoorCloser]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "doorCloser",
        "type": "DoorCloser, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_Take(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!rpc.player.CanInteract() || !rpc.player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDoor door = GetDoor();\r\n\tif (!(door == null) && door.GetPlayerLockPermission(rpc.player))\r\n\t{\r\n\t\tItem item = ItemManager.Create(itemType, 1, skinID);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\trpc.player.GiveItem(item);\r\n\t\t}\r\n\t\tKill();\r\n\t}\r\n}\r\n",
    "targetName": "DoorCloser",
    "methodName": "RPC_Take",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanTakeCutting",
    "fullName": "CanTakeCutting",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "growableEntity",
        "type": "GrowableEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TakeClones(BasePlayer player)\r\n{\r\n\tif (player == null || !CanClone())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = Properties.BaseCloneCount + Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;\r\n\tif (num > 0)\r\n\t{\r\n\t\tItem item = ItemManager.Create(Properties.CloneItem, num, 0uL);\r\n\t\titem.SetItemOwnership(player, ItemOwnershipPhrases.Cloned);\r\n\t\tGrowableGeneEncoding.EncodeGenesToItem(this, item);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);\r\n\t\tplayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\tif (Properties.pickEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\tTellPlanter();\r\n\t\tDie();\r\n\t}\r\n}\r\n",
    "targetName": "GrowableEntity",
    "methodName": "TakeClones",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPayForUpgrade",
    "fullName": "OnPayForUpgrade",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "buildingBlock",
        "type": "BuildingBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "g",
        "type": "ConstructionGrade, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void PayForUpgrade(ConstructionGrade g, BasePlayer player)\r\n{\r\n\tif (player.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<Item> list = new System.Collections.Generic.List<Item>();\r\n\tforeach (ItemAmount item in g.CostToBuild(grade))\r\n\t{\r\n\t\tplayer.inventory.Take(list, item.itemid, (int)item.amount);\r\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemid);\r\n\t\tFacepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, \"upgrade_block\", itemDefinition.shortname, (int)item.amount, this, null, safezone: false, null, player.userID);\r\n\t\tplayer.Command(\"note.inv \" + item.itemid + \" \" + item.amount * -1f);\r\n\t}\r\n\tforeach (Item item2 in list)\r\n\t{\r\n\t\titem2.Remove();\r\n\t}\r\n}\r\n",
    "targetName": "BuildingBlock",
    "methodName": "PayForUpgrade",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPayForPlacement",
    "fullName": "OnPayForPlacement",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "planner",
        "type": "Planner, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "component",
        "type": "Construction, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void PayForPlacement(BasePlayer player, Construction component)\r\n{\r\n\tif (player.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.IsInTutorial)\r\n\t{\r\n\t\tTutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();\r\n\t\tif (currentTutorialIsland != null)\r\n\t\t{\r\n\t\t\tcurrentTutorialIsland.OnPlayerBuiltConstruction(player);\r\n\t\t}\r\n\t}\r\n\tif (isTypeDeployable)\r\n\t{\r\n\t\tGetItem().UseItem();\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<Item> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Item>>();\r\n\tforeach (ItemAmount item in component.defaultGrade.CostToBuild())\r\n\t{\r\n\t\tplayer.inventory.Take(obj, item.itemDef.itemid, (int)item.amount);\r\n\t\tplayer.Command(\"note.inv\", item.itemDef.itemid, item.amount * -1f);\r\n\t}\r\n\tforeach (Item item2 in obj)\r\n\t{\r\n\t\titem2.Remove();\r\n\t}\r\n\tFacepunch.Pool.Free(ref obj, freeElements: false);\r\n}\r\n",
    "targetName": "Planner",
    "methodName": "PayForPlacement",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWireConnect",
    "fullName": "OnWireConnect",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local5",
        "type": "IOEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local6",
        "type": "IOEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "linePoints",
        "type": "System.Collections.Generic.List`1[[UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local7",
        "type": "System.Collections.Generic.List`1[[System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void RPC_MakeConnection(BaseEntity.RPCMessage rpc)\r\n{\r\n\tBasePlayer player = rpc.player;\r\n\tif (!CanPlayerUseWires(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.WireConnectionMessage wireConnectionMessage = ProtoBuf.WireConnectionMessage.Deserialize(rpc.read);\r\n\tSystem.Collections.Generic.List<UnityEngine.Vector3> linePoints = wireConnectionMessage.linePoints;\r\n\tint inputIndex = wireConnectionMessage.inputIndex;\r\n\tint outputIndex = wireConnectionMessage.outputIndex;\r\n\tIOEntity iOEntity = new EntityRef<IOEntity>(wireConnectionMessage.inputID).Get(serverside: true);\r\n\tIOEntity iOEntity2 = new EntityRef<IOEntity>(wireConnectionMessage.outputID).Get(serverside: true);\r\n\tif (!(iOEntity == null) && !(iOEntity2 == null) && ValidateLine(linePoints, iOEntity, iOEntity2, player, outputIndex) && inputIndex < iOEntity.inputs.Length && outputIndex < iOEntity2.outputs.Length && !(iOEntity.inputs[inputIndex].connectedTo.Get() != null) && !(iOEntity2.outputs[outputIndex].connectedTo.Get() != null) && (!iOEntity.inputs[inputIndex].rootConnectionsOnly || iOEntity2.IsRootEntity()) && CanModifyEntity(player, iOEntity) && CanModifyEntity(player, iOEntity2))\r\n\t{\r\n\t\tSystem.Collections.Generic.List<float> slackLevels = wireConnectionMessage.slackLevels;\r\n\t\tIOEntity.LineAnchor[] array = new IOEntity.LineAnchor[wireConnectionMessage.lineAnchors.Count];\r\n\t\tfor (int i = 0; i < wireConnectionMessage.lineAnchors.Count; i++)\r\n\t\t{\r\n\t\t\tProtoBuf.WireLineAnchorInfo wireLineAnchorInfo = wireConnectionMessage.lineAnchors[i];\r\n\t\t\tarray[i].entityRef = new EntityRef<Door>(wireLineAnchorInfo.parentID);\r\n\t\t\tarray[i].boneName = wireLineAnchorInfo.boneName;\r\n\t\t\tarray[i].index = (int)wireLineAnchorInfo.index;\r\n\t\t\tarray[i].position = wireLineAnchorInfo.position;\r\n\t\t}\r\n\t\tWireTool.WireColour wireColour = IntToColour(wireConnectionMessage.wireColor);\r\n\t\tif (wireColour == WireTool.WireColour.Invisible && !player.IsInCreativeMode)\r\n\t\t{\r\n\t\t\twireColour = DefaultColor;\r\n\t\t}\r\n\t\tiOEntity2.ConnectTo(iOEntity, outputIndex, inputIndex, linePoints, slackLevels, array, wireColour);\r\n\t\tif (wireType == IOEntity.IOType.Industrial)\r\n\t\t{\r\n\t\t\tiOEntity.NotifyIndustrialNetworkChanged();\r\n\t\t\tiOEntity2.NotifyIndustrialNetworkChanged();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WireTool",
    "methodName": "RPC_MakeConnection",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWireClear",
    "fullName": "OnWireClear",
    "category": "Player",
    "parameters": [
      {
        "name": "ply",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "IOEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "clearIndex",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "isInput",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)\r\n{\r\n\tIOEntity iOEntity = ((clearEnt != null) ? clearEnt.GetComponent<IOEntity>() : null);\r\n\tif (iOEntity == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (ply != null && !CanModifyEntity(ply, iOEntity))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn iOEntity.Disconnect(clearIndex, isInput);\r\n}\r\n",
    "targetName": "WireTool",
    "methodName": "AttemptClearSlot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanUseWires",
    "fullName": "CanUseWires",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool CanPlayerUseWires(BasePlayer player, bool cached = false, float cacheDuration = 1f)\r\n{\r\n\tif (player != null && player.IsInCreativeMode && ConVar.Creative.unlimitedIo)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (!player.CanBuild(cached, cacheDuration))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tSystem.Collections.Generic.List<UnityEngine.Collider> obj = Facepunch.Pool.Get<System.Collections.Generic.List<UnityEngine.Collider>>();\r\n\tGamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj, 536870912, UnityEngine.QueryTriggerInteraction.Collide);\r\n\tbool result = true;\r\n\tforeach (UnityEngine.Collider item in obj)\r\n\t{\r\n\t\tif (!item.gameObject.CompareTag(\"IgnoreWireCheck\"))\r\n\t\t{\r\n\t\t\tresult = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\treturn result;\r\n}\r\n",
    "targetName": "WireTool",
    "methodName": "CanPlayerUseWires",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPlayerStudyBlueprint",
    "fullName": "OnPlayerStudyBlueprint",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void ServerCommand(Item item, string command, BasePlayer player)\r\n{\r\n\tif (command != \"study\" || !item.IsBlueprint())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (item.GetOwnerPlayer() != player && player.inventory.GetBackpackWithInventory()?.contents != item.parent)\r\n\t{\r\n\t\tbool flag = false;\r\n\t\tforeach (ItemContainer container in player.inventory.loot.containers)\r\n\t\t{\r\n\t\t\tif (item.GetRootContainer() == container)\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (IsBlueprintUnlocked(item, player, out var blueprintTargetDef, out var blueprint))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem item2 = item;\r\n\tif (item.amount > 1)\r\n\t{\r\n\t\titem2 = item.SplitItem(1);\r\n\t}\r\n\titem2.UseItem();\r\n\tplayer.blueprints.Unlock(blueprintTargetDef);\r\n\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, \"blueprint\", ResearchTable.ScrapForResearch(blueprintTargetDef), player);\r\n\tif (blueprint != null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)\r\n\t{\r\n\t\tforeach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)\r\n\t\t{\r\n\t\t\tplayer.blueprints.Unlock(additionalUnlock);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, additionalUnlock, \"blueprint\", 0, player);\r\n\t\t}\r\n\t}\r\n\tif (studyEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(studyEffect.resourcePath, player, StringPool.Get(\"head\"), UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t}\r\n}\r\n",
    "targetName": "ItemModStudyBlueprint",
    "methodName": "ServerCommand",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanLootEntity",
    "fullName": "CanLootEntity [BaseRidableAnimal]",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseRidableAnimal",
        "type": "BaseRidableAnimal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_OpenLoot(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (storageInventory == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = rpc.player;\r\n\tstring text = rpc.read.String();\r\n\tif ((bool)player && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && player.inventory.loot.StartLootingEntity(this))\r\n\t{\r\n\t\tItemContainer container = equipmentInventory;\r\n\t\tstring arg = lootPanelName;\r\n\t\tif (text == \"storage\")\r\n\t\t{\r\n\t\t\targ = storagePanelName;\r\n\t\t\tcontainer = storageInventory;\r\n\t\t}\r\n\t\tplayer.inventory.loot.AddContainer(container);\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"RPC_OpenLootPanel\", player), arg);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "BaseRidableAnimal",
    "methodName": "RPC_OpenLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanLootEntity",
    "fullName": "CanLootEntity [RidableHorse2]",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "ridableHorse2",
        "type": "RidableHorse2, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_OpenLoot(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (storageInventory == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = rpc.player;\r\n\tstring text = rpc.read.String();\r\n\tif (!(player == null) && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && player.inventory.loot.StartLootingEntity(this))\r\n\t{\r\n\t\tItemContainer container = equipmentInventory;\r\n\t\tstring arg = lootPanelName;\r\n\t\tif (text == \"storage\")\r\n\t\t{\r\n\t\t\targ = storagePanelName;\r\n\t\t\tcontainer = storageInventory;\r\n\t\t}\r\n\t\tplayer.inventory.loot.AddContainer(container);\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"RPC_OpenLootPanel\", player), arg);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "RidableHorse2",
    "methodName": "SERVER_OpenLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnClothingItemChanged",
    "fullName": "OnClothingItemChanged",
    "category": "Player",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "bAdded",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnClothingChanged(Item item, bool bAdded)\r\n{\r\n\tbase.baseEntity.SV_ClothingChanged();\r\n\tif (ItemManager.EnablePooling)\r\n\t{\r\n\t\tif (!IsInvoking(DeferredServerUpdateAction))\r\n\t\t{\r\n\t\t\tInvoke(DeferredServerUpdateAction, 0f);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tItemManager.DoRemoves();\r\n\t\tServerUpdate(0f);\r\n\t}\r\n\tif (item.position == 7)\r\n\t{\r\n\t\titem.RecalulateParentEntity(children: true);\r\n\t\tInvoke(UpdatedVisibleHolsteredItems, 0.1f);\r\n\t\tif (base.baseEntity.GetHeldEntity() != null)\r\n\t\t{\r\n\t\t\tbase.baseEntity.GetHeldEntity().UpdateShieldState(bHeld: true);\r\n\t\t}\r\n\t\titem?.contents?.onItemAddedRemoved?.Invoke(item, bAdded);\r\n\t}\r\n\tbase.baseEntity.ProcessMissionEvent(BaseMission.MissionEventType.CLOTHINGCHANGED, 0, 0f);\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "OnClothingChanged",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDefaultItemsReceive",
    "fullName": "OnDefaultItemsReceive",
    "category": "Player",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GiveDefaultItems()\r\n{\r\n\tStrip();\r\n\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\r\n\tif (activeGameMode != null && activeGameMode.HasLoadouts())\r\n\t{\r\n\t\tBaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);\r\n\t\treturn;\r\n\t}\r\n\tGiveDefaultItemWithSkin(\"client.rockskin\", \"rock\");\r\n\tGiveDefaultItemWithSkin(\"client.torchskin\", \"torch\");\r\n\tif (IsBirthday() && !base.baseEntity.IsInTutorial)\r\n\t{\r\n\t\tGiveItem(ItemManager.CreateByName(\"cakefiveyear\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\tGiveItem(ItemManager.CreateByName(\"partyhat\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerWear);\r\n\t}\r\n\tif (IsChristmas() && !base.baseEntity.IsInTutorial)\r\n\t{\r\n\t\tGiveItem(ItemManager.CreateByName(\"snowball\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\tGiveItem(ItemManager.CreateByName(\"snowball\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\tGiveItem(ItemManager.CreateByName(\"snowball\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t}\r\n\tvoid GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)\r\n\t{\r\n\t\tulong num = 0uL;\r\n\t\tint infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);\r\n\t\tbool flag = false;\r\n\t\tbool flag2 = false;\r\n\t\tflag2 = base.baseEntity?.UnlockAllSkins ?? false;\r\n\t\tif (infoInt > 0 && (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))\r\n\t\t{\r\n\t\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);\r\n\t\t\tif (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)\r\n\t\t\t{\r\n\t\t\t\tIPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);\r\n\t\t\t\tif (itemDefinition2 != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tnum = itemDefinition2.WorkshopDownload;\r\n\t\t\t\t}\r\n\t\t\t\tif (num == 0L && itemDefinition.skins != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tItemSkinDirectory.Skin[] skins = itemDefinition.skins;\r\n\t\t\t\t\tfor (int i = 0; i < skins.Length; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tItemSkinDirectory.Skin skin = skins[i];\r\n\t\t\t\t\t\tif (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tGiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\t\t\t\t\t\tflag = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tGiveItem(ItemManager.CreateByName(itemShortName, 1, num).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "GiveDefaultItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDefaultItemsReceived",
    "fullName": "OnDefaultItemsReceived",
    "category": "Player",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GiveDefaultItems()\r\n{\r\n\tStrip();\r\n\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\r\n\tif (activeGameMode != null && activeGameMode.HasLoadouts())\r\n\t{\r\n\t\tBaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);\r\n\t\treturn;\r\n\t}\r\n\tGiveDefaultItemWithSkin(\"client.rockskin\", \"rock\");\r\n\tGiveDefaultItemWithSkin(\"client.torchskin\", \"torch\");\r\n\tif (IsBirthday() && !base.baseEntity.IsInTutorial)\r\n\t{\r\n\t\tGiveItem(ItemManager.CreateByName(\"cakefiveyear\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\tGiveItem(ItemManager.CreateByName(\"partyhat\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerWear);\r\n\t}\r\n\tif (IsChristmas() && !base.baseEntity.IsInTutorial)\r\n\t{\r\n\t\tGiveItem(ItemManager.CreateByName(\"snowball\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\tGiveItem(ItemManager.CreateByName(\"snowball\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\tGiveItem(ItemManager.CreateByName(\"snowball\", 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t}\r\n\tvoid GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)\r\n\t{\r\n\t\tulong num = 0uL;\r\n\t\tint infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);\r\n\t\tbool flag = false;\r\n\t\tbool flag2 = false;\r\n\t\tflag2 = base.baseEntity?.UnlockAllSkins ?? false;\r\n\t\tif (infoInt > 0 && (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))\r\n\t\t{\r\n\t\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);\r\n\t\t\tif (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)\r\n\t\t\t{\r\n\t\t\t\tIPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);\r\n\t\t\t\tif (itemDefinition2 != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tnum = itemDefinition2.WorkshopDownload;\r\n\t\t\t\t}\r\n\t\t\t\tif (num == 0L && itemDefinition.skins != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tItemSkinDirectory.Skin[] skins = itemDefinition.skins;\r\n\t\t\t\t\tfor (int i = 0; i < skins.Length; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tItemSkinDirectory.Skin skin = skins[i];\r\n\t\t\t\t\t\tif (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tGiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\t\t\t\t\t\tflag = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tGiveItem(ItemManager.CreateByName(itemShortName, 1, num).SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase), containerBelt);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "GiveDefaultItems",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnInventoryNetworkUpdate",
    "fullName": "OnInventoryNetworkUpdate",
    "category": "Player",
    "parameters": [
      {
        "name": "playerInventory",
        "type": "PlayerInventory, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "container",
        "type": "ItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ProtoBuf.UpdateItemContainer, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "type",
        "type": "PlayerInventory+Type, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "mode",
        "type": "PlayerInventory+NetworkInventoryMode, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendUpdatedInventoryInternal(PlayerInventory.Type type, ItemContainer container, PlayerInventory.NetworkInventoryMode mode)\r\n{\r\n\tusing ProtoBuf.UpdateItemContainer updateItemContainer = Facepunch.Pool.Get<ProtoBuf.UpdateItemContainer>();\r\n\tupdateItemContainer.type = (int)type;\r\n\tif (container != null)\r\n\t{\r\n\t\tcontainer.dirty = false;\r\n\t\tupdateItemContainer.container = Facepunch.Pool.Get<System.Collections.Generic.List<ProtoBuf.ItemContainer>>();\r\n\t\tbool bIncludeContainer = type != PlayerInventory.Type.Wear || mode == PlayerInventory.NetworkInventoryMode.LocalPlayer;\r\n\t\tupdateItemContainer.container.Add(container.Save(bIncludeContainer));\r\n\t}\r\n\tswitch (mode)\r\n\t{\r\n\tcase PlayerInventory.NetworkInventoryMode.Everyone:\r\n\t\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\"UpdatedItemContainer\"), updateItemContainer);\r\n\t\tbreak;\r\n\tcase PlayerInventory.NetworkInventoryMode.LocalPlayer:\r\n\t\tbase.baseEntity.ClientRPC(RpcTarget.Player(\"UpdatedItemContainer\", base.baseEntity), updateItemContainer);\r\n\t\tbreak;\r\n\tcase PlayerInventory.NetworkInventoryMode.EveryoneButLocal:\r\n\t\tif (base.baseEntity.net?.group?.subscribers == null)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t{\r\n\t\t\tforeach (Network.Connection subscriber in base.baseEntity.net.group.subscribers)\r\n\t\t\t{\r\n\t\t\t\tif (subscriber.player is BasePlayer basePlayer && basePlayer != base.baseEntity)\r\n\t\t\t\t{\r\n\t\t\t\t\tbase.baseEntity.ClientRPC(RpcTarget.Player(\"UpdatedItemContainer\", basePlayer), updateItemContainer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "PlayerInventory",
    "methodName": "SendUpdatedInventoryInternal",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanRagdollDismount",
    "fullName": "CanRagdollDismount",
    "category": "Player",
    "parameters": [
      {
        "name": "baseRagdoll",
        "type": "BaseRagdoll, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool AllowPlayerInstigatedDismount(BasePlayer player)\r\n{\r\n\treturn false;\r\n}\r\n",
    "targetName": "BaseRagdoll",
    "methodName": "AllowPlayerInstigatedDismount",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanUpdateSign",
    "fullName": "CanUpdateSign [PhotoFrame]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "photoFrame",
        "type": "PhotoFrame, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanUpdateSign(BasePlayer player)\r\n{\r\n\tif (player.IsAdmin || player.IsDeveloper)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (!player.CanBuild())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (IsLocked())\r\n\t{\r\n\t\treturn (ulong)player.userID == base.OwnerID;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "PhotoFrame",
    "methodName": "CanUpdateSign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnLootEntityEnd",
    "fullName": "OnLootEntityEnd [ContainerIOEntity]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "containerIOEntity",
        "type": "ContainerIOEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void PlayerStoppedLooting(BasePlayer player)\r\n{\r\n\tSetFlag(BaseEntity.Flags.Open, b: false);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "ContainerIOEntity",
    "methodName": "PlayerStoppedLooting",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanLootEntity",
    "fullName": "CanLootEntity [ContainerIOEntity]",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (needsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif ((onlyOneUser && IsOpen()) || IsTransferring())\r\n\t{\r\n\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, StorageContainer.LockedMessage, false);\r\n\t\treturn false;\r\n\t}\r\n\tif (panelToOpen == \"\")\r\n\t{\r\n\t\tpanelToOpen = lootPanelName;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Open, b: true);\r\n\t\tplayer.inventory.loot.AddContainer(_inventory);\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"RPC_OpenLootPanel\", player), lootPanelName);\r\n\t\tSendNetworkUpdate();\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "ContainerIOEntity",
    "methodName": "PlayerOpenLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanSwapToSeat",
    "fullName": "CanSwapToSeat [ModularCarSeat]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "modularCarSeat",
        "type": "ModularCarSeat, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool CanSwapToThis(BasePlayer player)\r\n{\r\n\tif (associatedSeatingModule.DoorsAreLockable)\r\n\t{\r\n\t\tModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;\r\n\t\tif (modularCar != null)\r\n\t\t{\r\n\t\t\treturn modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "ModularCarSeat",
    "methodName": "CanSwapToThis",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanUseGesture",
    "fullName": "CanUseGesture",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "gestureConfig",
        "type": "GestureConfig, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool IsOwnedBy(BasePlayer player, bool allowCinematic = false)\r\n{\r\n\tif (forceUnlock)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (gestureType == GestureConfig.GestureType.NPC)\r\n\t{\r\n\t\tif (player != null)\r\n\t\t{\r\n\t\t\treturn player.IsNpc;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tif (gestureType == GestureConfig.GestureType.Cinematic)\r\n\t{\r\n\t\tif (!allowCinematic && (!(player != null) || !player.IsAdmin))\r\n\t\t{\r\n\t\t\treturn ConVar.Server.cinematic;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tif (dlcItem != null && player != null)\r\n\t{\r\n\t\treturn dlcItem.CanUse(player);\r\n\t}\r\n\tif (inventoryItem != null && player != null && player.blueprints.steamInventory.HasItem(inventoryItem.id))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "GestureConfig",
    "methodName": "IsOwnedBy",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnClientCommand",
    "fullName": "OnClientCommand",
    "category": "Player",
    "parameters": [
      {
        "name": "connection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void OnClientCommand(Network.Message packet)\r\n{\r\n\tif (packet.read.Unread > ConVar.Server.maxpacketsize_command)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Dropping client command due to size\");\r\n\t\treturn;\r\n\t}\r\n\ttimer.Restart();\r\n\tstring text = packet.read.StringRaw();\r\n\tif (packet.connection == null || !packet.connection.connected)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Client without connection tried to run command: \" + text);\r\n\t\treturn;\r\n\t}\r\n\tstring text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text);\r\n\tif (!string.IsNullOrEmpty(text2))\r\n\t{\r\n\t\tSendClientReply(packet.connection, text2);\r\n\t}\r\n\tif (timer.Elapsed > Facepunch.Rust.Profiling.RuntimeProfiler.ConsoleCommandWarningThreshold)\r\n\t{\r\n\t\tFacepunch.Rust.Profiling.LagSpikeProfiler.ConsoleCommand(timer.Elapsed, packet, text);\r\n\t}\r\n}\r\n",
    "targetName": "ConsoleNetwork",
    "methodName": "OnClientCommand",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanSetRelationship",
    "fullName": "CanSetRelationship",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "otherPlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "type",
        "type": "RelationshipManager+RelationshipType, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "weight",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipManager.RelationshipType type, int weight = 1, bool sendImmediate = false)\r\n{\r\n\tif (!contacts)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tulong num = player.userID.Get();\r\n\tulong num2 = otherPlayer.userID.Get();\r\n\tif (player == null || player == otherPlayer || player.IsNpc || (otherPlayer != null && otherPlayer.IsNpc))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tRelationshipManager.PlayerRelationships playerRelationships = GetRelationships(num);\r\n\tif (!CleanupOldContacts(playerRelationships, num))\r\n\t{\r\n\t\tCleanupOldContacts(playerRelationships, num, RelationshipManager.RelationshipType.Enemy);\r\n\t}\r\n\tRelationshipManager.PlayerRelationshipInfo relations = playerRelationships.GetRelations(num2);\r\n\tbool flag = false;\r\n\tif (relations.type != type)\r\n\t{\r\n\t\tflag = true;\r\n\t\trelations.weight = 0;\r\n\t}\r\n\trelations.type = type;\r\n\trelations.weight += weight;\r\n\tfloat num3 = UnityEngine.Time.realtimeSinceStartup - relations.lastMugshotTime;\r\n\tif (flag || relations.mugshotCrc == 0 || num3 >= mugshotUpdateInterval)\r\n\t{\r\n\t\tbool flag2 = otherPlayer.IsAlive();\r\n\t\tbool num4 = player.SecondsSinceAttacked > 10f && !player.IsAiming;\r\n\t\tfloat num5 = 100f;\r\n\t\tif (num4)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 normalized = (otherPlayer.eyes.position - player.eyes.position).normalized;\r\n\t\t\tbool flag3 = UnityEngine.Vector3.Dot(player.eyes.HeadForward(), normalized) >= 0.6f;\r\n\t\t\tfloat num6 = UnityEngine.Vector3Ex.Distance2D(player.transform.position, otherPlayer.transform.position);\r\n\t\t\tif (flag2 && num6 < num5 && flag3)\r\n\t\t\t{\r\n\t\t\t\tClientRPC(RpcTarget.Player(\"CLIENT_DoMugshot\", player), num2);\r\n\t\t\t\trelations.lastMugshotTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (sendImmediate)\r\n\t{\r\n\t\tSendRelationshipsFor(player);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tMarkRelationshipsDirtyFor(player);\r\n\t}\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "SetRelationship",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerDrink",
    "fullName": "OnPlayerDrink",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "liquidContainer",
        "type": "LiquidContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void SVDrink(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!rpc.player.metabolism.CanConsume())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (Item item in base.inventory.itemList)\r\n\t{\r\n\t\tItemModConsume component = item.info.GetComponent<ItemModConsume>();\r\n\t\tif (!(component == null) && component.CanDoAction(item, rpc.player))\r\n\t\t{\r\n\t\t\tcomponent.DoAction(item, rpc.player);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "LiquidContainer",
    "methodName": "SVDrink",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLootEntityEnd",
    "fullName": "OnLootEntityEnd [FuseBox]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "itemBasedFlowRestrictor",
        "type": "ItemBasedFlowRestrictor, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void PlayerStoppedLooting(BasePlayer player)\r\n{\r\n}\r\n",
    "targetName": "ItemBasedFlowRestrictor",
    "methodName": "PlayerStoppedLooting",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanUpdateSign",
    "fullName": "CanUpdateSign [CarvablePumpkin]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "carvablePumpkin",
        "type": "CarvablePumpkin, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CanUpdateSign(BasePlayer player)\r\n{\r\n\tif (player.IsAdmin || player.IsDeveloper)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (!player.CanBuild())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (IsLocked())\r\n\t{\r\n\t\treturn (ulong)player.userID == base.OwnerID;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "CarvablePumpkin",
    "methodName": "CanUpdateSign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEyePosValidate",
    "fullName": "OnEyePosValidate",
    "category": "Player",
    "parameters": [
      {
        "name": "attackEntity",
        "type": "AttackEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "eyePos",
        "type": "UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "checkLineOfSight",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool ValidateEyePos(BasePlayer player, UnityEngine.Vector3 eyePos, bool checkLineOfSight = true)\r\n{\r\n\tbool flag = true;\r\n\tif (UnityEngine.Vector3Ex.IsNaNOrInfinity(eyePos))\r\n\t{\r\n\t\tstring shortPrefabName = base.ShortPrefabName;\r\n\t\tAntiHack.Log(player, AntiHackType.EyeHack, \"Contains NaN (\" + shortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"eye_nan\");\r\n\t\tflag = false;\r\n\t}\r\n\tif (ConVar.AntiHack.eye_protection > 0)\r\n\t{\r\n\t\tif (ConVar.AntiHack.eye_protection >= 1)\r\n\t\t{\r\n\t\t\tfloat num = player.GetParentVelocity().magnitude + player.GetMountVelocity().magnitude;\r\n\t\t\tfloat num2 = ((((player.HasParent() || player.isMounted) ? ConVar.AntiHack.eye_distance_parented_mounted_forgiveness : 0f) + player.estimatedSpeed > 0f) ? ConVar.AntiHack.eye_forgiveness : 0f);\r\n\t\t\tfloat num3 = num + num2;\r\n\t\t\tfloat num4 = player.tickHistory.Distance(player, eyePos);\r\n\t\t\tif (num4 > num3)\r\n\t\t\t{\r\n\t\t\t\tstring shortPrefabName2 = base.ShortPrefabName;\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, \"Distance (\" + shortPrefabName2 + \" on attack with \" + num4 + \"m > \" + num3 + \"m)\");\r\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \"eye_distance\");\r\n\t\t\t\tflag = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ConVar.AntiHack.eye_protection >= 3)\r\n\t\t{\r\n\t\t\tfloat num5 = UnityEngine.Mathf.Abs(player.GetMountVelocity().y + player.GetParentVelocity().y) + player.GetJumpHeight();\r\n\t\t\tfloat num6 = UnityEngine.Mathf.Abs(player.eyes.position.y - eyePos.y);\r\n\t\t\tif (num6 > num5)\r\n\t\t\t{\r\n\t\t\t\tstring shortPrefabName3 = base.ShortPrefabName;\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, \"Altitude (\" + shortPrefabName3 + \" on attack with \" + num6 + \"m > \" + num5 + \"m)\");\r\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \"eye_altitude\");\r\n\t\t\t\tflag = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (checkLineOfSight)\r\n\t\t{\r\n\t\t\tint num7 = 2162688;\r\n\t\t\tif (ConVar.AntiHack.eye_terraincheck)\r\n\t\t\t{\r\n\t\t\t\tnum7 |= 0x800000;\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.eye_vehiclecheck)\r\n\t\t\t{\r\n\t\t\t\tnum7 |= 0x8000000;\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.eye_protection >= 2)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Vector3 center = player.eyes.center;\r\n\t\t\t\tUnityEngine.Vector3 position = player.eyes.position;\r\n\t\t\t\tUnityEngine.Vector3 vector = eyePos;\r\n\t\t\t\tif (!GamePhysics.LineOfSightRadius(center, position, num7, ConVar.AntiHack.eye_losradius) || !GamePhysics.LineOfSightRadius(position, vector, num7, ConVar.AntiHack.eye_losradius))\r\n\t\t\t\t{\r\n\t\t\t\t\tstring shortPrefabName4 = base.ShortPrefabName;\r\n\t\t\t\t\tstring[] obj = new string[8] { \"Line of sight (\", shortPrefabName4, \" on attack) \", null, null, null, null, null };\r\n\t\t\t\t\tUnityEngine.Vector3 vector2 = center;\r\n\t\t\t\t\tobj[3] = vector2.ToString();\r\n\t\t\t\t\tobj[4] = \" \";\r\n\t\t\t\t\tvector2 = position;\r\n\t\t\t\t\tobj[5] = vector2.ToString();\r\n\t\t\t\t\tobj[6] = \" \";\r\n\t\t\t\t\tvector2 = vector;\r\n\t\t\t\t\tobj[7] = vector2.ToString();\r\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj));\r\n\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \"eye_los\");\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.eye_protection >= 4 && !player.HasParent())\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Vector3 position2 = player.eyes.position;\r\n\t\t\t\tUnityEngine.Vector3 vector3 = eyePos;\r\n\t\t\t\tfloat num8 = UnityEngine.Vector3.Distance(position2, vector3);\r\n\t\t\t\tUnityEngine.Collider col;\r\n\t\t\t\tif (num8 > ConVar.AntiHack.eye_noclip_cutoff)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (AntiHack.TestNoClipping(player, position2, vector3, player.NoClipRadius(ConVar.AntiHack.eye_noclip_margin), ConVar.AntiHack.eye_noclip_backtracking, out col))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring shortPrefabName5 = base.ShortPrefabName;\r\n\t\t\t\t\t\tstring[] obj2 = new string[6] { \"NoClip (\", shortPrefabName5, \" on attack) \", null, null, null };\r\n\t\t\t\t\t\tUnityEngine.Vector3 vector2 = position2;\r\n\t\t\t\t\t\tobj2[3] = vector2.ToString();\r\n\t\t\t\t\t\tobj2[4] = \" \";\r\n\t\t\t\t\t\tvector2 = vector3;\r\n\t\t\t\t\t\tobj2[5] = vector2.ToString();\r\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj2));\r\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \"eye_noclip\");\r\n\t\t\t\t\t\tflag = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (num8 > 0.01f && AntiHack.TestNoClipping(player, position2, vector3, 0.1f, ConVar.AntiHack.eye_noclip_backtracking, out col))\r\n\t\t\t\t{\r\n\t\t\t\t\tstring shortPrefabName6 = base.ShortPrefabName;\r\n\t\t\t\t\tstring[] obj3 = new string[6] { \"NoClip (\", shortPrefabName6, \" on attack) \", null, null, null };\r\n\t\t\t\t\tUnityEngine.Vector3 vector2 = position2;\r\n\t\t\t\t\tobj3[3] = vector2.ToString();\r\n\t\t\t\t\tobj3[4] = \" \";\r\n\t\t\t\t\tvector2 = vector3;\r\n\t\t\t\t\tobj3[5] = vector2.ToString();\r\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj3));\r\n\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \"eye_noclip\");\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tAntiHack.AddViolation(player, AntiHackType.EyeHack, ConVar.AntiHack.eye_penalty);\r\n\t\t}\r\n\t\telse if (ConVar.AntiHack.eye_protection >= 5 && !player.HasParent() && !player.isMounted)\r\n\t\t{\r\n\t\t\tplayer.eyeHistory.PushBack(eyePos);\r\n\t\t}\r\n\t}\r\n\treturn flag;\r\n}\r\n",
    "targetName": "AttackEntity",
    "methodName": "ValidateEyePos",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnClientProjectileEffectCreate",
    "fullName": "OnClientProjectileEffectCreate",
    "category": "Player",
    "parameters": [
      {
        "name": "sourceConnection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseProjectile",
        "type": "BaseProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "prefabName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CreateProjectileEffectClientside(string prefabName, UnityEngine.Vector3 pos, UnityEngine.Vector3 velocity, int seed, Network.Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false, System.Collections.Generic.List<Network.Connection> targets = null, float distanceOverride = 0f)\r\n{\r\n\tEffect effect = reusableInstance;\r\n\teffect.Init(Effect.Type.Projectile, pos, velocity, sourceConnection);\r\n\teffect.scale = (silenced ? 0f : 1f);\r\n\tif (forceClientsideEffects)\r\n\t{\r\n\t\teffect.scale = 2f;\r\n\t}\r\n\teffect.pooledString = prefabName;\r\n\teffect.number = seed;\r\n\teffect.targets = targets;\r\n\teffect.distanceOverride = distanceOverride;\r\n\tEffectNetwork.Send(effect);\r\n}\r\n",
    "targetName": "BaseProjectile",
    "methodName": "CreateProjectileEffectClientside",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerBanned",
    "fullName": "OnPlayerBanned [EAC]",
    "category": "Player",
    "parameters": [
      {
        "name": "local2",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "toString()",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void OnClientActionRequired(ref Epic.OnlineServices.AntiCheatCommon.OnClientActionRequiredCallbackInfo data)\r\n{\r\n\tusing (TimeWarning.New(\"OnClientActionRequired\", 10))\r\n\t{\r\n\t\tSystem.IntPtr clientHandle = data.ClientHandle;\r\n\t\tNetwork.Connection connection = GetConnection(clientHandle);\r\n\t\tif (connection == null)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(\"[EAC] Status update for invalid client: \" + clientHandle);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (data.ClientAction != Epic.OnlineServices.AntiCheatCommon.AntiCheatCommonClientAction.RemovePlayer)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tEpic.OnlineServices.Utf8String actionReasonDetailsString = data.ActionReasonDetailsString;\r\n\t\t\tif (connection.IsDevelopmentBuild())\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"[EAC] Remove player action skipped for unprotected client: \" + connection.ToString());\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tUnityEngine.Debug.Log($\"[EAC] Kicking {connection.userid} / {connection.username} ({actionReasonDetailsString})\");\r\n\t\t\tconnection.authStatusEAC = \"eac\";\r\n\t\t\tNetwork.Net.sv.Kick(connection, \"EAC: \" + actionReasonDetailsString);\r\n\t\t\tif (data.ActionReasonCode == Epic.OnlineServices.AntiCheatCommon.AntiCheatCommonClientActionReason.PermanentBanned || data.ActionReasonCode == Epic.OnlineServices.AntiCheatCommon.AntiCheatCommonClientActionReason.TemporaryBanned)\r\n\t\t\t{\r\n\t\t\t\tconnection.authStatusEAC = \"eacbanned\";\r\n\t\t\t\tConsoleNetwork.BroadcastToAllClients(\"chat.add\", 2, 0, \"<color=#fff>SERVER</color> Kicking \" + connection.username + \" (banned by anticheat)\");\r\n\t\t\t\tif (data.ActionReasonCode == Epic.OnlineServices.AntiCheatCommon.AntiCheatCommonClientActionReason.PermanentBanned)\r\n\t\t\t\t{\r\n\t\t\t\t\tConVar.Entity.DeleteBy(connection.userid);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tEpic.OnlineServices.AntiCheatServer.UnregisterClientOptions unregisterClientOptions = default(Epic.OnlineServices.AntiCheatServer.UnregisterClientOptions);\r\n\t\t\tunregisterClientOptions.ClientHandle = clientHandle;\r\n\t\t\tEpic.OnlineServices.AntiCheatServer.UnregisterClientOptions options = unregisterClientOptions;\r\n\t\t\tInterface.UnregisterClient(ref options);\r\n\t\t\tclient2connection.TryRemove((uint)(int)clientHandle, out var _);\r\n\t\t\tconnection2client.TryRemove(connection, out var _);\r\n\t\t\tconnection2status.TryRemove(connection, out var _);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "EACServer",
    "methodName": "OnClientActionRequired",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerKicked",
    "fullName": "OnPlayerKicked [EAC]",
    "category": "Player",
    "parameters": [
      {
        "name": "local2",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "toString()",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void OnClientActionRequired(ref Epic.OnlineServices.AntiCheatCommon.OnClientActionRequiredCallbackInfo data)\r\n{\r\n\tusing (TimeWarning.New(\"OnClientActionRequired\", 10))\r\n\t{\r\n\t\tSystem.IntPtr clientHandle = data.ClientHandle;\r\n\t\tNetwork.Connection connection = GetConnection(clientHandle);\r\n\t\tif (connection == null)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(\"[EAC] Status update for invalid client: \" + clientHandle);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (data.ClientAction != Epic.OnlineServices.AntiCheatCommon.AntiCheatCommonClientAction.RemovePlayer)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tEpic.OnlineServices.Utf8String actionReasonDetailsString = data.ActionReasonDetailsString;\r\n\t\t\tif (connection.IsDevelopmentBuild())\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"[EAC] Remove player action skipped for unprotected client: \" + connection.ToString());\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tUnityEngine.Debug.Log($\"[EAC] Kicking {connection.userid} / {connection.username} ({actionReasonDetailsString})\");\r\n\t\t\tconnection.authStatusEAC = \"eac\";\r\n\t\t\tNetwork.Net.sv.Kick(connection, \"EAC: \" + actionReasonDetailsString);\r\n\t\t\tif (data.ActionReasonCode == Epic.OnlineServices.AntiCheatCommon.AntiCheatCommonClientActionReason.PermanentBanned || data.ActionReasonCode == Epic.OnlineServices.AntiCheatCommon.AntiCheatCommonClientActionReason.TemporaryBanned)\r\n\t\t\t{\r\n\t\t\t\tconnection.authStatusEAC = \"eacbanned\";\r\n\t\t\t\tConsoleNetwork.BroadcastToAllClients(\"chat.add\", 2, 0, \"<color=#fff>SERVER</color> Kicking \" + connection.username + \" (banned by anticheat)\");\r\n\t\t\t\tif (data.ActionReasonCode == Epic.OnlineServices.AntiCheatCommon.AntiCheatCommonClientActionReason.PermanentBanned)\r\n\t\t\t\t{\r\n\t\t\t\t\tConVar.Entity.DeleteBy(connection.userid);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tEpic.OnlineServices.AntiCheatServer.UnregisterClientOptions unregisterClientOptions = default(Epic.OnlineServices.AntiCheatServer.UnregisterClientOptions);\r\n\t\t\tunregisterClientOptions.ClientHandle = clientHandle;\r\n\t\t\tEpic.OnlineServices.AntiCheatServer.UnregisterClientOptions options = unregisterClientOptions;\r\n\t\t\tInterface.UnregisterClient(ref options);\r\n\t\t\tclient2connection.TryRemove((uint)(int)clientHandle, out var _);\r\n\t\t\tconnection2client.TryRemove(connection, out var _);\r\n\t\t\tconnection2status.TryRemove(connection, out var _);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "EACServer",
    "methodName": "OnClientActionRequired",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPortalUse",
    "fullName": "OnPortalUse",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "basePortal",
        "type": "BasePortal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void UsePortal(BasePlayer player)\r\n{\r\n\tLinkPortal();\r\n\tif (targetPortal != null)\r\n\t{\r\n\t\tplayer.PauseFlyHackDetection();\r\n\t\tplayer.PauseSpeedHackDetection();\r\n\t\tplayer.ApplyStallProtection(4f);\r\n\t\tUnityEngine.Vector3 position = player.transform.position;\r\n\t\tUnityEngine.Vector3 vector = targetPortal.GetLocalEntryExitPosition();\r\n\t\tUnityEngine.Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());\r\n\t\tUnityEngine.Vector3 vector3 = vector2;\r\n\t\tif (isMirrored)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);\r\n\t\t\tvector = targetPortal.relativeAnchor.transform.TransformPoint(position2);\r\n\t\t\tvector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvector3 = targetPortal.GetLocalEntryExitRotation() * UnityEngine.Vector3.forward;\r\n\t\t}\r\n\t\tif (disappearEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(disappearEffect.resourcePath, position, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\tif (appearEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(appearEffect.resourcePath, vector, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"StartLoading_Quick\", player), arg1: true);\r\n\t\tplayer.SetParent(null, worldPositionStays: true);\r\n\t\tplayer.Teleport(vector);\r\n\t\tplayer.ForceUpdateTriggers();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"ForceViewAnglesTo\", player), vector3);\r\n\t\tif (transitionSoundEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\tplayer.UpdateNetworkGroup();\r\n\t\tplayer.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"No portal...\");\r\n\t}\r\n}\r\n",
    "targetName": "BasePortal",
    "methodName": "UsePortal",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPortalUsed",
    "fullName": "OnPortalUsed",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "basePortal",
        "type": "BasePortal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void UsePortal(BasePlayer player)\r\n{\r\n\tLinkPortal();\r\n\tif (targetPortal != null)\r\n\t{\r\n\t\tplayer.PauseFlyHackDetection();\r\n\t\tplayer.PauseSpeedHackDetection();\r\n\t\tplayer.ApplyStallProtection(4f);\r\n\t\tUnityEngine.Vector3 position = player.transform.position;\r\n\t\tUnityEngine.Vector3 vector = targetPortal.GetLocalEntryExitPosition();\r\n\t\tUnityEngine.Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());\r\n\t\tUnityEngine.Vector3 vector3 = vector2;\r\n\t\tif (isMirrored)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);\r\n\t\t\tvector = targetPortal.relativeAnchor.transform.TransformPoint(position2);\r\n\t\t\tvector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvector3 = targetPortal.GetLocalEntryExitRotation() * UnityEngine.Vector3.forward;\r\n\t\t}\r\n\t\tif (disappearEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(disappearEffect.resourcePath, position, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\tif (appearEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(appearEffect.resourcePath, vector, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"StartLoading_Quick\", player), arg1: true);\r\n\t\tplayer.SetParent(null, worldPositionStays: true);\r\n\t\tplayer.Teleport(vector);\r\n\t\tplayer.ForceUpdateTriggers();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"ForceViewAnglesTo\", player), vector3);\r\n\t\tif (transitionSoundEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\tplayer.UpdateNetworkGroup();\r\n\t\tplayer.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"No portal...\");\r\n\t}\r\n}\r\n",
    "targetName": "BasePortal",
    "methodName": "UsePortal",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanUnlock",
    "fullName": "CanUnlock [ModularCarCodeLock]",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "modularCarCodeLock",
        "type": "ModularCarCodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "codeEntered",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool TryOpenWithCode(BasePlayer player, string codeEntered)\r\n{\r\n\tif (CodeEntryBlocked(player))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!(codeEntered == Code))\r\n\t{\r\n\t\tif (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 60f)\r\n\t\t{\r\n\t\t\twrongCodes = 0;\r\n\t\t}\r\n\t\tplayer.Hurt((float)(wrongCodes + 1) * 5f, Rust.DamageType.ElectricShock, owner, useProtection: false);\r\n\t\twrongCodes++;\r\n\t\tif (wrongCodes > 5)\r\n\t\t{\r\n\t\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning, false);\r\n\t\t}\r\n\t\tif ((float)wrongCodes >= CodeLock.maxFailedAttempts)\r\n\t\t{\r\n\t\t\towner.SetFlag(BaseEntity.Flags.Reserved10, b: true);\r\n\t\t\towner.Invoke(ClearCodeEntryBlocked, CodeLock.lockoutCooldown);\r\n\t\t}\r\n\t\tlastWrongTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\treturn false;\r\n\t}\r\n\tif (TryAddPlayer(player.userID))\r\n\t{\r\n\t\twrongCodes = 0;\r\n\t}\r\n\towner.SendNetworkUpdate();\r\n\treturn true;\r\n}\r\n",
    "targetName": "ModularCarCodeLock",
    "methodName": "TryOpenWithCode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPlayerDig",
    "fullName": "OnPlayerDig",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseDiggableEntity",
        "type": "BaseDiggableEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void Dig(BasePlayer player)\r\n{\r\n\tif (digsRemaining == RequiredDigCount)\r\n\t{\r\n\t\tOnFirstDig(player);\r\n\t}\r\n\tClientRPC(RpcTarget.NetworkGroup(\"RPC_OnDig\"), RequiredDigCount - digsRemaining, RequiredDigCount);\r\n\tdigsRemaining--;\r\n\tbase.health = digsRemaining;\r\n\tSendNetworkUpdate();\r\n\tOnSingleDig(player);\r\n\tif (digsRemaining <= 0)\r\n\t{\r\n\t\tOnFullyDug(player);\r\n\t\tif (DestroyOnDug)\r\n\t\t{\r\n\t\t\tKill();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseDiggableEntity",
    "methodName": "Dig",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMetalDetectorFlagRequest",
    "fullName": "OnMetalDetectorFlagRequest",
    "category": "Player",
    "parameters": [
      {
        "name": "baseMetalDetector",
        "type": "BaseMetalDetector, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(2uL)]\r\npublic void RPC_RequestFlag(BaseEntity.RPCMessage rpc)\r\n{\r\n\tBasePlayer player = rpc.player;\r\n\tif (!(player == null) && !player.InSafeZone() && nearestSource != null)\r\n\t{\r\n\t\tUnityEngine.Vector3 pos = rpc.read.Vector3();\r\n\t\tif (nearestSource.VerifyScanPosition(player.transform.position, pos, out var spotPos))\r\n\t\t{\r\n\t\t\tnearestSource.Detected(spotPos);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseMetalDetector",
    "methodName": "RPC_RequestFlag",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanUseHBHFSensor",
    "fullName": "CanUseHBHFSensor",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "hBHFSensor",
        "type": "HBHFSensor, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanUse(BasePlayer player)\r\n{\r\n\treturn player.CanBuild();\r\n}\r\n",
    "targetName": "HBHFSensor",
    "methodName": "CanUse",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPlayerHandcuff",
    "fullName": "OnPlayerHandcuff",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer)\r\n{\r\n\tif (victim == null || handcuffer == null || victim.IsRestrained || (!victim.CurrentGestureIsSurrendering && !victim.IsWounded()) || UnityEngine.Vector3.Distance(victim.transform.position, handcuffer.transform.position) > UseDistance)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem ownerItem = GetOwnerItem();\r\n\tif (ownerItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tvictim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: true);\r\n\tvictim.SendNetworkUpdateImmediate();\r\n\townerItem.SetFlag(Item.Flag.IsOn, b: true);\r\n\tbool flag = true;\r\n\tif (!ownerItem.MoveToContainer(victim.inventory.containerBelt))\r\n\t{\r\n\t\tItem slot = victim.inventory.containerBelt.GetSlot(0);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tif (!slot.MoveToContainer(victim.inventory.containerMain))\r\n\t\t\t{\r\n\t\t\t\tslot.DropAndTossUpwards(victim.transform.position);\r\n\t\t\t}\r\n\t\t\tif (!ownerItem.MoveToContainer(victim.inventory.containerBelt))\r\n\t\t\t{\r\n\t\t\t\tflag = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (!flag)\r\n\t{\r\n\t\townerItem.SetFlag(Item.Flag.IsOn, b: false);\r\n\t\tvictim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: false);\r\n\t}\r\n\townerItem.MarkDirty();\r\n\tif (flag)\r\n\t{\r\n\t\tvictim.Server_CancelGesture();\r\n\t\tif (victim.IsBot)\r\n\t\t{\r\n\t\t\tConVar.Inventory.EquipItemInSlot(victim, 0);\r\n\t\t}\r\n\t\tvictim.ClientRPC(RpcTarget.Player(\"SetActiveBeltSlot\", victim), ownerItem.position, ownerItem.uid);\r\n\t\tSetLocked(flag: true, victim, ownerItem);\r\n\t\tEffect.server.Run(lockEffect.resourcePath, victim, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t}\r\n}\r\n",
    "targetName": "Handcuffs",
    "methodName": "SV_HandcuffVictim",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerHandcuffed",
    "fullName": "OnPlayerHandcuffed",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer)\r\n{\r\n\tif (victim == null || handcuffer == null || victim.IsRestrained || (!victim.CurrentGestureIsSurrendering && !victim.IsWounded()) || UnityEngine.Vector3.Distance(victim.transform.position, handcuffer.transform.position) > UseDistance)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem ownerItem = GetOwnerItem();\r\n\tif (ownerItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tvictim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: true);\r\n\tvictim.SendNetworkUpdateImmediate();\r\n\townerItem.SetFlag(Item.Flag.IsOn, b: true);\r\n\tbool flag = true;\r\n\tif (!ownerItem.MoveToContainer(victim.inventory.containerBelt))\r\n\t{\r\n\t\tItem slot = victim.inventory.containerBelt.GetSlot(0);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tif (!slot.MoveToContainer(victim.inventory.containerMain))\r\n\t\t\t{\r\n\t\t\t\tslot.DropAndTossUpwards(victim.transform.position);\r\n\t\t\t}\r\n\t\t\tif (!ownerItem.MoveToContainer(victim.inventory.containerBelt))\r\n\t\t\t{\r\n\t\t\t\tflag = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (!flag)\r\n\t{\r\n\t\townerItem.SetFlag(Item.Flag.IsOn, b: false);\r\n\t\tvictim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: false);\r\n\t}\r\n\townerItem.MarkDirty();\r\n\tif (flag)\r\n\t{\r\n\t\tvictim.Server_CancelGesture();\r\n\t\tif (victim.IsBot)\r\n\t\t{\r\n\t\t\tConVar.Inventory.EquipItemInSlot(victim, 0);\r\n\t\t}\r\n\t\tvictim.ClientRPC(RpcTarget.Player(\"SetActiveBeltSlot\", victim), ownerItem.position, ownerItem.uid);\r\n\t\tSetLocked(flag: true, victim, ownerItem);\r\n\t\tEffect.server.Run(lockEffect.resourcePath, victim, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t}\r\n}\r\n",
    "targetName": "Handcuffs",
    "methodName": "SV_HandcuffVictim",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerVanish",
    "fullName": "OnPlayerVanish",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerVar(Help = \"Make admin invisibile\")]\r\npublic static void invis(ConsoleSystem.Arg arg)\r\n{\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (basePlayer == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool @bool = arg.GetBool(0, !invisiblePlayers.Contains(basePlayer));\r\n\tif (@bool && !invisiblePlayers.Contains(basePlayer))\r\n\t{\r\n\t\tinvisiblePlayers.Add(basePlayer);\r\n\t\tbasePlayer.limitNetworking = true;\r\n\t\tbasePlayer.syncPosition = false;\r\n\t\tbasePlayer.GetHeldEntity()?.SetHeld(bHeld: false);\r\n\t\tbasePlayer.DisablePlayerCollider();\r\n\t\tRust.Ai.SimpleAIMemory.AddIgnorePlayer(basePlayer);\r\n\t\tBaseEntity.Query.Server.RemovePlayer(basePlayer);\r\n\t\tif (!Rust.Global.Runner.IsInvoking(TickInvis))\r\n\t\t{\r\n\t\t\tRust.Global.Runner.InvokeRepeating(TickInvis, 0f, 0f);\r\n\t\t}\r\n\t}\r\n\telse if (!@bool && invisiblePlayers.Contains(basePlayer))\r\n\t{\r\n\t\tinvisiblePlayers.Remove(basePlayer);\r\n\t\tbasePlayer.limitNetworking = false;\r\n\t\tbasePlayer.syncPosition = true;\r\n\t\tbasePlayer.EnablePlayerCollider();\r\n\t\tRust.Ai.SimpleAIMemory.RemoveIgnorePlayer(basePlayer);\r\n\t\tBaseEntity.Query.Server.RemovePlayer(basePlayer);\r\n\t\tBaseEntity.Query.Server.AddPlayer(basePlayer);\r\n\t\tif (invisiblePlayers.Count == 0)\r\n\t\t{\r\n\t\t\tRust.Global.Runner.CancelInvoke(TickInvis);\r\n\t\t}\r\n\t}\r\n\targ.ReplyWith(\"Invis: \" + basePlayer.limitNetworking);\r\n}\r\n",
    "targetName": "ConVar.Debugging",
    "methodName": "invis",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerUnvanish",
    "fullName": "OnPlayerUnvanish",
    "category": "Player",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerVar(Help = \"Make admin invisibile\")]\r\npublic static void invis(ConsoleSystem.Arg arg)\r\n{\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (basePlayer == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool @bool = arg.GetBool(0, !invisiblePlayers.Contains(basePlayer));\r\n\tif (@bool && !invisiblePlayers.Contains(basePlayer))\r\n\t{\r\n\t\tinvisiblePlayers.Add(basePlayer);\r\n\t\tbasePlayer.limitNetworking = true;\r\n\t\tbasePlayer.syncPosition = false;\r\n\t\tbasePlayer.GetHeldEntity()?.SetHeld(bHeld: false);\r\n\t\tbasePlayer.DisablePlayerCollider();\r\n\t\tRust.Ai.SimpleAIMemory.AddIgnorePlayer(basePlayer);\r\n\t\tBaseEntity.Query.Server.RemovePlayer(basePlayer);\r\n\t\tif (!Rust.Global.Runner.IsInvoking(TickInvis))\r\n\t\t{\r\n\t\t\tRust.Global.Runner.InvokeRepeating(TickInvis, 0f, 0f);\r\n\t\t}\r\n\t}\r\n\telse if (!@bool && invisiblePlayers.Contains(basePlayer))\r\n\t{\r\n\t\tinvisiblePlayers.Remove(basePlayer);\r\n\t\tbasePlayer.limitNetworking = false;\r\n\t\tbasePlayer.syncPosition = true;\r\n\t\tbasePlayer.EnablePlayerCollider();\r\n\t\tRust.Ai.SimpleAIMemory.RemoveIgnorePlayer(basePlayer);\r\n\t\tBaseEntity.Query.Server.RemovePlayer(basePlayer);\r\n\t\tBaseEntity.Query.Server.AddPlayer(basePlayer);\r\n\t\tif (invisiblePlayers.Count == 0)\r\n\t\t{\r\n\t\t\tRust.Global.Runner.CancelInvoke(TickInvis);\r\n\t\t}\r\n\t}\r\n\targ.ReplyWith(\"Invis: \" + basePlayer.limitNetworking);\r\n}\r\n",
    "targetName": "ConVar.Debugging",
    "methodName": "invis",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSignalBroadcast",
    "fullName": "OnSignalBroadcast [1]",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SignalBroadcast(BaseEntity.Signal signal, string arg, Network.Connection sourceConnection = null)\r\n{\r\n\tif (net != null && net.group != null)\r\n\t{\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"SignalFromServerEx\", this, Network.SendMethod.Unreliable, Network.Priority.Immediate), (int)signal, arg, sourceConnection?.userid ?? 0);\r\n\t}\r\n}\r\n",
    "targetName": "BaseEntity",
    "methodName": "SignalBroadcast",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerAddModifiers",
    "fullName": "OnPlayerAddModifiers",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void DoAction(Item item, BasePlayer player)\r\n{\r\n\tif (item.amount < 1)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tGameObjectRef gameObjectRef = GetConsumeEffect();\r\n\tif (gameObjectRef.isValid)\r\n\t{\r\n\t\tUnityEngine.Vector3 posLocal = (player.IsDucked() ? new UnityEngine.Vector3(0f, 1f, 0f) : new UnityEngine.Vector3(0f, 2f, 0f));\r\n\t\tEffect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, UnityEngine.Vector3.zero);\r\n\t}\r\n\tplayer.metabolism.MarkConsumption();\r\n\tItemModConsumable consumable = GetConsumable();\r\n\tif (!string.IsNullOrEmpty(consumable.achievementWhenEaten))\r\n\t{\r\n\t\tplayer.GiveAchievement(consumable.achievementWhenEaten);\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnConsumableUsed(player, item);\r\n\tfloat num = UnityEngine.Mathf.Max(consumable.amountToConsume, 1);\r\n\tfloat num2 = UnityEngine.Mathf.Min(item.amount, num);\r\n\tfloat num3 = num2 / num;\r\n\tfloat num4 = item.conditionNormalized;\r\n\tif (consumable.conditionFractionToLose > 0f)\r\n\t{\r\n\t\tnum4 = consumable.conditionFractionToLose;\r\n\t}\r\n\tforeach (ItemModConsumable.ConsumableEffect effect in consumable.effects)\r\n\t{\r\n\t\tif (UnityEngine.Mathf.Clamp01(player.healthFraction + player.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (effect.type == MetabolismAttribute.Type.Health)\r\n\t\t{\r\n\t\t\tif (effect.amount < 0f)\r\n\t\t\t{\r\n\t\t\t\tplayer.OnAttacked(new HitInfo(player, player, Rust.DamageType.Generic, (0f - effect.amount) * num3 * num4, player.transform.position + player.transform.forward * 1f));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tplayer.health += effect.amount * num3 * num4;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);\r\n\t\t}\r\n\t}\r\n\tplayer.ProcessMissionEvent(BaseMission.MissionEventType.CONSUME, item.info.itemid, 1f);\r\n\tif (player.modifiers != null)\r\n\t{\r\n\t\tplayer.modifiers.Add(consumable.modifiers);\r\n\t}\r\n\tif (product != null)\r\n\t{\r\n\t\tItemAmountRandom[] array = product;\r\n\t\tforeach (ItemAmountRandom itemAmountRandom in array)\r\n\t\t{\r\n\t\t\tint num5 = UnityEngine.Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);\r\n\t\t\tif (num5 > 0)\r\n\t\t\t{\r\n\t\t\t\tItem item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);\r\n\t\t\t\tplayer.GiveItem(item2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (string.IsNullOrEmpty(eatGesture))\r\n\t{\r\n\t\tplayer.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);\r\n\t}\r\n\tFacepunch.Rust.Analytics.Server.Consume(base.gameObject.name);\r\n\tif (consumable.conditionFractionToLose > 0f)\r\n\t{\r\n\t\titem.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);\r\n\t}\r\n\telse\r\n\t{\r\n\t\titem.UseItem((int)num2);\r\n\t}\r\n}\r\n",
    "targetName": "ItemModConsume",
    "methodName": "DoAction",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanLootEntity",
    "fullName": "CanLootEntity [IndustrialCrafter]",
    "category": "Player",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (NeedsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (OnlyOneUser && IsOpen())\r\n\t{\r\n\t\tplayer.ChatMessage(\"Already in use\");\r\n\t\treturn false;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Open, b: true);\r\n\t\tplayer.inventory.loot.AddContainer(_inventory);\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tplayer.ClientRPC(RpcTarget.Player(\"RPC_OpenLootPanel\", player), LootPanelName);\r\n\t\tSendNetworkUpdate();\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "IndustrialCrafter",
    "methodName": "PlayerOpenLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnClientDisconnected",
    "fullName": "OnClientDisconnected",
    "category": "Player",
    "parameters": [
      {
        "name": "cn",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "strReason",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnDisconnected(string strReason, Network.Connection cn)\r\n{\r\n\tif (cn != null)\r\n\t{\r\n\t\tRecordDisconnection(cn);\r\n\t\tcn.connected = false;\r\n\t\tcn.active = false;\r\n\t\tif (callbackHandler != null)\r\n\t\t{\r\n\t\t\tcallbackHandler.OnDisconnected(strReason, cn);\r\n\t\t}\r\n\t\tRemoveConnection(cn);\r\n\t}\r\n}\r\n",
    "targetName": "Network.Server",
    "methodName": "OnDisconnected",
    "assemblyName": "Facepunch.Network",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCatapultFireForce",
    "fullName": "OnCatapultFireForce",
    "category": "Primitive",
    "parameters": [
      {
        "name": "catapult",
        "type": "Catapult, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "shooter",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool Fire(BasePlayer shooter, float force)\r\n{\r\n\tFireRecoil();\r\n\tfloat num = UnityEngine.Mathf.Lerp(2f, 1f, UnityEngine.Mathf.Clamp01(force));\r\n\tfloat num2 = UnityEngine.Mathf.Lerp(0.5f, 1f, UnityEngine.Mathf.Clamp01(force));\r\n\tbool flag = true;\r\n\tUnityEngine.Vector3 firingPos = muzzle.position;\r\n\tBasePlayer passenger = GetPassenger();\r\n\tif (passenger != null)\r\n\t{\r\n\t\tpassenger.ServerPosition = muzzle.transform.position;\r\n\t\tpassenger.Ragdoll(muzzle.transform.forward * (20f * num2) + UnityEngine.Vector3.up * (2.5f * num), matchPlayerGravity: false, flailInAir: true, dieOnImpact: true, this);\r\n\t\treturn true;\r\n\t}\r\n\tif (GamePhysics.CheckSphere(muzzle.position, 1f, 1236994833, UnityEngine.QueryTriggerInteraction.Ignore))\r\n\t{\r\n\t\tUnityEngine.Vector3 vector = base.transform.position + UnityEngine.Vector3.up * 2f;\r\n\t\tif (GamePhysics.Trace(new UnityEngine.Ray(vector, muzzle.position - vector), 0f, out var hitInfo, 10f, 1236994833, UnityEngine.QueryTriggerInteraction.Ignore))\r\n\t\t{\r\n\t\t\tflag = false;\r\n\t\t\tfiringPos = hitInfo.point - UnityEngine.Vector3.up;\r\n\t\t}\r\n\t}\r\n\tServerProjectile projectile2;\r\n\tif (loadedAmmoDef == BoulderItemDef)\r\n\t{\r\n\t\tItemModCatapultBoulder component = loadedAmmoDef.GetComponent<ItemModCatapultBoulder>();\r\n\t\tif (component == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tforeach (ItemModCatapultBoulder.ProjectileSettings projectileSetting in component.projectileSettings)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < projectileSetting.count; i++)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Vector3 forward = muzzle.forward;\r\n\t\t\t\tforward = UnityEngine.Quaternion.Euler(UnityEngine.Random.Range(0f - component.spreadAngle, component.spreadAngle), UnityEngine.Random.Range(0f - component.spreadAngle, component.spreadAngle), 0f) * forward;\r\n\t\t\t\tif (FireProjectile(projectileSetting.prefab, firingPos, forward, shooter, 0.25f, 30f * num2, out var projectile))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!flag)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprojectile.GetComponent<TimedExplosive>()?.ForceExplode();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprojectile.ignoreEntity = this;\r\n\t\t\t\t\tprojectile.gravityModifier *= num * UnityEngine.Random.Range(1f - projectileSetting.gravityModifier, 1f + projectileSetting.gravityModifier);\r\n\t\t\t\t\tshooter.MarkHostileFor();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tloadedAmmoItem.UseItem();\r\n\t}\r\n\telse if (TryFireProjectile(ammoStorageRef.Get(base.isServer), Rust.AmmoTypes.CATAPULT_BOULDER, firingPos, muzzle.forward, shooter, 0.25f, 30f * num2, out projectile2))\r\n\t{\r\n\t\tprojectile2.ignoreEntity = this;\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tprojectile2.GetComponent<TimedExplosive>()?.ForceExplode();\r\n\t\t}\r\n\t\tprojectile2.gravityModifier *= num;\r\n\t\tshooter.MarkHostileFor();\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "Catapult",
    "methodName": "Fire",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSiegeWeaponFire",
    "fullName": "OnSiegeWeaponFire [Catapult]",
    "category": "Primitive",
    "parameters": [
      {
        "name": "catapult",
        "type": "Catapult, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void SERVER_WantsFire(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (CanFire())\r\n\t{\r\n\t\tfloat force = reloadProgress;\r\n\t\tFire(player, force);\r\n\t\treloadProgress = 0f;\r\n\t\ttimeSinceLastFire = 0f;\r\n\t\tFireAnimation();\r\n\t\tGameObjectRef loadedAmmoFiringEffect = GetLoadedAmmoFiringEffect();\r\n\t\tif (loadedAmmoFiringEffect != null && loadedAmmoFiringEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(loadedAmmoFiringEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.up, null, broadcast: true);\r\n\t\t}\r\n\t\tRefreshLastUseTime();\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"CLIENT_Fire\"));\r\n\t}\r\n}\r\n",
    "targetName": "Catapult",
    "methodName": "SERVER_WantsFire",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSiegeWeaponFire",
    "fullName": "OnSiegeWeaponFire [BatteringRam]",
    "category": "Primitive",
    "parameters": [
      {
        "name": "batteringRam",
        "type": "BatteringRam, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void SERVER_WantsAttack(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tBasePlayer driver = GetDriver();\r\n\tif (!(driver == null) && !(player == null) && !(driver != player) && CanAttack() && !driver.InSafeZone())\r\n\t{\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"CLIENT_Attack\"));\r\n\t\tInvoke(delegate\r\n\t\t{\r\n\t\t\tScanEntities(driver);\r\n\t\t}, 2f);\r\n\t\tSetFlag(BaseEntity.Flags.Busy, b: true);\r\n\t\tInvoke(delegate\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Busy, b: false);\r\n\t\t}, timeBetweenFire);\r\n\t}\r\n}\r\n",
    "targetName": "BatteringRam",
    "methodName": "SERVER_WantsAttack",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSiegeWeaponDoorOpen",
    "fullName": "OnSiegeWeaponDoorOpen [BatteringRam]",
    "category": "Primitive",
    "parameters": [
      {
        "name": "batteringRam",
        "type": "BatteringRam, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_OpenDoor(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract(usableWhileCrawling: true) && CanOpenDoor())\r\n\t{\r\n\t\tOpenDoor();\r\n\t}\r\n}\r\n",
    "targetName": "BatteringRam",
    "methodName": "RPC_OpenDoor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSiegeWeaponDoorClose",
    "fullName": "OnSiegeWeaponDoorClose [BatteringRam]",
    "category": "Primitive",
    "parameters": [
      {
        "name": "batteringRam",
        "type": "BatteringRam, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_CloseDoor(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract(usableWhileCrawling: true) && CanCloseDoor())\r\n\t{\r\n\t\tCloseDoor();\r\n\t}\r\n}\r\n",
    "targetName": "BatteringRam",
    "methodName": "RPC_CloseDoor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSiegeWeaponFire",
    "fullName": "OnSiegeWeaponFire [Ballista]",
    "category": "Primitive",
    "parameters": [
      {
        "name": "ballistaGun",
        "type": "BallistaGun, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.FromOwner(true)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void SERVER_FireClientProjectile(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!VerifyClientRPC(player))\r\n\t{\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!IsLoaded() || magazine.contents != 1 || player != GetMounted() || !CanFire() || player.InSafeZone())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemDefinition ammoType = magazine.ammoType;\r\n\t\tif (ammoType == null)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Item not found (\" + base.ShortPrefabName + \")\");\r\n\t\t\tplayer.stats.combat.LogInvalid(player, null, \"item_missing\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemModProjectile component = ammoType.GetComponent<ItemModProjectile>();\r\n\t\tif (component == null)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Item mod not found (\" + base.ShortPrefabName + \")\");\r\n\t\t\tplayer.stats.combat.LogInvalid(player, null, \"mod_missing\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tProtoBuf.ProjectileShoot projectileShoot = ProtoBuf.ProjectileShoot.Deserialize(msg.read);\r\n\t\tif (projectileShoot.projectiles.Count != 1)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Projectile count mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\t\tplayer.stats.combat.LogInvalid(player, null, \"count_mismatch\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayer.CleanupExpiredProjectiles();\r\n\t\tSystem.Guid projectileGroupId = System.Guid.NewGuid();\r\n\t\tforeach (ProtoBuf.ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\r\n\t\t{\r\n\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\r\n\t\t\t{\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Duplicate ID (\" + projectile.projectileID + \")\");\r\n\t\t\t\tplayer.stats.combat.LogInvalid(player, null, \"duplicate_id\");\r\n\t\t\t}\r\n\t\t\telse if (ValidateFirePos(player, projectile.startPos))\r\n\t\t\t{\r\n\t\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, null, ammoType, projectileGroupId, UnityEngine.Vector3.zero);\r\n\t\t\t\tEffect effect = new Effect();\r\n\t\t\t\teffect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);\r\n\t\t\t\teffect.scale = 1f;\r\n\t\t\t\teffect.pooledString = component.projectileObject.resourcePath;\r\n\t\t\t\teffect.number = projectile.seed;\r\n\t\t\t\tEffectNetwork.Send(effect);\r\n\t\t\t}\r\n\t\t}\r\n\t\tprojectileShoot?.Dispose();\r\n\t\tSendAimDirImmediate(force: true);\r\n\t\tplayer.MarkHostileFor();\r\n\t\tSignalBroadcast(BaseEntity.Signal.Attack, string.Empty, msg.connection);\r\n\t\tmagazine.contents = 0;\r\n\t\treloadProgress = 0f;\r\n\t\tSetFlag(BaseEntity.Flags.Reserved5, b: false);\r\n\t\tif (HasOwner())\r\n\t\t{\r\n\t\t\tballistaOwner.RefreshLastUseTime();\r\n\t\t\tballistaOwner.OnFired();\r\n\t\t}\r\n\t\tSingletonComponent<NpcNoiseManager>.Instance.OnWeaponShot(player, null);\r\n\t}\r\n}\r\n",
    "targetName": "BallistaGun",
    "methodName": "SERVER_FireClientProjectile",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSiegeWeaponPull",
    "fullName": "OnSiegeWeaponPull",
    "category": "Primitive",
    "parameters": [
      {
        "name": "baseSiegeWeapon",
        "type": "BaseSiegeWeapon, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void SERVER_StartPulling(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (CanPullNow(player) && !(rigidBody == null) && (!OnlyOwnerAccessible() || !(player != creatorEntity)))\r\n\t{\r\n\t\tplayer.metabolism.calories.Subtract(3f);\r\n\t\tplayer.metabolism.SendChangesToClient();\r\n\t\tif (rigidBody.IsSleeping())\r\n\t\t{\r\n\t\t\trigidBody.WakeUp();\r\n\t\t}\r\n\t\tStartPulling(player);\r\n\t}\r\n}\r\n",
    "targetName": "BaseSiegeWeapon",
    "methodName": "SERVER_StartPulling",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnConnectionDequeue",
    "fullName": "OnConnectionDequeue",
    "category": "Queue",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RemoveConnection(Network.Connection connection)\r\n{\r\n\tif (queue.Remove(connection))\r\n\t{\r\n\t\tnextMessageTime = 0f;\r\n\t}\r\n\tjoining.Remove(connection);\r\n}\r\n",
    "targetName": "ConnectionQueue",
    "methodName": "RemoveConnection",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnConnectionQueue",
    "fullName": "OnConnectionQueue",
    "category": "Queue",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Join(Network.Connection connection)\r\n{\r\n\tnextMessageTime = 0f;\r\n\tif ((Queued == 0 && !IsServerFull) || CanJumpQueue(connection))\r\n\t{\r\n\t\tJoinGame(connection);\r\n\t\treturn;\r\n\t}\r\n\tconnection.state = Network.Connection.State.InQueue;\r\n\tqueue.Add(connection);\r\n}\r\n",
    "targetName": "ConnectionQueue",
    "methodName": "Join",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnQueueUpdate",
    "fullName": "OnQueueUpdate",
    "category": "Queue",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SendQueueUpdate(Network.Connection c, int position)\r\n{\r\n\tNetwork.NetWrite netWrite = Network.Net.sv.StartWrite();\r\n\tnetWrite.PacketID(Network.Message.Type.QueueUpdate);\r\n\tnetWrite.UInt16((ushort)Queued);\r\n\tnetWrite.UInt16((ushort)position);\r\n\tnetWrite.Send(new Network.SendInfo(c));\r\n}\r\n",
    "targetName": "ConnectionQueue",
    "methodName": "SendQueueUpdate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnQueueCycle",
    "fullName": "OnQueueCycle",
    "category": "Queue",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Cycle(int availableSlots)\r\n{\r\n\tif (UnityEngine.Time.realtimeSinceStartup > nextCleanupReservedSlots)\r\n\t{\r\n\t\tnextCleanupReservedSlots = UnityEngine.Time.realtimeSinceStartup + 1f;\r\n\t\tCleanupExpiredReservedSlots();\r\n\t}\r\n\tif (queue.Count != 0)\r\n\t{\r\n\t\tSendQueueUpdates();\r\n\t\tif (!IsServerFull)\r\n\t\t{\r\n\t\t\tJoinGame(queue[0]);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ConnectionQueue",
    "methodName": "Cycle",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfListenerAdd",
    "fullName": "OnRfListenerAdd",
    "category": "Radio",
    "parameters": [
      {
        "name": "obj",
        "type": "IRFObject, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "frequency",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void AddListener(int frequency, IRFObject obj)\r\n{\r\n\tfrequency = ClampFrequency(frequency);\r\n\tif (GetListenerSet(frequency).Add(obj))\r\n\t{\r\n\t\tbool value;\r\n\t\tbool on = _isFrequencyBroadcasting.TryGetValue(frequency, out value) && value;\r\n\t\tobj.RFSignalUpdate(on);\r\n\t}\r\n}\r\n",
    "targetName": "RFManager",
    "methodName": "AddListener",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfListenerRemove",
    "fullName": "OnRfListenerRemove",
    "category": "Radio",
    "parameters": [
      {
        "name": "obj",
        "type": "IRFObject, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "frequency",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void RemoveListener(int frequency, IRFObject obj)\r\n{\r\n\tfrequency = ClampFrequency(frequency);\r\n\tif (GetListenerSet(frequency).Remove(obj))\r\n\t{\r\n\t\tobj.RFSignalUpdate(on: false);\r\n\t}\r\n}\r\n",
    "targetName": "RFManager",
    "methodName": "RemoveListener",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfBroadcasterAdd",
    "fullName": "OnRfBroadcasterAdd",
    "category": "Radio",
    "parameters": [
      {
        "name": "obj",
        "type": "IRFObject, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "frequency",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void AddBroadcaster(int frequency, IRFObject obj)\r\n{\r\n\tfrequency = ClampFrequency(frequency);\r\n\tSystem.Collections.Generic.HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);\r\n\tif (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning($\"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.\");\r\n\t}\r\n\tif (broadcasterSet.Add(obj) && (!_isFrequencyBroadcasting.TryGetValue(frequency, out var value) || !value))\r\n\t{\r\n\t\t_isFrequencyBroadcasting[frequency] = true;\r\n\t\tUpdateListenersForFrequency(frequency, isBroadcasting: true);\r\n\t}\r\n}\r\n",
    "targetName": "RFManager",
    "methodName": "AddBroadcaster",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfBroadcasterRemove",
    "fullName": "OnRfBroadcasterRemove",
    "category": "Radio",
    "parameters": [
      {
        "name": "obj",
        "type": "IRFObject, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "frequency",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void RemoveBroadcaster(int frequency, IRFObject obj)\r\n{\r\n\tfrequency = ClampFrequency(frequency);\r\n\tSystem.Collections.Generic.HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);\r\n\tif (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning($\"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.\");\r\n\t}\r\n\tif (broadcasterSet.Remove(obj) && broadcasterSet.Count == 0)\r\n\t{\r\n\t\t_isFrequencyBroadcasting[frequency] = false;\r\n\t\tUpdateListenersForFrequency(frequency, isBroadcasting: false);\r\n\t}\r\n}\r\n",
    "targetName": "RFManager",
    "methodName": "RemoveBroadcaster",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfBroadcasterAdded",
    "fullName": "OnRfBroadcasterAdded",
    "category": "Radio",
    "parameters": [
      {
        "name": "obj",
        "type": "IRFObject, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "frequency",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void AddBroadcaster(int frequency, IRFObject obj)\r\n{\r\n\tfrequency = ClampFrequency(frequency);\r\n\tSystem.Collections.Generic.HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);\r\n\tif (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning($\"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.\");\r\n\t}\r\n\tif (broadcasterSet.Add(obj) && (!_isFrequencyBroadcasting.TryGetValue(frequency, out var value) || !value))\r\n\t{\r\n\t\t_isFrequencyBroadcasting[frequency] = true;\r\n\t\tUpdateListenersForFrequency(frequency, isBroadcasting: true);\r\n\t}\r\n}\r\n",
    "targetName": "RFManager",
    "methodName": "AddBroadcaster",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRfListenerRemoved",
    "fullName": "OnRfListenerRemoved",
    "category": "Radio",
    "parameters": [
      {
        "name": "obj",
        "type": "IRFObject, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "frequency",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void RemoveListener(int frequency, IRFObject obj)\r\n{\r\n\tfrequency = ClampFrequency(frequency);\r\n\tif (GetListenerSet(frequency).Remove(obj))\r\n\t{\r\n\t\tobj.RFSignalUpdate(on: false);\r\n\t}\r\n}\r\n",
    "targetName": "RFManager",
    "methodName": "RemoveListener",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRfListenerAdded",
    "fullName": "OnRfListenerAdded",
    "category": "Radio",
    "parameters": [
      {
        "name": "obj",
        "type": "IRFObject, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "frequency",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void AddListener(int frequency, IRFObject obj)\r\n{\r\n\tfrequency = ClampFrequency(frequency);\r\n\tif (GetListenerSet(frequency).Add(obj))\r\n\t{\r\n\t\tbool value;\r\n\t\tbool on = _isFrequencyBroadcasting.TryGetValue(frequency, out value) && value;\r\n\t\tobj.RFSignalUpdate(on);\r\n\t}\r\n}\r\n",
    "targetName": "RFManager",
    "methodName": "AddListener",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRfBroadcasterRemoved",
    "fullName": "OnRfBroadcasterRemoved",
    "category": "Radio",
    "parameters": [
      {
        "name": "obj",
        "type": "IRFObject, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "frequency",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void RemoveBroadcaster(int frequency, IRFObject obj)\r\n{\r\n\tfrequency = ClampFrequency(frequency);\r\n\tSystem.Collections.Generic.HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);\r\n\tif (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning($\"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.\");\r\n\t}\r\n\tif (broadcasterSet.Remove(obj) && broadcasterSet.Count == 0)\r\n\t{\r\n\t\t_isFrequencyBroadcasting[frequency] = false;\r\n\t\tUpdateListenersForFrequency(frequency, isBroadcasting: false);\r\n\t}\r\n}\r\n",
    "targetName": "RFManager",
    "methodName": "RemoveBroadcaster",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRfListenerRemoved [patch]",
    "fullName": "OnRfListenerRemoved [patch]",
    "category": "Radio",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void RemoveListener(int frequency, IRFObject obj)\r\n{\r\n\tfrequency = ClampFrequency(frequency);\r\n\tif (GetListenerSet(frequency).Remove(obj))\r\n\t{\r\n\t\tobj.RFSignalUpdate(on: false);\r\n\t}\r\n}\r\n",
    "targetName": "RFManager",
    "methodName": "RemoveListener",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfFrequencyChange",
    "fullName": "OnRfFrequencyChange [Broadcaster]",
    "category": "Radio",
    "parameters": [
      {
        "name": "rFBroadcaster",
        "type": "RFBroadcaster, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(3uL)]\r\npublic void ServerSetFrequency(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (CanChangeFrequency(msg.player) && !(UnityEngine.Time.time < nextChangeTime))\r\n\t{\r\n\t\tnextChangeTime = UnityEngine.Time.time + 2f;\r\n\t\tint freq = msg.read.Int32();\r\n\t\tfreq = RFManager.ClampFrequency(freq);\r\n\t\tif (RFManager.IsReserved(freq))\r\n\t\t{\r\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tRFManager.ChangeFrequency(frequency, freq, this, isListener: false, IsPowered());\r\n\t\tfrequency = freq;\r\n\t\tMarkDirty();\r\n\t\tSendNetworkUpdate();\r\n\t\tHurt(MaxHealth() * 0.01f, Rust.DamageType.Decay, this);\r\n\t}\r\n}\r\n",
    "targetName": "RFBroadcaster",
    "methodName": "ServerSetFrequency",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfFrequencyChanged",
    "fullName": "OnRfFrequencyChanged [Broadcaster]",
    "category": "Radio",
    "parameters": [
      {
        "name": "rFBroadcaster",
        "type": "RFBroadcaster, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(3uL)]\r\npublic void ServerSetFrequency(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (CanChangeFrequency(msg.player) && !(UnityEngine.Time.time < nextChangeTime))\r\n\t{\r\n\t\tnextChangeTime = UnityEngine.Time.time + 2f;\r\n\t\tint freq = msg.read.Int32();\r\n\t\tfreq = RFManager.ClampFrequency(freq);\r\n\t\tif (RFManager.IsReserved(freq))\r\n\t\t{\r\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tRFManager.ChangeFrequency(frequency, freq, this, isListener: false, IsPowered());\r\n\t\tfrequency = freq;\r\n\t\tMarkDirty();\r\n\t\tSendNetworkUpdate();\r\n\t\tHurt(MaxHealth() * 0.01f, Rust.DamageType.Decay, this);\r\n\t}\r\n}\r\n",
    "targetName": "RFBroadcaster",
    "methodName": "ServerSetFrequency",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRfFrequencyChange",
    "fullName": "OnRfFrequencyChange [Receiver]",
    "category": "Radio",
    "parameters": [
      {
        "name": "rFReceiver",
        "type": "RFReceiver, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(3uL)]\r\npublic void ServerSetFrequency(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!(msg.player == null) && msg.player.CanBuild())\r\n\t{\r\n\t\tint freq = msg.read.Int32();\r\n\t\tfreq = RFManager.ClampFrequency(freq);\r\n\t\tRFManager.ChangeFrequency(frequency, freq, this, isListener: true);\r\n\t\tfrequency = freq;\r\n\t\tMarkDirty();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "RFReceiver",
    "methodName": "ServerSetFrequency",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfFrequencyChanged",
    "fullName": "OnRfFrequencyChanged [Receiver]",
    "category": "Radio",
    "parameters": [
      {
        "name": "rFReceiver",
        "type": "RFReceiver, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(3uL)]\r\npublic void ServerSetFrequency(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!(msg.player == null) && msg.player.CanBuild())\r\n\t{\r\n\t\tint freq = msg.read.Int32();\r\n\t\tfreq = RFManager.ClampFrequency(freq);\r\n\t\tRFManager.ChangeFrequency(frequency, freq, this, isListener: true);\r\n\t\tfrequency = freq;\r\n\t\tMarkDirty();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "RFReceiver",
    "methodName": "ServerSetFrequency",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRfFrequencyChange",
    "fullName": "OnRfFrequencyChange [Detonator]",
    "category": "Radio",
    "parameters": [
      {
        "name": "detonator",
        "type": "Detonator, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "freq",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void ServerSetFrequency(BaseEntity.RPCMessage msg)\r\n{\r\n\tServerSetFrequency(msg.player, msg.read.Int32());\r\n}\r\n",
    "targetName": "Detonator",
    "methodName": "ServerSetFrequency",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfFrequencyChanged",
    "fullName": "OnRfFrequencyChanged [Detonator]",
    "category": "Radio",
    "parameters": [
      {
        "name": "detonator",
        "type": "Detonator, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "freq",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void ServerSetFrequency(BaseEntity.RPCMessage msg)\r\n{\r\n\tServerSetFrequency(msg.player, msg.read.Int32());\r\n}\r\n",
    "targetName": "Detonator",
    "methodName": "ServerSetFrequency",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRfFrequencyChange",
    "fullName": "OnRfFrequencyChange [PagerEntity]",
    "category": "Radio",
    "parameters": [
      {
        "name": "pagerEntity",
        "type": "PagerEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ServerSetFrequency(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!(msg.player == null) && msg.player.CanBuild() && !(UnityEngine.Time.time < nextChangeTime))\r\n\t{\r\n\t\tnextChangeTime = UnityEngine.Time.time + 2f;\r\n\t\tint newFrequency = msg.read.Int32();\r\n\t\tRFManager.ChangeFrequency(frequency, newFrequency, this, isListener: true);\r\n\t\tfrequency = newFrequency;\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "PagerEntity",
    "methodName": "ServerSetFrequency",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRfFrequencyChanged",
    "fullName": "OnRfFrequencyChanged [PagerEntity]",
    "category": "Radio",
    "parameters": [
      {
        "name": "pagerEntity",
        "type": "PagerEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ServerSetFrequency(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!(msg.player == null) && msg.player.CanBuild() && !(UnityEngine.Time.time < nextChangeTime))\r\n\t{\r\n\t\tnextChangeTime = UnityEngine.Time.time + 2f;\r\n\t\tint newFrequency = msg.read.Int32();\r\n\t\tRFManager.ChangeFrequency(frequency, newFrequency, this, isListener: true);\r\n\t\tfrequency = newFrequency;\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "PagerEntity",
    "methodName": "ServerSetFrequency",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnBoomboxStationValidate",
    "fullName": "OnBoomboxStationValidate",
    "category": "Radio",
    "parameters": [
      {
        "name": "url",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool IsStationValid(string url)\r\n{\r\n\tParseServerUrlList();\r\n\tShoutcastStreamer.CheckBuiltInRadios();\r\n\tif (ValidStations == null || !ValidStations.ContainsValue(url))\r\n\t{\r\n\t\tif (ServerValidStations == null || !ServerValidStations.ContainsValue(url))\r\n\t\t{\r\n\t\t\tif (ShoutcastStreamer.ParsedLocalRadioList != null)\r\n\t\t\t{\r\n\t\t\t\treturn ShoutcastStreamer.ParsedLocalRadioList.ContainsValue(url);\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "BoomBox",
    "methodName": "IsStationValid",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnBoomboxToggle",
    "fullName": "OnBoomboxToggle",
    "category": "Radio",
    "parameters": [
      {
        "name": "boomBox",
        "type": "BoomBox, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ServerTogglePlay(BaseEntity.RPCMessage msg, bool bypassPower = false)\r\n{\r\n\tif (IsPowered() || bypassPower)\r\n\t{\r\n\t\tbool play = msg.read.ReadByte() == 1;\r\n\t\tServerTogglePlay(play);\r\n\t}\r\n}\r\n",
    "targetName": "BoomBox",
    "methodName": "ServerTogglePlay",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBoomboxStationUpdate",
    "fullName": "OnBoomboxStationUpdate",
    "category": "Radio",
    "parameters": [
      {
        "name": "boomBox",
        "type": "BoomBox, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)\r\n{\r\n\tstring text = msg.read.String();\r\n\tif (IsStationValid(text))\r\n\t{\r\n\t\tif (msg.player != null)\r\n\t\t{\r\n\t\t\tulong assignedRadioBy = msg.player.userID.Get();\r\n\t\t\tAssignedRadioBy = assignedRadioBy;\r\n\t\t}\r\n\t\tCurrentRadioIp = text;\r\n\t\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\"OnRadioIPChanged\"), CurrentRadioIp);\r\n\t\tif (IsOn())\r\n\t\t{\r\n\t\t\tServerTogglePlay(play: false);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BoomBox",
    "methodName": "Server_UpdateRadioIP",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBoomboxStationUpdated",
    "fullName": "OnBoomboxStationUpdated",
    "category": "Radio",
    "parameters": [
      {
        "name": "boomBox",
        "type": "BoomBox, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)\r\n{\r\n\tstring text = msg.read.String();\r\n\tif (IsStationValid(text))\r\n\t{\r\n\t\tif (msg.player != null)\r\n\t\t{\r\n\t\t\tulong assignedRadioBy = msg.player.userID.Get();\r\n\t\t\tAssignedRadioBy = assignedRadioBy;\r\n\t\t}\r\n\t\tCurrentRadioIp = text;\r\n\t\tbase.baseEntity.ClientRPC(RpcTarget.NetworkGroup(\"OnRadioIPChanged\"), CurrentRadioIp);\r\n\t\tif (IsOn())\r\n\t\t{\r\n\t\t\tServerTogglePlay(play: false);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BoomBox",
    "methodName": "Server_UpdateRadioIP",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDispenserGather",
    "fullName": "OnDispenserGather",
    "category": "Resource",
    "parameters": [
      {
        "name": "resourceDispenser",
        "type": "ResourceDispenser, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "entity",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local7",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)\r\n{\r\n\tif (itemAmt.amount == 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = UnityEngine.Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();\r\n\tfloat num2 = itemAmt.startAmount / startingItemCounts;\r\n\tfloat f = UnityEngine.Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);\r\n\tf = UnityEngine.Mathf.Round(f);\r\n\tfloat num3 = f * destroyFraction * 2f;\r\n\tif (itemAmt.amount <= f + num3)\r\n\t{\r\n\t\tfloat num4 = (f + num3) / itemAmt.amount;\r\n\t\tf /= num4;\r\n\t\tnum3 /= num4;\r\n\t}\r\n\titemAmt.amount -= UnityEngine.Mathf.Floor(f);\r\n\titemAmt.amount -= UnityEngine.Mathf.Floor(num3);\r\n\tif (f < 1f)\r\n\t{\r\n\t\tf = ((UnityEngine.Random.Range(0f, 1f) <= f) ? 1f : 0f);\r\n\t\titemAmt.amount = 0f;\r\n\t}\r\n\tif (itemAmt.amount < 0f)\r\n\t{\r\n\t\titemAmt.amount = 0f;\r\n\t}\r\n\tif (f >= 1f)\r\n\t{\r\n\t\tint num5 = CalculateGatherBonus(entity, itemAmt, f);\r\n\t\tint iAmount = UnityEngine.Mathf.FloorToInt(f) + num5;\r\n\t\tItem item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tApplyItemOwnership(entity, item);\r\n\t\t\tOverrideOwnership(item, attackWeapon);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);\r\n\t\t\tentity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ResourceDispenser",
    "methodName": "GiveResourceFromItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnDispenserBonus",
    "fullName": "OnDispenserBonus",
    "category": "Resource",
    "parameters": [
      {
        "name": "resourceDispenser",
        "type": "ResourceDispenser, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)\r\n{\r\n\tif (forceFullFinishBonus)\r\n\t{\r\n\t\tfraction = 1f;\r\n\t}\r\n\tSendMessage(\"FinishBonusAssigned\", UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\tif (fraction <= 0f || finishBonus == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (ItemAmount finishBonu in finishBonus)\r\n\t{\r\n\t\tint num = UnityEngine.Mathf.CeilToInt((float)(int)finishBonu.amount * UnityEngine.Mathf.Clamp01(fraction));\r\n\t\tint num2 = CalculateGatherBonus(player, finishBonu, num);\r\n\t\tItem item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tApplyItemOwnership(player, item);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);\r\n\t\t\tplayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ResourceDispenser",
    "methodName": "AssignFinishBonus",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDispenserGathered",
    "fullName": "OnDispenserGathered",
    "category": "Resource",
    "parameters": [
      {
        "name": "resourceDispenser",
        "type": "ResourceDispenser, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "entity",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local7",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)\r\n{\r\n\tif (itemAmt.amount == 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = UnityEngine.Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();\r\n\tfloat num2 = itemAmt.startAmount / startingItemCounts;\r\n\tfloat f = UnityEngine.Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);\r\n\tf = UnityEngine.Mathf.Round(f);\r\n\tfloat num3 = f * destroyFraction * 2f;\r\n\tif (itemAmt.amount <= f + num3)\r\n\t{\r\n\t\tfloat num4 = (f + num3) / itemAmt.amount;\r\n\t\tf /= num4;\r\n\t\tnum3 /= num4;\r\n\t}\r\n\titemAmt.amount -= UnityEngine.Mathf.Floor(f);\r\n\titemAmt.amount -= UnityEngine.Mathf.Floor(num3);\r\n\tif (f < 1f)\r\n\t{\r\n\t\tf = ((UnityEngine.Random.Range(0f, 1f) <= f) ? 1f : 0f);\r\n\t\titemAmt.amount = 0f;\r\n\t}\r\n\tif (itemAmt.amount < 0f)\r\n\t{\r\n\t\titemAmt.amount = 0f;\r\n\t}\r\n\tif (f >= 1f)\r\n\t{\r\n\t\tint num5 = CalculateGatherBonus(entity, itemAmt, f);\r\n\t\tint iAmount = UnityEngine.Mathf.FloorToInt(f) + num5;\r\n\t\tItem item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tApplyItemOwnership(entity, item);\r\n\t\t\tOverrideOwnership(item, attackWeapon);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);\r\n\t\t\tentity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ResourceDispenser",
    "methodName": "GiveResourceFromItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDispenserBonusReceived",
    "fullName": "OnDispenserBonusReceived",
    "category": "Resource",
    "parameters": [
      {
        "name": "resourceDispenser",
        "type": "ResourceDispenser, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)\r\n{\r\n\tif (forceFullFinishBonus)\r\n\t{\r\n\t\tfraction = 1f;\r\n\t}\r\n\tSendMessage(\"FinishBonusAssigned\", UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\tif (fraction <= 0f || finishBonus == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (ItemAmount finishBonu in finishBonus)\r\n\t{\r\n\t\tint num = UnityEngine.Mathf.CeilToInt((float)(int)finishBonu.amount * UnityEngine.Mathf.Clamp01(fraction));\r\n\t\tint num2 = CalculateGatherBonus(player, finishBonu, num);\r\n\t\tItem item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tApplyItemOwnership(player, item);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);\r\n\t\t\tplayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ResourceDispenser",
    "methodName": "AssignFinishBonus",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSurveyGather",
    "fullName": "OnSurveyGather",
    "category": "Resource",
    "parameters": [
      {
        "name": "surveyCharge",
        "type": "SurveyCharge, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void Explode()\r\n{\r\n\tbase.Explode();\r\n\tif (WaterLevel.Test(base.transform.position, waves: true, volumes: true, this))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);\r\n\tif (orCreate == null || UnityEngine.Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\torCreate.lastSurveyTime = UnityEngine.Time.realtimeSinceStartup;\r\n\tif (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tUnityEngine.Vector3 point = hitOut.point;\r\n\t_ = hitOut.normal;\r\n\tSystem.Collections.Generic.List<SurveyCrater> obj = Facepunch.Pool.Get<System.Collections.Generic.List<SurveyCrater>>();\r\n\tVis.Entities(base.transform.position, 10f, obj, 1);\r\n\tbool num = obj.Count > 0;\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\tif (num)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = false;\r\n\tbool flag2 = false;\r\n\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)\r\n\t{\r\n\t\tif (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)\r\n\t\t{\r\n\t\t\tint num2 = UnityEngine.Mathf.Clamp(UnityEngine.Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);\r\n\t\t\tint iAmount = 1;\r\n\t\t\tflag = true;\r\n\t\t\tif (resource.isLiquid)\r\n\t\t\t{\r\n\t\t\t\tflag2 = true;\r\n\t\t\t}\r\n\t\t\tfor (int i = 0; i < num2; i++)\r\n\t\t\t{\r\n\t\t\t\tItem item = ItemManager.Create(resource.type, iAmount, 0uL);\r\n\t\t\t\tUnityEngine.Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, UnityEngine.Vector3.up);\r\n\t\t\t\titem.Drop(base.transform.position + UnityEngine.Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tstring strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, point, UnityEngine.Quaternion.identity);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "SurveyCharge",
    "methodName": "Explode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnResourceDepositCreated",
    "fullName": "OnResourceDepositCreated",
    "category": "Resource",
    "parameters": [
      {
        "name": "local1",
        "type": "ResourceDepositManager+ResourceDeposit, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public ResourceDepositManager.ResourceDeposit CreateFromPosition(UnityEngine.Vector3 pos)\r\n{\r\n\tVector2i indexFrom = GetIndexFrom(pos);\r\n\tUnityEngine.Random.State state = UnityEngine.Random.state;\r\n\tUnityEngine.Random.InitState((int)new UnityEngine.Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt));\r\n\tResourceDepositManager.ResourceDeposit resourceDeposit = new ResourceDepositManager.ResourceDeposit\r\n\t{\r\n\t\torigin = new UnityEngine.Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)\r\n\t};\r\n\tif (UnityEngine.Random.Range(0f, 1f) < 0.5f)\r\n\t{\r\n\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\"stones\"), 1f, 100, 1f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tbool flag = false;\r\n\t\tfloat num = 0f;\r\n\t\tif (World.Procedural)\r\n\t\t{\r\n\t\t\tif (TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)\r\n\t\t\t{\r\n\t\t\t\tnum += 0.25f;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnum += 0.15f;\r\n\t\t}\r\n\t\tif (UnityEngine.Random.Range(0f, 1f) >= 1f - num)\r\n\t\t{\r\n\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\"crude.oil\"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(8f, 10f), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, liquid: true);\r\n\t\t\tflag = true;\r\n\t\t}\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\"stones\"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);\r\n\t\t\tfloat num2 = 0f;\r\n\t\t\tnum2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));\r\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)\r\n\t\t\t{\r\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\"metal.ore\"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);\r\n\t\t\t}\r\n\t\t\tfloat num3 = 0f;\r\n\t\t\tnum3 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));\r\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) >= 1f - num3)\r\n\t\t\t{\r\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\"sulfur.ore\"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);\r\n\t\t\t}\r\n\t\t\tfloat num4 = 0f;\r\n\t\t\tif (World.Procedural)\r\n\t\t\t{\r\n\t\t\t\tif (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)\r\n\t\t\t\t{\r\n\t\t\t\t\tnum4 += 0.25f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tnum4 += 0.15f;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) >= 1f - num4)\r\n\t\t\t{\r\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\"hq.metal.ore\"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t_deposits.Add(indexFrom, resourceDeposit);\r\n\tUnityEngine.Random.state = state;\r\n\treturn resourceDeposit;\r\n}\r\n",
    "targetName": "ResourceDepositManager",
    "methodName": "CreateFromPosition",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnLootSpawn",
    "fullName": "OnLootSpawn [LootContainer]",
    "category": "Resource",
    "parameters": [
      {
        "name": "lootContainer",
        "type": "LootContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void SpawnLoot()\r\n{\r\n\tif (base.inventory == null)\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!\");\r\n\t\treturn;\r\n\t}\r\n\tbase.inventory.Clear();\r\n\tItemManager.DoRemoves();\r\n\tPopulateLoot();\r\n\tif (shouldRefreshContents)\r\n\t{\r\n\t\tInvoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));\r\n\t}\r\n}\r\n",
    "targetName": "LootContainer",
    "methodName": "SpawnLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCollectiblePickup",
    "fullName": "OnCollectiblePickup",
    "category": "Resource",
    "parameters": [
      {
        "name": "collectibleEntity",
        "type": "CollectibleEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "reciever",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "eat",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoPickup(BasePlayer reciever, bool eat = false)\r\n{\r\n\tif (itemList == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = ((reciever.modifiers != null) ? reciever.modifiers.GetValue(Modifier.ModifierType.Collectible_DoubleYield) : 0f);\r\n\tbool flag = num != 0f && UnityEngine.Random.value < num;\r\n\tItemAmount[] array = itemList;\r\n\tforeach (ItemAmount itemAmount in array)\r\n\t{\r\n\t\tif (reciever != null && reciever.IsInTutorial && itemAmount.ignoreInTutorial)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tItem item = ItemManager.Create(itemAmount.itemDef, flag ? ((int)itemAmount.amount * 2) : ((int)itemAmount.amount), 0uL);\r\n\t\tif (item == null)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\titem.SetItemOwnership(reciever, ItemOwnershipPhrases.GatheredPhrase);\r\n\t\tif (eat && item.info.category == ItemCategory.Food && reciever != null)\r\n\t\t{\r\n\t\t\tItemModConsume component = item.info.GetComponent<ItemModConsume>();\r\n\t\t\tif (component != null)\r\n\t\t\t{\r\n\t\t\t\tcomponent.DoAction(item, reciever);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((bool)reciever)\r\n\t\t{\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);\r\n\t\t\treciever.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\titem.Drop(base.transform.position + UnityEngine.Vector3.up * 0.5f, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t}\r\n\titemList = null;\r\n\tif (pickupEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);\r\n\t}\r\n\tRandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);\r\n\tif (randomItemDispenser != null)\r\n\t{\r\n\t\trandomItemDispenser.DistributeItems(reciever, base.transform.position);\r\n\t}\r\n\tKill();\r\n}\r\n",
    "targetName": "CollectibleEntity",
    "methodName": "DoPickup",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCollectiblePickedup",
    "fullName": "OnCollectiblePickedup",
    "category": "Resource",
    "parameters": [
      {
        "name": "collectibleEntity",
        "type": "CollectibleEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "reciever",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local6",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoPickup(BasePlayer reciever, bool eat = false)\r\n{\r\n\tif (itemList == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = ((reciever.modifiers != null) ? reciever.modifiers.GetValue(Modifier.ModifierType.Collectible_DoubleYield) : 0f);\r\n\tbool flag = num != 0f && UnityEngine.Random.value < num;\r\n\tItemAmount[] array = itemList;\r\n\tforeach (ItemAmount itemAmount in array)\r\n\t{\r\n\t\tif (reciever != null && reciever.IsInTutorial && itemAmount.ignoreInTutorial)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tItem item = ItemManager.Create(itemAmount.itemDef, flag ? ((int)itemAmount.amount * 2) : ((int)itemAmount.amount), 0uL);\r\n\t\tif (item == null)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\titem.SetItemOwnership(reciever, ItemOwnershipPhrases.GatheredPhrase);\r\n\t\tif (eat && item.info.category == ItemCategory.Food && reciever != null)\r\n\t\t{\r\n\t\t\tItemModConsume component = item.info.GetComponent<ItemModConsume>();\r\n\t\t\tif (component != null)\r\n\t\t\t{\r\n\t\t\t\tcomponent.DoAction(item, reciever);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((bool)reciever)\r\n\t\t{\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);\r\n\t\t\treciever.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\titem.Drop(base.transform.position + UnityEngine.Vector3.up * 0.5f, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t}\r\n\titemList = null;\r\n\tif (pickupEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);\r\n\t}\r\n\tRandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);\r\n\tif (randomItemDispenser != null)\r\n\t{\r\n\t\trandomItemDispenser.DistributeItems(reciever, base.transform.position);\r\n\t}\r\n\tKill();\r\n}\r\n",
    "targetName": "CollectibleEntity",
    "methodName": "DoPickup",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnExcavatorGather",
    "fullName": "OnExcavatorGather",
    "category": "Resource",
    "parameters": [
      {
        "name": "excavatorArm",
        "type": "ExcavatorArm, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local8",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ProduceResources()\r\n{\r\n\tfloat num = resourceProductionTickRate / timeForFullResources;\r\n\tfloat num2 = resourcesToMine[resourceMiningIndex].amount * num;\r\n\tpendingResources[resourceMiningIndex].amount += num2;\r\n\tItemAmount[] array = pendingResources;\r\n\tforeach (ItemAmount itemAmount in array)\r\n\t{\r\n\t\tif (!(itemAmount.amount >= (float)outputPiles.Count))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tint num3 = UnityEngine.Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);\r\n\t\titemAmount.amount -= num3 * 2;\r\n\t\tforeach (ExcavatorOutputPile outputPile in outputPiles)\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);\r\n\t\t\tif (!item.MoveToContainer(outputPile.inventory))\r\n\t\t\t{\r\n\t\t\t\titem.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ExcavatorArm",
    "methodName": "ProduceResources",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnExcavatorMiningToggled",
    "fullName": "OnExcavatorMiningToggled [start]",
    "category": "Resource",
    "parameters": [
      {
        "name": "excavatorArm",
        "type": "ExcavatorArm, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void BeginMining()\r\n{\r\n\tif (!IsPowered())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\tInvokeRepeating(ProduceResources, resourceProductionTickRate, resourceProductionTickRate);\r\n\tif (UnityEngine.Time.time > nextNotificationTime)\r\n\t{\r\n\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\r\n\t\t{\r\n\t\t\tif (!activePlayer.IsNpc && activePlayer.IsConnected && !activePlayer.IsInTutorial)\r\n\t\t\t{\r\n\t\t\t\tactivePlayer.ShowToast(GameTip.Styles.Server_Event, excavatorPhrase, false);\r\n\t\t\t}\r\n\t\t}\r\n\t\tnextNotificationTime = UnityEngine.Time.time + 60f;\r\n\t}\r\n\tExcavatorServerEffects.SetMining(isMining: true);\r\n\tFacepunch.Rust.Analytics.Server.ExcavatorStarted();\r\n\texcavatorStartTime = GetNetworkTime();\r\n}\r\n",
    "targetName": "ExcavatorArm",
    "methodName": "BeginMining",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnExcavatorMiningToggled",
    "fullName": "OnExcavatorMiningToggled [stop]",
    "category": "Resource",
    "parameters": [
      {
        "name": "excavatorArm",
        "type": "ExcavatorArm, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StopMining()\r\n{\r\n\tExcavatorServerEffects.SetMining(isMining: false);\r\n\tCancelInvoke(ProduceResources);\r\n\tif (HasFlag(BaseEntity.Flags.On))\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Server.ExcavatorStopped(GetNetworkTime() - excavatorStartTime);\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.On, b: false);\r\n}\r\n",
    "targetName": "ExcavatorArm",
    "methodName": "StopMining",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnExcavatorResourceSet",
    "fullName": "OnExcavatorResourceSet",
    "category": "Resource",
    "parameters": [
      {
        "name": "excavatorArm",
        "type": "ExcavatorArm, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_SetResourceTarget(BaseEntity.RPCMessage msg)\r\n{\r\n\tswitch (msg.read.String())\r\n\t{\r\n\tcase \"HQM\":\r\n\t\tresourceMiningIndex = 0;\r\n\t\tbreak;\r\n\tcase \"Sulfur\":\r\n\t\tresourceMiningIndex = 1;\r\n\t\tbreak;\r\n\tcase \"Stone\":\r\n\t\tresourceMiningIndex = 2;\r\n\t\tbreak;\r\n\tcase \"Metal\":\r\n\t\tresourceMiningIndex = 3;\r\n\t\tbreak;\r\n\t}\r\n\tif (!IsOn())\r\n\t{\r\n\t\tBeginMining();\r\n\t}\r\n}\r\n",
    "targetName": "ExcavatorArm",
    "methodName": "RPC_SetResourceTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnGrowableGathered",
    "fullName": "OnGrowableGathered",
    "category": "Resource",
    "parameters": [
      {
        "name": "growableEntity",
        "type": "GrowableEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void GiveFruit(BasePlayer player, int amount, bool eat)\r\n{\r\n\tif (amount <= 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = Properties.pickupItem.condition.enabled;\r\n\tif (flag)\r\n\t{\r\n\t\tfor (int i = 0; i < amount; i++)\r\n\t\t{\r\n\t\t\tGiveFruit(player, 1, flag, eat);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tGiveFruit(player, amount, flag, eat);\r\n\t}\r\n}\r\n",
    "targetName": "GrowableEntity",
    "methodName": "GiveFruit",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnGrowableGather",
    "fullName": "OnGrowableGather",
    "category": "Resource",
    "parameters": [
      {
        "name": "growableEntity",
        "type": "GrowableEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void PickFruit(BasePlayer player, bool eat = false)\r\n{\r\n\tif (!CanPick())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tharvests++;\r\n\tGiveFruit(player, CurrentPickAmount, eat);\r\n\tRandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);\r\n\tif (randomItemDispenser != null)\r\n\t{\r\n\t\trandomItemDispenser.DistributeItems(player, base.transform.position);\r\n\t}\r\n\tResetSeason();\r\n\tif (Properties.pickEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t}\r\n\tif (harvests >= Properties.maxHarvests)\r\n\t{\r\n\t\tif (Properties.disappearAfterHarvest)\r\n\t\t{\r\n\t\t\tTellPlanter();\r\n\t\t\tDie();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tChangeState(PlantProperties.State.Dying, resetAge: true);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tChangeState(PlantProperties.State.Mature, resetAge: true);\r\n\t}\r\n}\r\n",
    "targetName": "GrowableEntity",
    "methodName": "PickFruit",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRemoveDying",
    "fullName": "OnRemoveDying",
    "category": "Resource",
    "parameters": [
      {
        "name": "growableEntity",
        "type": "GrowableEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "receiver",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RemoveDying(BasePlayer receiver)\r\n{\r\n\tif (State == PlantProperties.State.Dying && !(Properties.removeDyingItem == null))\r\n\t{\r\n\t\tif (Properties.removeDyingEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(Properties.removeDyingEffect.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t\t}\r\n\t\tItem item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);\r\n\t\tif (receiver != null)\r\n\t\t{\r\n\t\t\treceiver.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\titem.Drop(base.transform.position + UnityEngine.Vector3.up * 0.5f, UnityEngine.Vector3.up * 1f);\r\n\t\t}\r\n\t\tTellPlanter();\r\n\t\tDie();\r\n\t}\r\n}\r\n",
    "targetName": "GrowableEntity",
    "methodName": "RemoveDying",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnGrowableStateChange",
    "fullName": "OnGrowableStateChange",
    "category": "Resource",
    "parameters": [
      {
        "name": "growableEntity",
        "type": "GrowableEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "state",
        "type": "PlantProperties+State, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ChangeState(PlantProperties.State state, bool resetAge, bool loading = false)\r\n{\r\n\tif (base.isServer && State == state)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tState = state;\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!loading)\r\n\t{\r\n\t\tif (currentStage.resources > 0f)\r\n\t\t{\r\n\t\t\tyieldPool = currentStage.yield;\r\n\t\t}\r\n\t\tif (state == PlantProperties.State.Crossbreed)\r\n\t\t{\r\n\t\t\tif (Properties.CrossBreedEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(Properties.CrossBreedEffect.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t\t\t}\r\n\t\t\tGrowableGenetics.CrossBreed(this);\r\n\t\t}\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n\tif (resetAge)\r\n\t{\r\n\t\tstageAge = 0f;\r\n\t}\r\n}\r\n",
    "targetName": "GrowableEntity",
    "methodName": "ChangeState",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnQuarryConsumeFuel",
    "fullName": "OnQuarryConsumeFuel",
    "category": "Resource",
    "parameters": [
      {
        "name": "miningQuarry",
        "type": "MiningQuarry, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool FuelCheck()\r\n{\r\n\tif (pendingWork > 0f)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tItem item = fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.FindItemByItemName(\"diesel_barrel\");\r\n\tif (item != null && item.amount >= 1)\r\n\t{\r\n\t\tpendingWork += workPerFuel;\r\n\t\tFacepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);\r\n\t\titem.UseItem();\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "MiningQuarry",
    "methodName": "FuelCheck",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnQuarryGather",
    "fullName": "OnQuarryGather",
    "category": "Resource",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ProcessResources()\r\n{\r\n\tif (_linkedDeposit == null || hopperPrefab.instance == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!FuelCheck())\r\n\t{\r\n\t\tSetOn(isOn: false);\r\n\t}\r\n\tfloat num = UnityEngine.Mathf.Min(workToAdd, pendingWork);\r\n\tpendingWork -= num;\r\n\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)\r\n\t{\r\n\t\tif ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tfloat workNeeded = resource.workNeeded;\r\n\t\tint num2 = UnityEngine.Mathf.FloorToInt(resource.workDone / workNeeded);\r\n\t\tresource.workDone += num;\r\n\t\tint num3 = UnityEngine.Mathf.FloorToInt(resource.workDone / workNeeded);\r\n\t\tif (resource.workDone > workNeeded)\r\n\t\t{\r\n\t\t\tresource.workDone %= workNeeded;\r\n\t\t}\r\n\t\tif (num2 != num3)\r\n\t\t{\r\n\t\t\tint iAmount = num3 - num2;\r\n\t\t\tItem item = ItemManager.Create(resource.type, iAmount, 0uL);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);\r\n\t\t\tif (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))\r\n\t\t\t{\r\n\t\t\t\titem.Remove();\r\n\t\t\t\tSetOn(isOn: false);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "MiningQuarry",
    "methodName": "ProcessResources",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCoalingTowerStart",
    "fullName": "OnCoalingTowerStart",
    "category": "Resource",
    "parameters": [
      {
        "name": "coalingTower",
        "type": "CoalingTower, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_Unload(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!TryUnloadActiveWagon(out var attemptStatus) && msg.player != null)\r\n\t{\r\n\t\tClientRPC(RpcTarget.Player(\"ActionFailed\", msg.player), (byte)attemptStatus, arg2: true);\r\n\t}\r\n}\r\n",
    "targetName": "CoalingTower",
    "methodName": "RPC_Unload",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCoalingTowerGather",
    "fullName": "OnCoalingTowerGather",
    "category": "Resource",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void EmptyTenPercent()\r\n{\r\n\tif (!IsPowered())\r\n\t{\r\n\t\tEndEmptyProcess(CoalingTower.ActionAttemptStatus.GenericError);\r\n\t\treturn;\r\n\t}\r\n\tif (!HasUnloadableLinedUp)\r\n\t{\r\n\t\tEndEmptyProcess(CoalingTower.ActionAttemptStatus.NoTrainCar);\r\n\t\treturn;\r\n\t}\r\n\tTrainCarUnloadable activeUnloadable = GetActiveUnloadable();\r\n\tif (tcUnloadingNow == null || activeUnloadable != tcUnloadingNow)\r\n\t{\r\n\t\tEndEmptyProcess(CoalingTower.ActionAttemptStatus.NoTrainCar);\r\n\t\treturn;\r\n\t}\r\n\tStorageContainer storageContainer = tcUnloadingNow.GetStorageContainer();\r\n\tif (storageContainer.inventory == null || !TrainWagonLootData.instance.TryGetLootFromIndex(LootTypeIndex, out var lootOption))\r\n\t{\r\n\t\tEndEmptyProcess(CoalingTower.ActionAttemptStatus.NoTrainCar);\r\n\t\treturn;\r\n\t}\r\n\tbool flag = tcUnloadingNow.wagonType != TrainCarUnloadable.WagonType.Fuel;\r\n\tItemContainer itemContainer = null;\r\n\tPercentFullStorageContainer percentFullStorageContainer = (flag ? GetOreStorage() : GetFuelStorage());\r\n\tif (percentFullStorageContainer != null)\r\n\t{\r\n\t\titemContainer = percentFullStorageContainer.inventory;\r\n\t}\r\n\tif (itemContainer == null)\r\n\t{\r\n\t\tEndEmptyProcess(CoalingTower.ActionAttemptStatus.GenericError);\r\n\t\treturn;\r\n\t}\r\n\tItemContainer inventory = storageContainer.inventory;\r\n\tItemContainer newcontainer = itemContainer;\r\n\tint iAmount = UnityEngine.Mathf.RoundToInt((float)lootOption.maxLootAmount / 10f);\r\n\tSystem.Collections.Generic.List<Item> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Item>>();\r\n\tint num = inventory.Take(obj, lootOption.lootItem.itemid, iAmount);\r\n\tbool flag2 = true;\r\n\tif (num > 0)\r\n\t{\r\n\t\tforeach (Item item in obj)\r\n\t\t{\r\n\t\t\tif (tcUnloadingNow.wagonType == TrainCarUnloadable.WagonType.Lootboxes)\r\n\t\t\t{\r\n\t\t\t\titem.Remove();\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tbool flag3 = item.MoveToContainer(newcontainer);\r\n\t\t\tif (!flag2 || flag3)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\titem.MoveToContainer(inventory);\r\n\t\t\tflag2 = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.Free(ref obj, freeElements: false);\r\n\tfloat orePercent = tcUnloadingNow.GetOrePercent();\r\n\tif (orePercent == 0f)\r\n\t{\r\n\t\tEndEmptyProcess(CoalingTower.ActionAttemptStatus.NoError);\r\n\t}\r\n\telse if (!flag2)\r\n\t{\r\n\t\tEndEmptyProcess(CoalingTower.ActionAttemptStatus.OutputIsFull);\r\n\t}\r\n\telse if (flag)\r\n\t{\r\n\t\ttcUnloadingNow.SetVisualOreLevel(orePercent);\r\n\t}\r\n}\r\n",
    "targetName": "CoalingTower",
    "methodName": "EmptyTenPercent",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnQuarryToggle",
    "fullName": "OnQuarryToggle [on]",
    "category": "Resource",
    "parameters": [
      {
        "name": "local0",
        "type": "MiningQuarry, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void StartEngine(BaseEntity.RPCMessage msg)\r\n{\r\n\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\r\n\tif ((bool)miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(isOn: true);\r\n\t}\r\n}\r\n",
    "targetName": "EngineSwitch",
    "methodName": "StartEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnQuarryToggle",
    "fullName": "OnQuarryToggle [off]",
    "category": "Resource",
    "parameters": [
      {
        "name": "local0",
        "type": "MiningQuarry, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void StopEngine(BaseEntity.RPCMessage msg)\r\n{\r\n\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\r\n\tif ((bool)miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(isOn: false);\r\n\t}\r\n}\r\n",
    "targetName": "EngineSwitch",
    "methodName": "StopEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnQuarryToggled",
    "fullName": "OnQuarryToggled [off]",
    "category": "Resource",
    "parameters": [
      {
        "name": "local0",
        "type": "MiningQuarry, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void StopEngine(BaseEntity.RPCMessage msg)\r\n{\r\n\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\r\n\tif ((bool)miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(isOn: false);\r\n\t}\r\n}\r\n",
    "targetName": "EngineSwitch",
    "methodName": "StopEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnQuarryToggled",
    "fullName": "OnQuarryToggled [on]",
    "category": "Resource",
    "parameters": [
      {
        "name": "local0",
        "type": "MiningQuarry, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void StartEngine(BaseEntity.RPCMessage msg)\r\n{\r\n\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\r\n\tif ((bool)miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(isOn: true);\r\n\t}\r\n}\r\n",
    "targetName": "EngineSwitch",
    "methodName": "StartEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnQuarryToggled",
    "fullName": "OnQuarryToggled [off] [patch]",
    "category": "Resource",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void StopEngine(BaseEntity.RPCMessage msg)\r\n{\r\n\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\r\n\tif ((bool)miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(isOn: false);\r\n\t}\r\n}\r\n",
    "targetName": "EngineSwitch",
    "methodName": "StopEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnQuarryToggled",
    "fullName": "OnQuarryToggled [on] [patch]",
    "category": "Resource",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void StartEngine(BaseEntity.RPCMessage msg)\r\n{\r\n\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\r\n\tif ((bool)miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(isOn: true);\r\n\t}\r\n}\r\n",
    "targetName": "EngineSwitch",
    "methodName": "StartEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRandomItemAward",
    "fullName": "OnRandomItemAward",
    "category": "Resource",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool TryAward(RandomItemDispenser.RandomItemChance itemChance, BasePlayer forPlayer, UnityEngine.Vector3 distributorPosition)\r\n{\r\n\tfloat num = UnityEngine.Random.Range(0f, 1f);\r\n\tif (itemChance.Chance >= num)\r\n\t{\r\n\t\tItem item = ItemManager.Create(itemChance.Item, itemChance.Amount, 0uL);\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\titem.SetItemOwnership(forPlayer, ItemOwnershipPhrases.GatheredPhrase);\r\n\t\t\tif ((bool)forPlayer)\r\n\t\t\t{\r\n\t\t\t\tforPlayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\titem.Drop(distributorPosition + UnityEngine.Vector3.up * 0.5f, UnityEngine.Vector3.up);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "RandomItemDispenser",
    "methodName": "TryAward",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnXmasLootDistribute",
    "fullName": "OnXmasLootDistribute",
    "category": "Seasonal",
    "parameters": [
      {
        "name": "xMasRefill",
        "type": "XMasRefill, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void ServerInit()\r\n{\r\n\tbase.ServerInit();\r\n\tif (!ConVar.XMas.enabled)\r\n\t{\r\n\t\tInvoke(RemoveMe, 0.1f);\r\n\t\treturn;\r\n\t}\r\n\tgoodKids = ((BasePlayer.activePlayerList != null) ? new System.Collections.Generic.List<BasePlayer>(BasePlayer.activePlayerList) : new System.Collections.Generic.List<BasePlayer>());\r\n\tstockings = ((Stocking.stockings != null) ? new System.Collections.Generic.List<Stocking>(Stocking.stockings.Values) : new System.Collections.Generic.List<Stocking>());\r\n\tInvoke(RemoveMe, 60f);\r\n\tInvokeRepeating(DistributeLoot, 3f, 0.02f);\r\n\tInvoke(SendBells, 0.5f);\r\n}\r\n",
    "targetName": "XMasRefill",
    "methodName": "ServerInit",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnXmasGiftsDistribute",
    "fullName": "OnXmasGiftsDistribute",
    "category": "Seasonal",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool DistributeGiftsForPlayer(BasePlayer player)\r\n{\r\n\tint num = GiftsPerPlayer();\r\n\tint num2 = GiftSpawnAttempts();\r\n\tfor (int i = 0; i < num2; i++)\r\n\t{\r\n\t\tif (num <= 0)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tUnityEngine.Vector2 vector = UnityEngine.Random.insideUnitCircle * GiftRadius();\r\n\t\tUnityEngine.Vector3 pos = player.transform.position + new UnityEngine.Vector3(vector.x, 10f, vector.y);\r\n\t\tUnityEngine.Quaternion rot = UnityEngine.Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\r\n\t\tif (DropToGround(ref pos))\r\n\t\t{\r\n\t\t\tstring resourcePath = giftPrefabs[UnityEngine.Random.Range(0, giftPrefabs.Length)].resourcePath;\r\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);\r\n\t\t\tif ((bool)baseEntity)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity.Spawn();\r\n\t\t\t\tnum--;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "XMasRefill",
    "methodName": "DistributeGiftsForPlayer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnXmasStockingFill",
    "fullName": "OnXmasStockingFill",
    "category": "Seasonal",
    "parameters": [
      {
        "name": "stocking",
        "type": "Stocking, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void SpawnLoot()\r\n{\r\n\tif (base.inventory == null)\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! \" + base.name);\r\n\t}\r\n\telse if (IsEmpty())\r\n\t{\r\n\t\tbase.SpawnLoot();\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\tHurt(MaxHealth() * 0.1f, Rust.DamageType.Generic, null, useProtection: false);\r\n\t}\r\n}\r\n",
    "targetName": "Stocking",
    "methodName": "SpawnLoot",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnAdventGiftAward",
    "fullName": "OnAdventGiftAward",
    "category": "Seasonal",
    "parameters": [
      {
        "name": "adventCalendar",
        "type": "AdventCalendar, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void AwardGift(BasePlayer player)\r\n{\r\n\tSystem.DateTime now = System.DateTime.Now;\r\n\tint num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;\r\n\tif (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) != startMonth || num < 0 || num >= days.Length)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!playerRewardHistory.ContainsKey(player.userID))\r\n\t{\r\n\t\tplayerRewardHistory.Add(player.userID, new System.Collections.Generic.List<int>());\r\n\t}\r\n\tplayerRewardHistory[player.userID].Add(num);\r\n\tEffect.server.Run(giftEffect.resourcePath, player.transform.position);\r\n\tif (num >= 0 && num < crosses.Length)\r\n\t{\r\n\t\tEffect.server.Run(boxCloseEffect.resourcePath, base.transform.position + UnityEngine.Vector3.up * 1.5f);\r\n\t}\r\n\tAdventCalendar.DayReward dayReward = days[num];\r\n\tItemAmount[] rewards = dayReward.rewards;\r\n\tif (ConVar.Server.Era != 0 && dayReward.alternativeRewards != null)\r\n\t{\r\n\t\tAdventCalendar.AlternativeReward[] alternativeRewards = dayReward.alternativeRewards;\r\n\t\tforeach (AdventCalendar.AlternativeReward alternativeReward in alternativeRewards)\r\n\t\t{\r\n\t\t\tif (alternativeReward.era == ConVar.Server.Era)\r\n\t\t\t{\r\n\t\t\t\trewards = alternativeReward.rewards;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tforeach (ItemAmount itemAmount in rewards)\r\n\t{\r\n\t\tif (itemAmount.itemDef.IsAllowedInEra(Rust.EraRestriction.Loot))\r\n\t\t{\r\n\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, UnityEngine.Mathf.CeilToInt(itemAmount.amount), 0uL).SetItemOwnership(player, ItemOwnershipPhrases.AdventCalendar), BaseEntity.GiveItemReason.PickedUp);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "AdventCalendar",
    "methodName": "AwardGift",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnAdventGiftAwarded",
    "fullName": "OnAdventGiftAwarded",
    "category": "Seasonal",
    "parameters": [
      {
        "name": "adventCalendar",
        "type": "AdventCalendar, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void AwardGift(BasePlayer player)\r\n{\r\n\tSystem.DateTime now = System.DateTime.Now;\r\n\tint num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;\r\n\tif (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) != startMonth || num < 0 || num >= days.Length)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!playerRewardHistory.ContainsKey(player.userID))\r\n\t{\r\n\t\tplayerRewardHistory.Add(player.userID, new System.Collections.Generic.List<int>());\r\n\t}\r\n\tplayerRewardHistory[player.userID].Add(num);\r\n\tEffect.server.Run(giftEffect.resourcePath, player.transform.position);\r\n\tif (num >= 0 && num < crosses.Length)\r\n\t{\r\n\t\tEffect.server.Run(boxCloseEffect.resourcePath, base.transform.position + UnityEngine.Vector3.up * 1.5f);\r\n\t}\r\n\tAdventCalendar.DayReward dayReward = days[num];\r\n\tItemAmount[] rewards = dayReward.rewards;\r\n\tif (ConVar.Server.Era != 0 && dayReward.alternativeRewards != null)\r\n\t{\r\n\t\tAdventCalendar.AlternativeReward[] alternativeRewards = dayReward.alternativeRewards;\r\n\t\tforeach (AdventCalendar.AlternativeReward alternativeReward in alternativeRewards)\r\n\t\t{\r\n\t\t\tif (alternativeReward.era == ConVar.Server.Era)\r\n\t\t\t{\r\n\t\t\t\trewards = alternativeReward.rewards;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tforeach (ItemAmount itemAmount in rewards)\r\n\t{\r\n\t\tif (itemAmount.itemDef.IsAllowedInEra(Rust.EraRestriction.Loot))\r\n\t\t{\r\n\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, UnityEngine.Mathf.CeilToInt(itemAmount.amount), 0uL).SetItemOwnership(player, ItemOwnershipPhrases.AdventCalendar), BaseEntity.GiveItemReason.PickedUp);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "AdventCalendar",
    "methodName": "AwardGift",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanBeAwardedAdventGift",
    "fullName": "CanBeAwardedAdventGift",
    "category": "Seasonal",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool WasAwardedTodaysGift(BasePlayer player)\r\n{\r\n\tif (!playerRewardHistory.ContainsKey(player.userID))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tSystem.DateTime now = System.DateTime.Now;\r\n\tif (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) != startMonth)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tint num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;\r\n\tif (num < 0 || num >= days.Length)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (playerRewardHistory[player.userID].Contains(num))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "AdventCalendar",
    "methodName": "WasAwardedTodaysGift",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEventCollectablePickup",
    "fullName": "OnEventCollectablePickup",
    "category": "Seasonal",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "collectableEasterEgg",
        "type": "CollectableEasterEgg, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_PickUp(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = UnityEngine.Time.realtimeSinceStartup - lastPickupStartTime;\r\n\tif (!(msg.player.GetHeldEntity() as EasterBasket) && (num > 2f || num < 0.8f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif ((bool)EggHuntEvent.serverEvent)\r\n\t{\r\n\t\tif (!EggHuntEvent.serverEvent.IsEventActive())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tEggHuntEvent.serverEvent.OnEggCollected(msg.player, this);\r\n\t\tint iAmount = 1;\r\n\t\tmsg.player.GiveItem(ItemManager.Create(itemToGive, iAmount, 0uL));\r\n\t}\r\n\tEffect.server.Run(pickupEffect.resourcePath, base.transform.position + UnityEngine.Vector3.up * 0.3f, UnityEngine.Vector3.up);\r\n\tKill();\r\n}\r\n",
    "targetName": "CollectableEasterEgg",
    "methodName": "RPC_PickUp",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnHuntEventStart",
    "fullName": "OnHuntEventStart",
    "category": "Seasonal",
    "parameters": [
      {
        "name": "eggHuntEvent",
        "type": "EggHuntEvent, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartEvent()\r\n{\r\n\tif (initialSpawnIndex <= BasePlayer.activePlayerList.Count)\r\n\t{\r\n\t\teggSpawningFrameBudget = float.PositiveInfinity;\r\n\t}\r\n\tEnableEggs();\r\n}\r\n",
    "targetName": "EggHuntEvent",
    "methodName": "StartEvent",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnHuntEventEnd",
    "fullName": "OnHuntEventEnd",
    "category": "Seasonal",
    "parameters": [
      {
        "name": "eggHuntEvent",
        "type": "EggHuntEvent, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Update()\r\n{\r\n\ttimeAlive += UnityEngine.Time.deltaTime;\r\n\tif (base.isServer && !base.IsDestroyed)\r\n\t{\r\n\t\tif (timeAlive - warmupTime > durationSeconds - warnTime)\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved1, b: true);\r\n\t\t}\r\n\t\tif (timeAlive - warmupTime > durationSeconds && !IsInvoking(Cooldown))\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved2, b: true);\r\n\t\t\tCleanupEggs();\r\n\t\t\tPrintWinnersAndAward();\r\n\t\t\tInvoke(Cooldown, 10f);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "EggHuntEvent",
    "methodName": "Update",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "InitLogging",
    "fullName": "InitLogging",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartupShared()\r\n{\r\n\tItemManager.Initialize();\r\n}\r\n",
    "targetName": "Bootstrap",
    "methodName": "StartupShared",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTick",
    "fullName": "OnTick",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoTick()\r\n{\r\n\tFacepunch.RCon.Update();\r\n\tCompanionServer.Server.Update();\r\n\tNexusServer.Update();\r\n\tfor (int i = 0; i < Network.Net.sv.connections.Count; i++)\r\n\t{\r\n\t\tNetwork.Connection connection = Network.Net.sv.connections[i];\r\n\t\tif (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))\r\n\t\t{\r\n\t\t\tNetwork.Net.sv.Kick(connection, \"Authentication Timed Out\");\r\n\t\t}\r\n\t}\r\n\tfloat num = UnityEngine.Mathf.Max(ConVar.Server.premiumRecheckInterval, 60f);\r\n\tif (ConVar.Server.premium && (double)sinceLastPremiumRecheck > (double)num)\r\n\t{\r\n\t\tsinceLastPremiumRecheck = 0.0;\r\n\t\tRecheckPremiumStatus();\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "DoTick",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "IOnServerShutdown",
    "fullName": "IOnServerShutdown",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Shutdown()\r\n{\r\n\tBasePlayer[] array = System.Linq.Enumerable.ToArray(BasePlayer.activePlayerList);\r\n\tfor (int i = 0; i < array.Length; i++)\r\n\t{\r\n\t\tarray[i].Kick(\"Server Shutting Down\");\r\n\t}\r\n\tConsoleSystem.Run(ConsoleSystem.Option.Server, \"server.save\");\r\n\tConsoleSystem.Run(ConsoleSystem.Option.Server, \"server.writecfg\");\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "Shutdown",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnServerInitialize",
    "fullName": "OnServerInitialize",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool Initialize(bool loadSave = true, string saveFile = \"\", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)\r\n{\r\n\tpersistance = new UserPersistance(ConVar.Server.rootFolder);\r\n\tplayerStateManager = new PlayerStateManager(persistance);\r\n\tTutorialIsland.GenerateIslandSpawnPoints(loadingSave: true);\r\n\tif ((bool)SingletonComponent<SpawnHandler>.Instance)\r\n\t{\r\n\t\tusing (TimeWarning.New(\"SpawnHandler.UpdateDistributions\"))\r\n\t\t{\r\n\t\t\tSingletonComponent<SpawnHandler>.Instance.UpdateDistributions();\r\n\t\t}\r\n\t}\r\n\tif (loadSave)\r\n\t{\r\n\t\tWorld.LoadedFromSave = true;\r\n\t\tWorld.LoadedFromSave = (skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tSaveRestore.SaveCreatedTime = System.DateTime.UtcNow;\r\n\t\tWorld.LoadedFromSave = false;\r\n\t}\r\n\tif (!World.LoadedFromSave)\r\n\t{\r\n\t\tSaveRestore.SpawnMapEntities(SaveRestore.FindMapEntities());\r\n\t}\r\n\tSaveRestore.InitializeWipeId();\r\n\tif ((bool)SingletonComponent<SpawnHandler>.Instance)\r\n\t{\r\n\t\tif (!skipInitialSpawn)\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\"SpawnHandler.InitialSpawn\", 200))\r\n\t\t\t{\r\n\t\t\t\tSingletonComponent<SpawnHandler>.Instance.InitialSpawn();\r\n\t\t\t}\r\n\t\t}\r\n\t\tusing (TimeWarning.New(\"SpawnHandler.StartSpawnTick\", 200))\r\n\t\t{\r\n\t\t\tSingletonComponent<SpawnHandler>.Instance.StartSpawnTick();\r\n\t\t}\r\n\t}\r\n\tCreateImportantEntities();\r\n\tauth = GetComponent<ConnectionAuth>();\r\n\tFacepunch.Rust.Analytics.Azure.Initialize();\r\n\treturn World.LoadedFromSave;\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "Initialize",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "IOnServerInitialized",
    "fullName": "IOnServerInitialized",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OpenConnection(bool useSteamServer = true)\r\n{\r\n\tif (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)\r\n\t{\r\n\t\tConVar.Server.queryport = System.Math.Max(ConVar.Server.port, Facepunch.RCon.Port) + 1;\r\n\t}\r\n\tNetwork.Net.sv.ip = ConVar.Server.ip;\r\n\tNetwork.Net.sv.port = ConVar.Server.port;\r\n\tif (useSteamServer)\r\n\t{\r\n\t\tStartSteamServer();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tPlatformService.Instance.Initialize(RustPlatformHooks.Instance);\r\n\t}\r\n\tif (!Network.Net.sv.Start(this))\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Couldn't Start Server.\");\r\n\t\tCloseConnection();\r\n\t\treturn;\r\n\t}\r\n\tNetwork.Net.sv.cryptography = new NetworkCryptographyServer();\r\n\tEACServer.DoStartup();\r\n\tInvokeRepeating(\"DoTick\", 1f, 1f / (float)ConVar.Server.tickrate);\r\n\tInvokeRepeating(\"DoHeartbeat\", 1f, 1f);\r\n\trunFrameUpdate = true;\r\n\tConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;\r\n\tif (ConVar.Server.autoUploadMap)\r\n\t{\r\n\t\tMapUploader.UploadMap();\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "OpenConnection",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnServerRestartInterrupt",
    "fullName": "OnServerRestartInterrupt",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void RestartServer(string strNotice, int iSeconds)\r\n{\r\n\tif (!(SingletonComponent<ServerMgr>.Instance == null))\r\n\t{\r\n\t\tif (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)\r\n\t\t{\r\n\t\t\tConsoleNetwork.BroadcastToAllClients(\"chat.add\", 2, 0, \"<color=#fff>SERVER</color> Restart interrupted!\");\r\n\t\t\tSingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);\r\n\t\t\tSingletonComponent<ServerMgr>.Instance.restartCoroutine = null;\r\n\t\t}\r\n\t\tSingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);\r\n\t\tSingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);\r\n\t\tSingletonComponent<ServerMgr>.Instance.UpdateServerInformation();\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "RestartServer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnServerRestart",
    "fullName": "OnServerRestart",
    "category": "Server",
    "parameters": [
      {
        "name": "strNotice",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "iSeconds",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void RestartServer(string strNotice, int iSeconds)\r\n{\r\n\tif (!(SingletonComponent<ServerMgr>.Instance == null))\r\n\t{\r\n\t\tif (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)\r\n\t\t{\r\n\t\t\tConsoleNetwork.BroadcastToAllClients(\"chat.add\", 2, 0, \"<color=#fff>SERVER</color> Restart interrupted!\");\r\n\t\t\tSingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);\r\n\t\t\tSingletonComponent<ServerMgr>.Instance.restartCoroutine = null;\r\n\t\t}\r\n\t\tSingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);\r\n\t\tSingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);\r\n\t\tSingletonComponent<ServerMgr>.Instance.UpdateServerInformation();\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "RestartServer",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnServerInformationUpdated",
    "fullName": "OnServerInformationUpdated",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateServerInformation()\r\n{\r\n\tif (!Steamworks.SteamServer.IsValid)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"UpdateServerInformation\"))\r\n\t{\r\n\t\tSteamworks.SteamServer.ServerName = ConVar.Server.hostname;\r\n\t\tSteamworks.SteamServer.MaxPlayers = ConVar.Server.maxplayers;\r\n\t\tSteamworks.SteamServer.Passworded = false;\r\n\t\tSteamworks.SteamServer.MapName = World.GetServerBrowserMapName();\r\n\t\tstring value = \"stok\";\r\n\t\tif (Restarting)\r\n\t\t{\r\n\t\t\tvalue = \"strst\";\r\n\t\t}\r\n\t\tstring text = $\"born{Facepunch.Math.Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}\";\r\n\t\tstring text2 = $\"gm{GamemodeName()}\";\r\n\t\tstring text3 = (ConVar.Server.pve ? \",pve\" : string.Empty);\r\n\t\tstring text4 = ConVar.Server.tags?.Trim(',') ?? \"\";\r\n\t\tstring text5 = ((!string.IsNullOrWhiteSpace(text4)) ? (\",\" + text4) : \"\");\r\n\t\tstring text6 = Facepunch.BuildInfo.Current?.Scm?.ChangeId ?? \"0\";\r\n\t\tstring text7 = (ConVar.Server.premium ? \",premium\" : \"\");\r\n\t\tstring text8 = Facepunch.Ping.PingEstimater.GetCachedClosestRegion().Code;\r\n\t\tif (!string.IsNullOrEmpty(ConVar.Server.ping_region_code_override))\r\n\t\t{\r\n\t\t\ttext8 = ConVar.Server.ping_region_code_override;\r\n\t\t}\r\n\t\tSteamworks.SteamServer.GameTags = ServerTagCompressor.CompressTags($\"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},$r{text8},v{2583}{text3}{text5},{text},{text2},cs{text6}{text7}\");\r\n\t\tif (ConVar.Server.description != null && ConVar.Server.description.Length > 100)\r\n\t\t{\r\n\t\t\tstring[] array = System.Linq.Enumerable.ToArray(UnityEngine.StringEx.SplitToChunks(ConVar.Server.description, 100));\r\n\t\t\tfor (int i = 0; i < 16; i++)\r\n\t\t\t{\r\n\t\t\t\tif (i < array.Length)\r\n\t\t\t\t{\r\n\t\t\t\t\tSteamworks.SteamServer.SetKey($\"description_{i:00}\", array[i]);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tSteamworks.SteamServer.SetKey($\"description_{i:00}\", string.Empty);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSteamworks.SteamServer.SetKey(\"description_0\", ConVar.Server.description);\r\n\t\t\tfor (int j = 1; j < 16; j++)\r\n\t\t\t{\r\n\t\t\t\tSteamworks.SteamServer.SetKey($\"description_{j:00}\", string.Empty);\r\n\t\t\t}\r\n\t\t}\r\n\t\tSteamworks.SteamServer.SetKey(\"hash\", AssemblyHash);\r\n\t\tSteamworks.SteamServer.SetKey(\"status\", value);\r\n\t\tstring value2 = World.Seed.ToString();\r\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\r\n\t\tif (activeGameMode != null && !activeGameMode.ingameMap)\r\n\t\t{\r\n\t\t\tvalue2 = \"0\";\r\n\t\t}\r\n\t\tSteamworks.SteamServer.SetKey(\"world.seed\", value2);\r\n\t\tSteamworks.SteamServer.SetKey(\"world.size\", World.Size.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"pve\", ConVar.Server.pve.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"headerimage\", ConVar.Server.headerimage);\r\n\t\tSteamworks.SteamServer.SetKey(\"logoimage\", ConVar.Server.logoimage);\r\n\t\tSteamworks.SteamServer.SetKey(\"url\", ConVar.Server.url);\r\n\t\tif (!string.IsNullOrWhiteSpace(ConVar.Server.favoritesEndpoint))\r\n\t\t{\r\n\t\t\tSteamworks.SteamServer.SetKey(\"favendpoint\", ConVar.Server.favoritesEndpoint);\r\n\t\t}\r\n\t\tSteamworks.SteamServer.SetKey(\"gmn\", GamemodeName());\r\n\t\tSteamworks.SteamServer.SetKey(\"gmt\", GamemodeTitle());\r\n\t\tSteamworks.SteamServer.SetKey(\"uptime\", ((int)UnityEngine.Time.realtimeSinceStartup).ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"gc_mb\", Performance.report.memoryAllocations.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"gc_cl\", Performance.report.memoryCollections.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"ram_sys\", (Performance.report.memoryUsageSystem / 1000000).ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"fps\", Performance.report.frameRate.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"fps_avg\", Performance.report.frameRateAverage.ToString(\"0.00\"));\r\n\t\tSteamworks.SteamServer.SetKey(\"ent_cnt\", BaseNetworkable.serverEntities.Count.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"build\", Facepunch.BuildInfo.Current.Scm.ChangeId);\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "UpdateServerInformation",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMessagePlayer",
    "fullName": "OnMessagePlayer",
    "category": "Server",
    "parameters": [
      {
        "name": "msg",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ChatMessage(string msg)\r\n{\r\n\tif (base.isServer)\r\n\t{\r\n\t\tSendConsoleCommand(\"chat.add\", 2, 0, msg);\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "ChatMessage",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnServerMessage",
    "fullName": "OnServerMessage",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void Broadcast(string message, string username = \"SERVER\", string color = \"#eee\", ulong userid = 0uL)\r\n{\r\n\tstring text = UnityEngine.StringEx.EscapeRichText(username);\r\n\tConsoleNetwork.BroadcastToAllClients(\"chat.add\", 2, 0, \"<color=\" + color + \">\" + text + \"</color> \" + message);\r\n\tConVar.Chat.ChatEntry ce = default(ConVar.Chat.ChatEntry);\r\n\tce.Channel = ConVar.Chat.ChatChannel.Server;\r\n\tce.Message = message;\r\n\tce.UserId = userid.ToString();\r\n\tce.Username = username;\r\n\tce.Color = color;\r\n\tce.Time = Facepunch.Math.Epoch.Current;\r\n\tRecord(ce);\r\n}\r\n",
    "targetName": "ConVar.Chat",
    "methodName": "Broadcast",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRconConnection",
    "fullName": "OnRconConnection [exp]",
    "category": "Server",
    "parameters": [
      {
        "name": "address",
        "type": "System.Net.IPAddress, System.Net.Primitives, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "Facepunch.RCon+RConListener",
    "methodName": "ProcessConnections",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNewSave",
    "fullName": "OnNewSave",
    "category": "Server",
    "parameters": [
      {
        "name": "strFilename",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "#define UNITY_ASSERTIONS\r\npublic static bool Load(string strFilename = \"\", bool allowOutOfDateSaves = false)\r\n{\r\n\tSaveCreatedTime = System.DateTime.UtcNow;\r\n\ttry\r\n\t{\r\n\t\tif (strFilename == \"\")\r\n\t\t{\r\n\t\t\tstrFilename = World.SaveFolderName + \"/\" + World.SaveFileName;\r\n\t\t}\r\n\t\tif (!System.IO.File.Exists(strFilename))\r\n\t\t{\r\n\t\t\tif (!System.IO.File.Exists(\"TestSaves/\" + strFilename))\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"Couldn't load \" + strFilename + \" - file doesn't exist\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tstrFilename = \"TestSaves/\" + strFilename;\r\n\t\t}\r\n\t\tSystem.Collections.Generic.List<BaseEntity> list = FindMapEntities();\r\n\t\tSystem.Collections.Generic.Dictionary<BaseEntity, ProtoBuf.Entity> dictionary = new System.Collections.Generic.Dictionary<BaseEntity, ProtoBuf.Entity>();\r\n\t\tusing (System.IO.FileStream fileStream = System.IO.File.OpenRead(strFilename))\r\n\t\t{\r\n\t\t\tusing System.IO.BinaryReader binaryReader = new System.IO.BinaryReader(fileStream);\r\n\t\t\tSaveCreatedTime = System.IO.File.GetCreationTime(strFilename);\r\n\t\t\tif (binaryReader.ReadSByte() != 83 || binaryReader.ReadSByte() != 65 || binaryReader.ReadSByte() != 86 || binaryReader.ReadSByte() != 82)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"Invalid save (missing header)\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (binaryReader.PeekChar() == 74)\r\n\t\t\t{\r\n\t\t\t\tbinaryReader.ReadChar();\r\n\t\t\t\tWipeId = Newtonsoft.Json.JsonConvert.DeserializeObject<SaveRestore.SaveExtraData>(binaryReader.ReadString()).WipeId;\r\n\t\t\t}\r\n\t\t\tif (binaryReader.PeekChar() == 68)\r\n\t\t\t{\r\n\t\t\t\tbinaryReader.ReadChar();\r\n\t\t\t\tSaveCreatedTime = Facepunch.Math.Epoch.ToDateTime(binaryReader.ReadInt32());\r\n\t\t\t}\r\n\t\t\tif (binaryReader.ReadUInt32() != 265)\r\n\t\t\t{\r\n\t\t\t\tif (allowOutOfDateSaves)\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\"This save is from an older (possibly incompatible) version!\");\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\"This save is from an older version. It might not load properly.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tClearMapEntities(list);\r\n\t\t\tUnityEngine.Assertions.Assert.IsTrue(BaseEntity.saveList.Count == 0, \"BaseEntity.saveList isn't empty!\");\r\n\t\t\tNetwork.Net.sv.Reset();\r\n\t\t\tRust.Application.isLoadingSave = true;\r\n\t\t\tSystem.Collections.Generic.HashSet<NetworkableId> hashSet = new System.Collections.Generic.HashSet<NetworkableId>();\r\n\t\t\twhile (fileStream.Position < fileStream.Length)\r\n\t\t\t{\r\n\t\t\t\tFacepunch.RCon.Update();\r\n\t\t\t\tuint num = binaryReader.ReadUInt32();\r\n\t\t\t\tlong position = fileStream.Position;\r\n\t\t\t\tProtoBuf.Entity entData = null;\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tentData = ProtoBuf.Entity.DeserializeLength(fileStream, (int)num);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (System.Exception exception)\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\"Skipping entity since it could not be deserialized - stream position: \" + position + \" size: \" + num);\r\n\t\t\t\t\tUnityEngine.Debug.LogException(exception);\r\n\t\t\t\t\tfileStream.Position = position + num;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (entData.basePlayer != null && System.Linq.Enumerable.Any(dictionary, (System.Collections.Generic.KeyValuePair<BaseEntity, ProtoBuf.Entity> x) => x.Value.basePlayer != null && x.Value.basePlayer.userid == entData.basePlayer.userid))\r\n\t\t\t\t{\r\n\t\t\t\t\tstring[] obj = new string[5] { \"Skipping entity \", null, null, null, null };\r\n\t\t\t\t\tNetworkableId uid = entData.baseNetworkable.uid;\r\n\t\t\t\t\tobj[1] = uid.ToString();\r\n\t\t\t\t\tobj[2] = \" - it's a player \";\r\n\t\t\t\t\tobj[3] = entData.basePlayer.userid.ToString();\r\n\t\t\t\t\tobj[4] = \" who is in the save multiple times\";\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(string.Concat(obj));\r\n\t\t\t\t}\r\n\t\t\t\telse if (entData.baseNetworkable.uid.IsValid && hashSet.Contains(entData.baseNetworkable.uid))\r\n\t\t\t\t{\r\n\t\t\t\t\tstring[] obj2 = new string[5] { \"Skipping entity \", null, null, null, null };\r\n\t\t\t\t\tNetworkableId uid = entData.baseNetworkable.uid;\r\n\t\t\t\t\tobj2[1] = uid.ToString();\r\n\t\t\t\t\tobj2[2] = \" \";\r\n\t\t\t\t\tobj2[3] = StringPool.Get(entData.baseNetworkable.prefabID);\r\n\t\t\t\t\tobj2[4] = \" - uid is used multiple times\";\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(string.Concat(obj2));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (entData.baseNetworkable.uid.IsValid)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\thashSet.Add(entData.baseNetworkable.uid);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entData.baseNetworkable.prefabID), entData.baseEntity.pos, UnityEngine.Quaternion.Euler(entData.baseEntity.rot));\r\n\t\t\t\t\tif ((bool)baseEntity)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbaseEntity.InitLoad(entData.baseNetworkable.uid);\r\n\t\t\t\t\t\tbaseEntity.PreServerLoad();\r\n\t\t\t\t\t\tdictionary.Add(baseEntity, entData);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"Spawning \" + list.Count + \" entities from map\");\r\n\t\tforeach (BaseEntity item in list)\r\n\t\t{\r\n\t\t\tif (!(item == null))\r\n\t\t\t{\r\n\t\t\t\titem.SpawnAsMapEntity();\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\tUnityEngine.DebugEx.Log(\"Spawning \" + dictionary.Count + \" entities from save\");\r\n\t\tBaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);\r\n\t\tinfo.fromDisk = true;\r\n\t\tSystem.Diagnostics.Stopwatch stopwatch = System.Diagnostics.Stopwatch.StartNew();\r\n\t\tint num2 = 0;\r\n\t\tforeach (System.Collections.Generic.KeyValuePair<BaseEntity, ProtoBuf.Entity> item2 in dictionary)\r\n\t\t{\r\n\t\t\tBaseEntity key = item2.Key;\r\n\t\t\tif (key == null)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tFacepunch.RCon.Update();\r\n\t\t\tinfo.msg = item2.Value;\r\n\t\t\tkey.Spawn();\r\n\t\t\tkey.Load(info);\r\n\t\t\tif (key.IsValid())\r\n\t\t\t{\r\n\t\t\t\tnum2++;\r\n\t\t\t\tif (stopwatch.Elapsed.TotalMilliseconds > 2000.0)\r\n\t\t\t\t{\r\n\t\t\t\t\tstopwatch.Reset();\r\n\t\t\t\t\tstopwatch.Start();\r\n\t\t\t\t\tUnityEngine.DebugEx.Log(\"\\t\" + num2 + \" / \" + dictionary.Count);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\tUnityEngine.DebugEx.Log(\"Postprocessing \" + list.Count + \" entities from map\");\r\n\t\tforeach (BaseEntity item3 in list)\r\n\t\t{\r\n\t\t\tif (!(item3 == null))\r\n\t\t\t{\r\n\t\t\t\titem3.PostMapEntitySpawn();\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\tUnityEngine.DebugEx.Log(\"Postprocessing \" + list.Count + \" entities from save\");\r\n\t\tforeach (System.Collections.Generic.KeyValuePair<BaseEntity, ProtoBuf.Entity> item4 in dictionary)\r\n\t\t{\r\n\t\t\tBaseEntity key2 = item4.Key;\r\n\t\t\tif (!(key2 == null))\r\n\t\t\t{\r\n\t\t\t\tFacepunch.RCon.Update();\r\n\t\t\t\tif (key2.IsValid())\r\n\t\t\t\t{\r\n\t\t\t\t\tkey2.UpdateNetworkGroup();\r\n\t\t\t\t\tkey2.PostServerLoad();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\tif ((bool)SingletonComponent<SpawnHandler>.Instance)\r\n\t\t{\r\n\t\t\tUnityEngine.DebugEx.Log(\"Enforcing SpawnPopulation Limits\");\r\n\t\t\tSingletonComponent<SpawnHandler>.Instance.EnforceLimits();\r\n\t\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\t}\r\n\t\tInitializeWipeId();\r\n\t\tRust.Application.isLoadingSave = false;\r\n\t\treturn true;\r\n\t}\r\n\tcatch (System.Exception exception2)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Error loading save (\" + strFilename + \")\");\r\n\t\tUnityEngine.Debug.LogException(exception2);\r\n\t\treturn false;\r\n\t}\r\n}\r\n",
    "targetName": "SaveRestore",
    "methodName": "Load",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSaveLoad",
    "fullName": "OnSaveLoad",
    "category": "Server",
    "parameters": [
      {
        "name": "local1",
        "type": "System.Collections.Generic.Dictionary`2[[BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null],[ProtoBuf.Entity, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "#define UNITY_ASSERTIONS\r\npublic static bool Load(string strFilename = \"\", bool allowOutOfDateSaves = false)\r\n{\r\n\tSaveCreatedTime = System.DateTime.UtcNow;\r\n\ttry\r\n\t{\r\n\t\tif (strFilename == \"\")\r\n\t\t{\r\n\t\t\tstrFilename = World.SaveFolderName + \"/\" + World.SaveFileName;\r\n\t\t}\r\n\t\tif (!System.IO.File.Exists(strFilename))\r\n\t\t{\r\n\t\t\tif (!System.IO.File.Exists(\"TestSaves/\" + strFilename))\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"Couldn't load \" + strFilename + \" - file doesn't exist\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tstrFilename = \"TestSaves/\" + strFilename;\r\n\t\t}\r\n\t\tSystem.Collections.Generic.List<BaseEntity> list = FindMapEntities();\r\n\t\tSystem.Collections.Generic.Dictionary<BaseEntity, ProtoBuf.Entity> dictionary = new System.Collections.Generic.Dictionary<BaseEntity, ProtoBuf.Entity>();\r\n\t\tusing (System.IO.FileStream fileStream = System.IO.File.OpenRead(strFilename))\r\n\t\t{\r\n\t\t\tusing System.IO.BinaryReader binaryReader = new System.IO.BinaryReader(fileStream);\r\n\t\t\tSaveCreatedTime = System.IO.File.GetCreationTime(strFilename);\r\n\t\t\tif (binaryReader.ReadSByte() != 83 || binaryReader.ReadSByte() != 65 || binaryReader.ReadSByte() != 86 || binaryReader.ReadSByte() != 82)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"Invalid save (missing header)\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (binaryReader.PeekChar() == 74)\r\n\t\t\t{\r\n\t\t\t\tbinaryReader.ReadChar();\r\n\t\t\t\tWipeId = Newtonsoft.Json.JsonConvert.DeserializeObject<SaveRestore.SaveExtraData>(binaryReader.ReadString()).WipeId;\r\n\t\t\t}\r\n\t\t\tif (binaryReader.PeekChar() == 68)\r\n\t\t\t{\r\n\t\t\t\tbinaryReader.ReadChar();\r\n\t\t\t\tSaveCreatedTime = Facepunch.Math.Epoch.ToDateTime(binaryReader.ReadInt32());\r\n\t\t\t}\r\n\t\t\tif (binaryReader.ReadUInt32() != 265)\r\n\t\t\t{\r\n\t\t\t\tif (allowOutOfDateSaves)\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\"This save is from an older (possibly incompatible) version!\");\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\"This save is from an older version. It might not load properly.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tClearMapEntities(list);\r\n\t\t\tUnityEngine.Assertions.Assert.IsTrue(BaseEntity.saveList.Count == 0, \"BaseEntity.saveList isn't empty!\");\r\n\t\t\tNetwork.Net.sv.Reset();\r\n\t\t\tRust.Application.isLoadingSave = true;\r\n\t\t\tSystem.Collections.Generic.HashSet<NetworkableId> hashSet = new System.Collections.Generic.HashSet<NetworkableId>();\r\n\t\t\twhile (fileStream.Position < fileStream.Length)\r\n\t\t\t{\r\n\t\t\t\tFacepunch.RCon.Update();\r\n\t\t\t\tuint num = binaryReader.ReadUInt32();\r\n\t\t\t\tlong position = fileStream.Position;\r\n\t\t\t\tProtoBuf.Entity entData = null;\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tentData = ProtoBuf.Entity.DeserializeLength(fileStream, (int)num);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (System.Exception exception)\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\"Skipping entity since it could not be deserialized - stream position: \" + position + \" size: \" + num);\r\n\t\t\t\t\tUnityEngine.Debug.LogException(exception);\r\n\t\t\t\t\tfileStream.Position = position + num;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (entData.basePlayer != null && System.Linq.Enumerable.Any(dictionary, (System.Collections.Generic.KeyValuePair<BaseEntity, ProtoBuf.Entity> x) => x.Value.basePlayer != null && x.Value.basePlayer.userid == entData.basePlayer.userid))\r\n\t\t\t\t{\r\n\t\t\t\t\tstring[] obj = new string[5] { \"Skipping entity \", null, null, null, null };\r\n\t\t\t\t\tNetworkableId uid = entData.baseNetworkable.uid;\r\n\t\t\t\t\tobj[1] = uid.ToString();\r\n\t\t\t\t\tobj[2] = \" - it's a player \";\r\n\t\t\t\t\tobj[3] = entData.basePlayer.userid.ToString();\r\n\t\t\t\t\tobj[4] = \" who is in the save multiple times\";\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(string.Concat(obj));\r\n\t\t\t\t}\r\n\t\t\t\telse if (entData.baseNetworkable.uid.IsValid && hashSet.Contains(entData.baseNetworkable.uid))\r\n\t\t\t\t{\r\n\t\t\t\t\tstring[] obj2 = new string[5] { \"Skipping entity \", null, null, null, null };\r\n\t\t\t\t\tNetworkableId uid = entData.baseNetworkable.uid;\r\n\t\t\t\t\tobj2[1] = uid.ToString();\r\n\t\t\t\t\tobj2[2] = \" \";\r\n\t\t\t\t\tobj2[3] = StringPool.Get(entData.baseNetworkable.prefabID);\r\n\t\t\t\t\tobj2[4] = \" - uid is used multiple times\";\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(string.Concat(obj2));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (entData.baseNetworkable.uid.IsValid)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\thashSet.Add(entData.baseNetworkable.uid);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entData.baseNetworkable.prefabID), entData.baseEntity.pos, UnityEngine.Quaternion.Euler(entData.baseEntity.rot));\r\n\t\t\t\t\tif ((bool)baseEntity)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbaseEntity.InitLoad(entData.baseNetworkable.uid);\r\n\t\t\t\t\t\tbaseEntity.PreServerLoad();\r\n\t\t\t\t\t\tdictionary.Add(baseEntity, entData);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"Spawning \" + list.Count + \" entities from map\");\r\n\t\tforeach (BaseEntity item in list)\r\n\t\t{\r\n\t\t\tif (!(item == null))\r\n\t\t\t{\r\n\t\t\t\titem.SpawnAsMapEntity();\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\tUnityEngine.DebugEx.Log(\"Spawning \" + dictionary.Count + \" entities from save\");\r\n\t\tBaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);\r\n\t\tinfo.fromDisk = true;\r\n\t\tSystem.Diagnostics.Stopwatch stopwatch = System.Diagnostics.Stopwatch.StartNew();\r\n\t\tint num2 = 0;\r\n\t\tforeach (System.Collections.Generic.KeyValuePair<BaseEntity, ProtoBuf.Entity> item2 in dictionary)\r\n\t\t{\r\n\t\t\tBaseEntity key = item2.Key;\r\n\t\t\tif (key == null)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tFacepunch.RCon.Update();\r\n\t\t\tinfo.msg = item2.Value;\r\n\t\t\tkey.Spawn();\r\n\t\t\tkey.Load(info);\r\n\t\t\tif (key.IsValid())\r\n\t\t\t{\r\n\t\t\t\tnum2++;\r\n\t\t\t\tif (stopwatch.Elapsed.TotalMilliseconds > 2000.0)\r\n\t\t\t\t{\r\n\t\t\t\t\tstopwatch.Reset();\r\n\t\t\t\t\tstopwatch.Start();\r\n\t\t\t\t\tUnityEngine.DebugEx.Log(\"\\t\" + num2 + \" / \" + dictionary.Count);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\tUnityEngine.DebugEx.Log(\"Postprocessing \" + list.Count + \" entities from map\");\r\n\t\tforeach (BaseEntity item3 in list)\r\n\t\t{\r\n\t\t\tif (!(item3 == null))\r\n\t\t\t{\r\n\t\t\t\titem3.PostMapEntitySpawn();\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\tUnityEngine.DebugEx.Log(\"Postprocessing \" + list.Count + \" entities from save\");\r\n\t\tforeach (System.Collections.Generic.KeyValuePair<BaseEntity, ProtoBuf.Entity> item4 in dictionary)\r\n\t\t{\r\n\t\t\tBaseEntity key2 = item4.Key;\r\n\t\t\tif (!(key2 == null))\r\n\t\t\t{\r\n\t\t\t\tFacepunch.RCon.Update();\r\n\t\t\t\tif (key2.IsValid())\r\n\t\t\t\t{\r\n\t\t\t\t\tkey2.UpdateNetworkGroup();\r\n\t\t\t\t\tkey2.PostServerLoad();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\tif ((bool)SingletonComponent<SpawnHandler>.Instance)\r\n\t\t{\r\n\t\t\tUnityEngine.DebugEx.Log(\"Enforcing SpawnPopulation Limits\");\r\n\t\t\tSingletonComponent<SpawnHandler>.Instance.EnforceLimits();\r\n\t\t\tUnityEngine.DebugEx.Log(\"\\tdone.\");\r\n\t\t}\r\n\t\tInitializeWipeId();\r\n\t\tRust.Application.isLoadingSave = false;\r\n\t\treturn true;\r\n\t}\r\n\tcatch (System.Exception exception2)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Error loading save (\" + strFilename + \")\");\r\n\t\tUnityEngine.Debug.LogException(exception2);\r\n\t\treturn false;\r\n\t}\r\n}\r\n",
    "targetName": "SaveRestore",
    "methodName": "Load",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnServerSave",
    "fullName": "OnServerSave",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public System.Collections.IEnumerator DoAutomatedSave(bool AndWait = false)\r\n{\r\n\tIsSaving = true;\r\n\tstring folder = ConVar.Server.rootFolder;\r\n\tif (!AndWait)\r\n\t{\r\n\t\tyield return UnityEngine.CoroutineEx.waitForEndOfFrame;\r\n\t}\r\n\tif (AndWait)\r\n\t{\r\n\t\tSystem.Collections.IEnumerator enumerator = Save(folder + \"/\" + World.SaveFileName, AndWait);\r\n\t\twhile (enumerator.MoveNext())\r\n\t\t{\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tyield return StartCoroutine(Save(folder + \"/\" + World.SaveFileName, AndWait));\r\n\t}\r\n\tif (!AndWait)\r\n\t{\r\n\t\tyield return UnityEngine.CoroutineEx.waitForEndOfFrame;\r\n\t}\r\n\tUnityEngine.Debug.Log(\"Saving complete\");\r\n\tIsSaving = false;\r\n}\r\n",
    "targetName": "SaveRestore",
    "methodName": "DoAutomatedSave",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnServerUserSet",
    "fullName": "OnServerUserSet",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void Set(ulong uid, ServerUsers.UserGroup group, string username, string notes, long expiry = -1L)\r\n{\r\n\tRemove(uid);\r\n\tServerUsers.User value = new ServerUsers.User\r\n\t{\r\n\t\tsteamid = uid,\r\n\t\tgroup = group,\r\n\t\tusername = username,\r\n\t\tnotes = notes,\r\n\t\texpiry = expiry\r\n\t};\r\n\tusers.Add(uid, value);\r\n}\r\n",
    "targetName": "ServerUsers",
    "methodName": "Set",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnServerUserRemove",
    "fullName": "OnServerUserRemove",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void Remove(ulong uid)\r\n{\r\n\tusers.Remove(uid);\r\n}\r\n",
    "targetName": "ServerUsers",
    "methodName": "Remove",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "IOnRconInitialize",
    "fullName": "IOnRconInitialize",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void Initialize()\r\n{\r\n\tif (Port == 0)\r\n\t{\r\n\t\tPort = ConVar.Server.port;\r\n\t}\r\n\tPassword = Facepunch.CommandLine.GetSwitch(\"-rcon.password\", Facepunch.CommandLine.GetSwitch(\"+rcon.password\", \"\"));\r\n\tif (Password.Length < 8)\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"\\r\\n*******************************************************\\r\\n**                                                   **\\r\\n** RCON password length is very insecure.            **\\r\\n** Support for passwords less than 8 characters may  **\\r\\n** be removed in the future.                         **\\r\\n**                                                   **\\r\\n*******************************************************\\r\\n\");\r\n\t}\r\n\tswitch (Password.ToLower())\r\n\t{\r\n\tcase \"changeme\":\r\n\tcase \"abc123\":\r\n\tcase \"qwerty\":\r\n\tcase \"qwerty123\":\r\n\tcase \"123456\":\r\n\tcase \"000000\":\r\n\tcase \"password123\":\r\n\tcase \"password\":\r\n\tcase \"\":\r\n\t\tUnityEngine.Debug.Log(\"\\r\\n*******************************************************\\r\\n**                                                   **\\r\\n** RCON password is very insecure, RCON is disabled. **\\r\\n**                                                   **\\r\\n*******************************************************\\r\\n\");\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Output.OnMessage += OnMessage;\r\n\tif (Web)\r\n\t{\r\n\t\tlistenerNew = new Facepunch.Rcon.Listener();\r\n\t\tstring serverFolder = ConVar.Server.GetServerFolder(\"cfg\");\r\n\t\tlistenerNew.BansFile = serverFolder + \"/rcon-bans.cfg\";\r\n\t\tif (!string.IsNullOrEmpty(Ip))\r\n\t\t{\r\n\t\t\tlistenerNew.Address = Ip;\r\n\t\t}\r\n\t\tlistenerNew.Password = Password;\r\n\t\tlistenerNew.Port = Port;\r\n\t\tlistenerNew.SslCertificate = Facepunch.CommandLine.GetSwitch(\"-rcon.ssl\", Facepunch.CommandLine.GetSwitch(\"+rcon.ssl\", null));\r\n\t\tlistenerNew.SslCertificatePassword = Facepunch.CommandLine.GetSwitch(\"-rcon.sslpwd\", Facepunch.CommandLine.GetSwitch(\"+rcon.sslpwd\", null));\r\n\t\tlistenerNew.OnMessage = delegate(System.Net.IPAddress ip, int id, string msg)\r\n\t\t{\r\n\t\t\tFacepunch.RCon.Command item = Newtonsoft.Json.JsonConvert.DeserializeObject<Facepunch.RCon.Command>(msg);\r\n\t\t\titem.Ip = ip;\r\n\t\t\titem.ConnectionId = id;\r\n\t\t\tCommands.Enqueue(item);\r\n\t\t};\r\n\t\tlistenerNew.Start();\r\n\t\tUnityEngine.Debug.Log($\"WebSocket RCON Started on {Ip}:{Port}\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlistener = new Facepunch.RCon.RConListener();\r\n\t\tUnityEngine.Debug.Log(\"RCON Started on \" + Port);\r\n\t\tUnityEngine.Debug.Log(\"\\r\\n*********************************************************************\\r\\n**                                                                 **\\r\\n** Source engine style TCP RCON is deprecated and will be removed. **\\r\\n** Please switch to Websocket RCON by setting rcon.web to true     **\\r\\n**                                                                 **\\r\\n*********************************************************************\");\r\n\t}\r\n}\r\n",
    "targetName": "Facepunch.RCon",
    "methodName": "Initialize",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSendCommand",
    "fullName": "OnSendCommand",
    "category": "Server",
    "parameters": [
      {
        "name": "cn",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "strCommand",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "args",
        "type": "System.Object[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void SendClientCommand(Network.Connection cn, string strCommand, params object[] args)\r\n{\r\n\tif (Network.Net.sv.IsConnected())\r\n\t{\r\n\t\tNetwork.NetWrite netWrite = Network.Net.sv.StartWrite();\r\n\t\tnetWrite.PacketID(Network.Message.Type.ConsoleCommand);\r\n\t\tstring val = ConsoleSystem.BuildCommand(strCommand, args);\r\n\t\tnetWrite.String(val);\r\n\t\tnetWrite.Send(new Network.SendInfo(cn));\r\n\t}\r\n}\r\n",
    "targetName": "ConsoleNetwork",
    "methodName": "SendClientCommand",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSendCommand",
    "fullName": "OnSendCommand [list]",
    "category": "Server",
    "parameters": [
      {
        "name": "cn",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "strCommand",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "args",
        "type": "System.Object[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void SendClientCommand(Network.Connection cn, string strCommand, params object[] args)\r\n{\r\n\tif (Network.Net.sv.IsConnected())\r\n\t{\r\n\t\tNetwork.NetWrite netWrite = Network.Net.sv.StartWrite();\r\n\t\tnetWrite.PacketID(Network.Message.Type.ConsoleCommand);\r\n\t\tstring val = ConsoleSystem.BuildCommand(strCommand, args);\r\n\t\tnetWrite.String(val);\r\n\t\tnetWrite.Send(new Network.SendInfo(cn));\r\n\t}\r\n}\r\n",
    "targetName": "ConsoleNetwork",
    "methodName": "SendClientCommand",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBroadcastCommand",
    "fullName": "OnBroadcastCommand",
    "category": "Server",
    "parameters": [
      {
        "name": "strCommand",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "args",
        "type": "System.Object[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void BroadcastToAllClients(string strCommand, params object[] args)\r\n{\r\n\tif (Network.Net.sv.IsConnected())\r\n\t{\r\n\t\tNetwork.NetWrite netWrite = Network.Net.sv.StartWrite();\r\n\t\tnetWrite.PacketID(Network.Message.Type.ConsoleCommand);\r\n\t\tnetWrite.String(ConsoleSystem.BuildCommand(strCommand, args));\r\n\t\tnetWrite.Send(new Network.SendInfo(Network.Net.sv.connections));\r\n\t}\r\n}\r\n",
    "targetName": "ConsoleNetwork",
    "methodName": "BroadcastToAllClients",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "IOnServerCommand",
    "fullName": "IOnServerCommand",
    "category": "Server",
    "parameters": [
      {
        "name": "arg",
        "type": "ConsoleSystem+Arg, Facepunch.Console, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool Internal(ConsoleSystem.Arg arg)\r\n{\r\n\tif (arg.Invalid)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!arg.HasPermission())\r\n\t{\r\n\t\targ.ReplyWith(\"You cannot run this command\");\r\n\t\treturn false;\r\n\t}\r\n\ttry\r\n\t{\r\n\t\tusing (TimeWarning.New(\"ConsoleSystem: \" + arg.cmd.FullName))\r\n\t\t{\r\n\t\t\targ.cmd.Call(arg);\r\n\t\t}\r\n\t}\r\n\tcatch (System.Exception ex)\r\n\t{\r\n\t\targ.ReplyWith(\"Error: \" + arg.cmd.FullName + \" - \" + ex.Message + \" (\" + ex.Source + \")\");\r\n\t\tUnityEngine.Debug.LogException(ex);\r\n\t\treturn false;\r\n\t}\r\n\tif (arg.cmd.Variable && arg.cmd.GetOveride != null && string.IsNullOrWhiteSpace(arg.Reply))\r\n\t{\r\n\t\tstring @string = arg.cmd.String;\r\n\t\tstring text = (arg.cmd.Variable ? arg.cmd.String : \"\");\r\n\t\tif (!arg.Silent)\r\n\t\t{\r\n\t\t\tif (arg.Option.PrintValueOnly)\r\n\t\t\t{\r\n\t\t\t\targ.ReplyWith(@string);\r\n\t\t\t}\r\n\t\t\telse if (text != @string)\r\n\t\t\t{\r\n\t\t\t\targ.ReplyWith($\"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\targ.ReplyWith($\"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "ConsoleSystem",
    "methodName": "Internal",
    "assemblyName": "Facepunch.Console",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "IOnRunCommandLine",
    "fullName": "IOnRunCommandLine",
    "category": "Server",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void UpdateValuesFromCommandLine()\r\n{\r\n\tforeach (System.Collections.Generic.KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())\r\n\t{\r\n\t\tstring text = @switch.Value;\r\n\t\tif (text == \"\")\r\n\t\t{\r\n\t\t\ttext = \"1\";\r\n\t\t}\r\n\t\tstring strCommand = @switch.Key.Substring(1);\r\n\t\tRun(ConsoleSystem.Option.Unrestricted, strCommand, text);\r\n\t}\r\n}\r\n",
    "targetName": "ConsoleSystem",
    "methodName": "UpdateValuesFromCommandLine",
    "assemblyName": "Facepunch.Console",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnShopCompleteTrade",
    "fullName": "OnShopCompleteTrade",
    "category": "Shop",
    "parameters": [
      {
        "name": "shopFront",
        "type": "ShopFront, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CompleteTrade()\r\n{\r\n\tif (vendorPlayer != null && customerPlayer != null && HasFlag(BaseEntity.Flags.Reserved1) && HasFlag(BaseEntity.Flags.Reserved2))\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tswappingItems = true;\r\n\t\t\tfor (int num = vendorInventory.capacity - 1; num >= 0; num--)\r\n\t\t\t{\r\n\t\t\t\tItem slot = vendorInventory.GetSlot(num);\r\n\t\t\t\tItem slot2 = customerInventory.GetSlot(num);\r\n\t\t\t\tif ((bool)customerPlayer && slot != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tcustomerPlayer.GiveItem(slot);\r\n\t\t\t\t}\r\n\t\t\t\tif ((bool)vendorPlayer && slot2 != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvendorPlayer.GiveItem(slot2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tswappingItems = false;\r\n\t\t}\r\n\t\tEffect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new UnityEngine.Vector3(0f, 1f, 0f), UnityEngine.Vector3.zero);\r\n\t}\r\n\tResetTrade();\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "ShopFront",
    "methodName": "CompleteTrade",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnShopAcceptClick",
    "fullName": "OnShopAcceptClick",
    "category": "Shop",
    "parameters": [
      {
        "name": "shopFront",
        "type": "ShopFront, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void AcceptClicked(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (IsTradingPlayer(msg.player) && !(vendorPlayer == null) && !(customerPlayer == null))\r\n\t{\r\n\t\tif (IsPlayerVendor(msg.player))\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved1, b: true);\r\n\t\t\tvendorInventory.SetLocked(isLocked: true);\r\n\t\t}\r\n\t\telse if (IsPlayerCustomer(msg.player))\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved2, b: true);\r\n\t\t\tcustomerInventory.SetLocked(isLocked: true);\r\n\t\t}\r\n\t\tif (HasFlag(BaseEntity.Flags.Reserved1) && HasFlag(BaseEntity.Flags.Reserved2))\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved3, b: true);\r\n\t\t\tInvoke(CompleteTrade, 2f);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ShopFront",
    "methodName": "AcceptClicked",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnShopCancelClick",
    "fullName": "OnShopCancelClick",
    "category": "Shop",
    "parameters": [
      {
        "name": "shopFront",
        "type": "ShopFront, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void CancelClicked(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (IsTradingPlayer(msg.player))\r\n\t{\r\n\t\t_ = (bool)vendorPlayer;\r\n\t\t_ = (bool)customerPlayer;\r\n\t\tResetTrade();\r\n\t}\r\n}\r\n",
    "targetName": "ShopFront",
    "methodName": "CancelClicked",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWallpaperSet",
    "fullName": "OnWallpaperSet",
    "category": "Structure",
    "parameters": [
      {
        "name": "buildingBlock",
        "type": "BuildingBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "id",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "side",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetWallpaper(ulong id, int side = 0)\r\n{\r\n\tif (side == 0)\r\n\t{\r\n\t\tif (HasWallpaper(side) && wallpaperID == id)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twallpaperID = id;\r\n\t\twallpaperHealth = 100f;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (HasWallpaper(side) && wallpaperID2 == id)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twallpaperID2 = id;\r\n\t\twallpaperHealth2 = 100f;\r\n\t}\r\n\tif (base.isServer)\r\n\t{\r\n\t\tSetConditionalModel(currentSkin.DetermineConditionalModelState(this));\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"RefreshSkin\"));\r\n\t}\r\n}\r\n",
    "targetName": "BuildingBlock",
    "methodName": "SetWallpaper",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWallpaperRemove",
    "fullName": "OnWallpaperRemove",
    "category": "Structure",
    "parameters": [
      {
        "name": "buildingBlock",
        "type": "BuildingBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "side",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RemoveWallpaper(int side)\r\n{\r\n\tswitch (side)\r\n\t{\r\n\tcase 0:\r\n\t\twallpaperHealth = -1f;\r\n\t\twallpaperID = 0uL;\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\twallpaperHealth2 = -1f;\r\n\t\twallpaperID2 = 0uL;\r\n\t\tbreak;\r\n\t}\r\n\tif (base.isServer)\r\n\t{\r\n\t\tSetConditionalModel(currentSkin.DetermineConditionalModelState(this));\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"RefreshSkin\"));\r\n\t}\r\n}\r\n",
    "targetName": "BuildingBlock",
    "methodName": "RemoveWallpaper",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnStructureUpgrade",
    "fullName": "OnStructureUpgrade",
    "category": "Structure",
    "parameters": [
      {
        "name": "buildingBlock",
        "type": "BuildingBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "type",
        "type": "BuildingGrade+Enum, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "skin",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void DoUpgradeToGrade(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!msg.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tConstructionGrade constructionGrade = blockDefinition.GetGrade((BuildingGrade.Enum)msg.read.Int32(), msg.read.UInt64());\r\n\tif (constructionGrade == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!CanChangeToGrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))\r\n\t{\r\n\t\tif (!(DeployVolume.LastDeployHit != null))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBaseEntity baseEntity = UnityEngine.GameObjectEx.ToBaseEntity(DeployVolume.LastDeployHit);\r\n\t\tif (baseEntity != null && baseEntity is BasePlayer basePlayer)\r\n\t\t{\r\n\t\t\tulong currentTeam = msg.player.currentTeam;\r\n\t\t\tif (currentTeam != 0L && currentTeam == basePlayer.currentTeam)\r\n\t\t\t{\r\n\t\t\t\tstring playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);\r\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, false, playerNameStreamSafe);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (base.SecondsSinceAttacked < 30f)\r\n\t\t{\r\n\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString(\"N0\"));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!constructionGrade.gradeBase.alwaysUnlock && constructionGrade.gradeBase.skin != 0L && !msg.player.blueprints.steamInventory.HasItem((int)constructionGrade.gradeBase.skin))\r\n\t\t{\r\n\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.SkinNotOwned, false);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tPayForUpgrade(constructionGrade, msg.player);\r\n\t\tif (msg.player != null)\r\n\t\t{\r\n\t\t\tplayerCustomColourToApply = GetShippingContainerBlockColourForPlayer(msg.player);\r\n\t\t}\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"DoUpgradeEffect\"), (int)constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\r\n\t\tBuildingGrade.Enum @enum = grade;\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, constructionGrade.gradeBase.type, playerCustomColourToApply, constructionGrade.gradeBase.skin);\r\n\t\tOnSkinChanged(skinID, constructionGrade.gradeBase.skin);\r\n\t\tChangeGrade(constructionGrade.gradeBase.type, playEffect: true);\r\n\t\tif (msg.player != null && @enum != constructionGrade.gradeBase.type)\r\n\t\t{\r\n\t\t\tmsg.player.ProcessMissionEvent(BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE, new BaseMission.MissionEventPayload\r\n\t\t\t{\r\n\t\t\t\tNetworkIdentifier = net.ID,\r\n\t\t\t\tIntIdentifier = (int)constructionGrade.gradeBase.type\r\n\t\t\t}, 1f);\r\n\t\t}\r\n\t\ttimePlaced = GetNetworkTime();\r\n\t}\r\n}\r\n",
    "targetName": "BuildingBlock",
    "methodName": "DoUpgradeToGrade",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnStructureRotate",
    "fullName": "OnStructureRotate",
    "category": "Structure",
    "parameters": [
      {
        "name": "buildingBlock",
        "type": "BuildingBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void DoRotation(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotateAfterPlacement)\r\n\t{\r\n\t\tbase.transform.localRotation *= UnityEngine.Quaternion.Euler(blockDefinition.rotationAmount);\r\n\t\tRefreshEntityLinks();\r\n\t\tUpdateSurroundingEntities();\r\n\t\tUpdateSkin(force: true);\r\n\t\tRefreshNeighbours(linkToNeighbours: false);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"RefreshSkin\"));\r\n\t\tif (!globalNetworkCooldown)\r\n\t\t{\r\n\t\t\tglobalNetworkCooldown = true;\r\n\t\t\tGlobalNetworkHandler.server.TrySendNetworkUpdate(this);\r\n\t\t\tCancelInvoke(ResetGlobalNetworkCooldown);\r\n\t\t\tInvoke(ResetGlobalNetworkCooldown, 15f);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BuildingBlock",
    "methodName": "DoRotation",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanChangeGrade",
    "fullName": "CanChangeGrade",
    "category": "Structure",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "buildingBlock",
        "type": "BuildingBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "iGrade",
        "type": "BuildingGrade+Enum, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "iSkin",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)\r\n{\r\n\tif (player.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (HasUpgradePrivilege(iGrade, iSkin, player))\r\n\t{\r\n\t\treturn !IsUpgradeBlocked();\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "BuildingBlock",
    "methodName": "CanChangeToGrade",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanAffordUpgrade",
    "fullName": "CanAffordUpgrade",
    "category": "Structure",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "buildingBlock",
        "type": "BuildingBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "iGrade",
        "type": "BuildingGrade+Enum, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "iSkin",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)\r\n{\r\n\tif (player != null && player.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (!ConVar.Decay.CanUpgradeToGrade(iGrade))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tforeach (ItemAmount item in blockDefinition.GetGrade(iGrade, iSkin).CostToBuild(grade))\r\n\t{\r\n\t\tif ((float)player.inventory.GetAmount(item.itemid) < item.amount)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "BuildingBlock",
    "methodName": "CanAffordUpgrade",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPlayerPveDamage",
    "fullName": "OnPlayerPveDamage [BuildingBlock]",
    "category": "Structure",
    "parameters": [
      {
        "name": "initiator",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "buildingBlock",
        "type": "BuildingBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void Hurt(HitInfo info)\r\n{\r\n\tif (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer)\r\n\t{\r\n\t\t(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), Rust.DamageType.Generic);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif ((bool)info.Initiator && info.Initiator is BasePlayer { IsInTutorial: not false })\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (HasWallpaper())\r\n\t\t{\r\n\t\t\tRust.DamageType majorityDamageType = info.damageTypes.GetMajorityDamageType();\r\n\t\t\tbool flag = info.damageTypes.Contains(Rust.DamageType.Explosion);\r\n\t\t\tRust.DamageTypeList damageTypeList = info.damageTypes.Clone();\r\n\t\t\tif (wallpaperProtection != null)\r\n\t\t\t{\r\n\t\t\t\twallpaperProtection.Scale(damageTypeList);\r\n\t\t\t}\r\n\t\t\tfloat totalDamage = damageTypeList.Total();\r\n\t\t\tif (majorityDamageType == Rust.DamageType.Decay || flag || majorityDamageType == Rust.DamageType.Heat)\r\n\t\t\t{\r\n\t\t\t\tDamageWallpaper(totalDamage);\r\n\t\t\t\tDamageWallpaper(totalDamage, 1);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbool flag2 = false;\r\n\t\t\t\tfor (int i = 0; i < propDirection.Length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (propDirection[i].IsWeakspot(base.transform, info))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tflag2 = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tDamageWallpaper(totalDamage, (!flag2) ? 1 : 0);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbase.Hurt(info);\r\n\t}\r\n}\r\n",
    "targetName": "BuildingBlock",
    "methodName": "Hurt",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnStructureUpgraded",
    "fullName": "OnStructureUpgraded",
    "category": "Structure",
    "parameters": [
      {
        "name": "buildingBlock",
        "type": "BuildingBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "type",
        "type": "BuildingGrade+Enum, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "skin",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void DoUpgradeToGrade(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!msg.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tConstructionGrade constructionGrade = blockDefinition.GetGrade((BuildingGrade.Enum)msg.read.Int32(), msg.read.UInt64());\r\n\tif (constructionGrade == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!CanChangeToGrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))\r\n\t{\r\n\t\tif (!(DeployVolume.LastDeployHit != null))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBaseEntity baseEntity = UnityEngine.GameObjectEx.ToBaseEntity(DeployVolume.LastDeployHit);\r\n\t\tif (baseEntity != null && baseEntity is BasePlayer basePlayer)\r\n\t\t{\r\n\t\t\tulong currentTeam = msg.player.currentTeam;\r\n\t\t\tif (currentTeam != 0L && currentTeam == basePlayer.currentTeam)\r\n\t\t\t{\r\n\t\t\t\tstring playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);\r\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, false, playerNameStreamSafe);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (base.SecondsSinceAttacked < 30f)\r\n\t\t{\r\n\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString(\"N0\"));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!constructionGrade.gradeBase.alwaysUnlock && constructionGrade.gradeBase.skin != 0L && !msg.player.blueprints.steamInventory.HasItem((int)constructionGrade.gradeBase.skin))\r\n\t\t{\r\n\t\t\tmsg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.SkinNotOwned, false);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tPayForUpgrade(constructionGrade, msg.player);\r\n\t\tif (msg.player != null)\r\n\t\t{\r\n\t\t\tplayerCustomColourToApply = GetShippingContainerBlockColourForPlayer(msg.player);\r\n\t\t}\r\n\t\tClientRPC(RpcTarget.NetworkGroup(\"DoUpgradeEffect\"), (int)constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\r\n\t\tBuildingGrade.Enum @enum = grade;\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, constructionGrade.gradeBase.type, playerCustomColourToApply, constructionGrade.gradeBase.skin);\r\n\t\tOnSkinChanged(skinID, constructionGrade.gradeBase.skin);\r\n\t\tChangeGrade(constructionGrade.gradeBase.type, playEffect: true);\r\n\t\tif (msg.player != null && @enum != constructionGrade.gradeBase.type)\r\n\t\t{\r\n\t\t\tmsg.player.ProcessMissionEvent(BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE, new BaseMission.MissionEventPayload\r\n\t\t\t{\r\n\t\t\t\tNetworkIdentifier = net.ID,\r\n\t\t\t\tIntIdentifier = (int)constructionGrade.gradeBase.type\r\n\t\t\t}, 1f);\r\n\t\t}\r\n\t\ttimePlaced = GetNetworkTime();\r\n\t}\r\n}\r\n",
    "targetName": "BuildingBlock",
    "methodName": "DoUpgradeToGrade",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnStructureDemolish",
    "fullName": "OnStructureDemolish [immediate = true]",
    "category": "Structure",
    "parameters": [
      {
        "name": "stabilityEntity",
        "type": "StabilityEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void DoImmediateDemolish(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && msg.player.IsAdmin)\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\r\n\t\tKill(BaseNetworkable.DestroyMode.Gib);\r\n\t}\r\n}\r\n",
    "targetName": "StabilityEntity",
    "methodName": "DoImmediateDemolish",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnStructureDemolish",
    "fullName": "OnStructureDemolish [immediate = false]",
    "category": "Structure",
    "parameters": [
      {
        "name": "stabilityEntity",
        "type": "StabilityEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void DoDemolish(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && CanDemolish(msg.player))\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\r\n\t\tKill(BaseNetworkable.DestroyMode.Gib);\r\n\t}\r\n}\r\n",
    "targetName": "StabilityEntity",
    "methodName": "DoDemolish",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanDemolish",
    "fullName": "CanDemolish",
    "category": "Structure",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "stabilityEntity",
        "type": "StabilityEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanDemolish(BasePlayer player)\r\n{\r\n\tif (CanBeDemolished && IsDemolishable())\r\n\t{\r\n\t\treturn HasDemolishPrivilege(player);\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "StabilityEntity",
    "methodName": "CanDemolish",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnSignLocked",
    "fullName": "OnSignLocked [Signage]",
    "category": "Structure",
    "parameters": [
      {
        "name": "signage",
        "type": "Signage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void LockSign(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && CanUpdateSign(msg.player))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Locked, b: true);\r\n\t\tSendNetworkUpdate();\r\n\t\tbase.OwnerID = msg.player.userID;\r\n\t}\r\n}\r\n",
    "targetName": "Signage",
    "methodName": "LockSign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSignUpdated",
    "fullName": "OnSignUpdated [Signage]",
    "category": "Structure",
    "parameters": [
      {
        "name": "signage",
        "type": "Signage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\n[BaseEntity.RPC_Server.MaxDistance(5f)]\r\npublic void UpdateSign(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player == null || !CanUpdateSign(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tif (num < 0 || num >= paintableSources.Length)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbyte[] array = msg.read.BytesWithSize();\r\n\tif (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning($\"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring\");\r\n\t\treturn;\r\n\t}\r\n\tEnsureInitialized();\r\n\tif (array == null)\r\n\t{\r\n\t\tif (textureIDs[num] != 0)\r\n\t\t{\r\n\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\r\n\t\t}\r\n\t\ttextureIDs[num] = 0u;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!ImageProcessing.IsValidPNG(array, 1024, 1024))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (textureIDs[num] != 0)\r\n\t\t{\r\n\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\r\n\t\t}\r\n\t\ttextureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);\r\n\t}\r\n\tLogEdit(msg.player);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "Signage",
    "methodName": "UpdateSign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDoorOpened",
    "fullName": "OnDoorOpened",
    "category": "Structure",
    "parameters": [
      {
        "name": "door",
        "type": "Door, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_OpenDoor(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!rpc.player.CanInteract(usableWhileCrawling: true) || !canHandOpen || IsOpen() || IsBusy() || IsLocked() || IsInvoking(DelayedDoorOpening))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (rpc.player.IsWounded())\r\n\t{\r\n\t\tif (!woundedOpens.ContainsKey(rpc.player) || !((float)woundedOpens[rpc.player] > 2.5f))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twoundedOpens.Remove(rpc.player);\r\n\t}\r\n\tBaseLock baseLock = GetSlot(BaseEntity.Slot.Lock) as BaseLock;\r\n\tif (baseLock != null)\r\n\t{\r\n\t\tif (!baseLock.OnTryToOpen(rpc.player))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (baseLock.IsLocked() && UnityEngine.Time.realtimeSinceStartup - decayResetTimeLast > 60f)\r\n\t\t{\r\n\t\t\tBuildingBlock buildingBlock = FindLinkedEntity<BuildingBlock>();\r\n\t\t\tif ((bool)buildingBlock)\r\n\t\t\t{\r\n\t\t\t\tDecay.BuildingDecayTouch(buildingBlock);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tDecay.RadialDecayTouch(base.transform.position, 40f, 2097408);\r\n\t\t\t}\r\n\t\t\tdecayResetTimeLast = UnityEngine.Time.realtimeSinceStartup;\r\n\t\t}\r\n\t}\r\n\tif (canReverseOpen)\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Reserved1, base.transform.InverseTransformPoint(rpc.player.transform.position).x > 0f, recursive: false, networkupdate: false);\r\n\t}\r\n\tif (ShouldDelayOpen(rpc.player, out var delay))\r\n\t{\r\n\t\tInvoke(DelayedDoorOpening, delay);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Open, b: true);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n\tif (isSecurityDoor && NavMeshLink != null)\r\n\t{\r\n\t\tSetNavMeshLinkEnabled(wantsOn: true);\r\n\t}\r\n\tif (checkPhysBoxesOnOpen)\r\n\t{\r\n\t\tStartCheckingForBlockages(isOpening: true);\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnBaseInteract(rpc.player, this);\r\n\tOnPlayerOpenedDoor(rpc.player);\r\n}\r\n",
    "targetName": "Door",
    "methodName": "RPC_OpenDoor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDoorClosed",
    "fullName": "OnDoorClosed",
    "category": "Structure",
    "parameters": [
      {
        "name": "door",
        "type": "Door, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_CloseDoor(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!rpc.player.CanInteract(usableWhileCrawling: true) || !canHandOpen || !IsOpen() || IsBusy() || IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (rpc.player.IsWounded())\r\n\t{\r\n\t\tif (!woundedCloses.ContainsKey(rpc.player) || !((float)woundedCloses[rpc.player] > 2.5f))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twoundedCloses.Remove(rpc.player);\r\n\t}\r\n\tBaseLock baseLock = GetSlot(BaseEntity.Slot.Lock) as BaseLock;\r\n\tif (!(baseLock != null) || baseLock.OnTryToClose(rpc.player))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Open, b: false);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tif (isSecurityDoor && NavMeshLink != null)\r\n\t\t{\r\n\t\t\tSetNavMeshLinkEnabled(wantsOn: false);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBaseInteract(rpc.player, this);\r\n\t\tStartCheckingForBlockages(isOpening: false);\r\n\t}\r\n}\r\n",
    "targetName": "Door",
    "methodName": "RPC_CloseDoor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDoorKnocked",
    "fullName": "OnDoorKnocked [Door]",
    "category": "Structure",
    "parameters": [
      {
        "name": "door",
        "type": "Door, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_KnockDoor(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!rpc.player.CanInteract(usableWhileCrawling: true) || !knockEffect.isValid || UnityEngine.Time.realtimeSinceStartup < nextKnockTime)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tnextKnockTime = UnityEngine.Time.realtimeSinceStartup + 0.5f;\r\n\tBaseEntity slot = GetSlot(BaseEntity.Slot.LowerCenterDecoration);\r\n\tif (slot != null)\r\n\t{\r\n\t\tDoorKnocker component = slot.GetComponent<DoorKnocker>();\r\n\t\tif ((bool)component)\r\n\t\t{\r\n\t\t\tcomponent.Knock(rpc.player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tEffect.server.Run(knockEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n}\r\n",
    "targetName": "Door",
    "methodName": "RPC_KnockDoor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnHammerHit",
    "fullName": "OnHammerHit",
    "category": "Structure",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void DoAttackShared(HitInfo info)\r\n{\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tBaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;\r\n\tif (baseCombatEntity != null && ownerPlayer != null && base.isServer)\r\n\t{\r\n\t\tusing (TimeWarning.New(\"DoRepair\", 50))\r\n\t\t{\r\n\t\t\tbaseCombatEntity.DoRepair(ownerPlayer);\r\n\t\t}\r\n\t}\r\n\tinfo.DoDecals = false;\r\n\tif (base.isServer)\r\n\t{\r\n\t\tEffect.server.ImpactEffect(info);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tEffect.client.ImpactEffect(info);\r\n\t}\r\n}\r\n",
    "targetName": "Hammer",
    "methodName": "DoAttackShared",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnStructureRepair",
    "fullName": "OnStructureRepair",
    "category": "Structure",
    "parameters": [
      {
        "name": "baseCombatEntity",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void DoRepair(BasePlayer player)\r\n{\r\n\tif (!repair.enabled)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = GetDamageRepairCooldown();\r\n\tif (player.IsInCreativeMode && ConVar.Creative.freeRepair)\r\n\t{\r\n\t\tnum = 0f;\r\n\t}\r\n\tif (SecondsSinceAttacked <= num)\r\n\t{\r\n\t\tOnRepairFailed(player, RecentlyDamagedError, (num - SecondsSinceAttacked).ToString(\"N0\"));\r\n\t\treturn;\r\n\t}\r\n\tfloat num2 = MaxHealth() - Health();\r\n\tfloat num3 = num2 / MaxHealth();\r\n\tif (num2 <= 0f || num3 <= 0f)\r\n\t{\r\n\t\tOnRepairFailed(player, NotDamagedError);\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<ItemAmount> list = RepairCost(num3);\r\n\tif (list == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num4 = System.Linq.Enumerable.Sum(list, (ItemAmount x) => x.amount);\r\n\tfloat healthBefore = health;\r\n\tif (player.IsInCreativeMode && ConVar.Creative.freeRepair)\r\n\t{\r\n\t\tnum4 = 0f;\r\n\t}\r\n\tif (num4 > 0f)\r\n\t{\r\n\t\tfloat num5 = System.Linq.Enumerable.Min(list, (ItemAmount x) => UnityEngine.Mathf.Clamp01((float)player.inventory.GetAmount(x.itemid) / x.amount));\r\n\t\tif (float.IsNaN(num5))\r\n\t\t{\r\n\t\t\tnum5 = 0f;\r\n\t\t}\r\n\t\tnum5 = UnityEngine.Mathf.Min(num5, 50f / num2);\r\n\t\tif (num5 <= 0f)\r\n\t\t{\r\n\t\t\tOnRepairFailedResources(player, list);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint num6 = 0;\r\n\t\tforeach (ItemAmount item in list)\r\n\t\t{\r\n\t\t\tint amount = UnityEngine.Mathf.CeilToInt(num5 * item.amount);\r\n\t\t\tint num7 = player.inventory.Take(null, item.itemid, amount);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, \"repair_entity\", item.itemDef.shortname, num7, this, null, safezone: false, null, player.userID);\r\n\t\t\tif (num7 > 0)\r\n\t\t\t{\r\n\t\t\t\tnum6 += num7;\r\n\t\t\t\tplayer.Command(\"note.inv\", item.itemid, num7 * -1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfloat num8 = (float)num6 / num4;\r\n\t\thealth += num2 * num8;\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n\telse\r\n\t{\r\n\t\thealth += num2;\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnEntityRepaired(player, this, healthBefore, health);\r\n\tif (Health() >= MaxHealth())\r\n\t{\r\n\t\tOnRepairFinished();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tOnRepair();\r\n\t}\r\n}\r\n",
    "targetName": "BaseCombatEntity",
    "methodName": "DoRepair",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCupboardDeauthorize",
    "fullName": "OnCupboardDeauthorize",
    "category": "Structure",
    "parameters": [
      {
        "name": "buildingPrivlidge",
        "type": "BuildingPrivlidge, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RemoveSelfAuthorize(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && CanAdministrate(rpc.player))\r\n\t{\r\n\t\tauthorizedPlayers.RemoveWhere((ProtoBuf.PlayerNameID x) => x.userid == (ulong)rpc.player.userID);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, System.Linq.Enumerable.Select(authorizedPlayers, (ProtoBuf.PlayerNameID x) => x.userid), \"removed\", rpc.player.userID);\r\n\t\tUpdateMaxAuthCapacity();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "BuildingPrivlidge",
    "methodName": "RemoveSelfAuthorize",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCupboardClearList",
    "fullName": "OnCupboardClearList",
    "category": "Structure",
    "parameters": [
      {
        "name": "buildingPrivlidge",
        "type": "BuildingPrivlidge, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ClearList(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && CanAdministrate(rpc.player))\r\n\t{\r\n\t\tauthorizedPlayers.Clear();\r\n\t\tUpdateMaxAuthCapacity();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "BuildingPrivlidge",
    "methodName": "ClearList",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCupboardProtectionCalculated",
    "fullName": "OnCupboardProtectionCalculated",
    "category": "Structure",
    "parameters": [
      {
        "name": "buildingPrivlidge",
        "type": "BuildingPrivlidge, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BuildingPrivlidge, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public float GetProtectedMinutes(bool force = false)\r\n{\r\n\tif (base.isServer)\r\n\t{\r\n\t\tif (!force && UnityEngine.Time.realtimeSinceStartup < nextProtectedCalcTime)\r\n\t\t{\r\n\t\t\treturn cachedProtectedMinutes;\r\n\t\t}\r\n\t\tnextProtectedCalcTime = UnityEngine.Time.realtimeSinceStartup + 60f;\r\n\t\tSystem.Collections.Generic.List<ItemAmount> obj = Facepunch.Pool.Get<System.Collections.Generic.List<ItemAmount>>();\r\n\t\tCalculateUpkeepCostAmounts(obj);\r\n\t\tfloat num = CalculateUpkeepPeriodMinutes();\r\n\t\tfloat num2 = -1f;\r\n\t\tif (base.inventory != null)\r\n\t\t{\r\n\t\t\tforeach (ItemAmount item in obj)\r\n\t\t\t{\r\n\t\t\t\tint num3 = System.Linq.Enumerable.Sum(base.inventory.FindItemsByItemID(item.itemid), (Item x) => x.amount);\r\n\t\t\t\tif (num3 > 0 && item.amount > 0f)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat num4 = (float)num3 / item.amount * num;\r\n\t\t\t\t\tif (num2 == -1f || num4 < num2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnum2 = num4;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tnum2 = 0f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (num2 == -1f)\r\n\t\t\t{\r\n\t\t\t\tnum2 = 0f;\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\tcachedProtectedMinutes = num2;\r\n\t\treturn cachedProtectedMinutes;\r\n\t}\r\n\treturn 0f;\r\n}\r\n",
    "targetName": "BuildingPrivlidge",
    "methodName": "GetProtectedMinutes",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "IOnCupboardAuthorize",
    "fullName": "IOnCupboardAuthorize [BuildingPrivlidge]",
    "category": "Structure",
    "parameters": [
      {
        "name": "local0",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "buildingPrivlidge",
        "type": "BuildingPrivlidge, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void AddAuthorize(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && CanAdministrate(rpc.player))\r\n\t{\r\n\t\tulong targetPlayerId = rpc.read.UInt64();\r\n\t\tAddPlayer(rpc.player, targetPlayerId);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "BuildingPrivlidge",
    "methodName": "AddAuthorize",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanBuild",
    "fullName": "CanBuild",
    "category": "Structure",
    "parameters": [
      {
        "name": "planner",
        "type": "Planner, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Construction, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "Construction+Target, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void DoBuild(ProtoBuf.CreateBuilding msg)\r\n{\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredMovementAntiHack())\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.AntihackWithReason, false, ownerPlayer.lastViolationType.ToString());\r\n\t\treturn;\r\n\t}\r\n\tConstruction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);\r\n\tif (construction == null)\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindConstruction, false);\r\n\t\tConstructionErrors.Log(ownerPlayer, msg.blockID.ToString());\r\n\t\treturn;\r\n\t}\r\n\tif (!CanAffordToPlace(construction))\r\n\t{\r\n\t\tusing (ProtoBuf.ItemAmountList itemAmountList = Facepunch.Pool.Get<ProtoBuf.ItemAmountList>())\r\n\t\t{\r\n\t\t\titemAmountList.amount = Facepunch.Pool.Get<System.Collections.Generic.List<float>>();\r\n\t\t\titemAmountList.itemID = Facepunch.Pool.Get<System.Collections.Generic.List<int>>();\r\n\t\t\tGetConstructionCost(itemAmountList, construction);\r\n\t\t\townerPlayer.ClientRPC(RpcTarget.Player(\"Client_OnRepairFailedResources\", ownerPlayer), itemAmountList);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\r\n\t\treturn;\r\n\t}\r\n\tDeployable deployable = GetDeployable(msg.entity);\r\n\tif (construction.deployable != deployable)\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.DeployableMismatch, false);\r\n\t\treturn;\r\n\t}\r\n\tConstruction.Target target = default(Construction.Target);\r\n\tif (msg.entity.IsValid)\r\n\t{\r\n\t\ttarget.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;\r\n\t\tif (target.entity == null)\r\n\t\t{\r\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindEntity, false);\r\n\t\t\tConstructionErrors.Log(ownerPlayer, msg.entity.ToString());\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tmsg.ray = new UnityEngine.Ray(target.entity.transform.TransformPoint(msg.ray.origin), target.entity.transform.TransformDirection(msg.ray.direction));\r\n\t\tmsg.position = target.entity.transform.TransformPoint(msg.position);\r\n\t\tmsg.normal = target.entity.transform.TransformDirection(msg.normal);\r\n\t\tmsg.rotation = target.entity.transform.rotation * msg.rotation;\r\n\t\tif (msg.socket != 0)\r\n\t\t{\r\n\t\t\tstring text = StringPool.Get(msg.socket);\r\n\t\t\tif (text != \"\")\r\n\t\t\t{\r\n\t\t\t\ttarget.socket = FindSocket(text, target.entity.prefabID);\r\n\t\t\t}\r\n\t\t\tif (target.socket == null)\r\n\t\t\t{\r\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindSocket, false);\r\n\t\t\t\tConstructionErrors.Log(ownerPlayer, msg.socket.ToString());\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (target.entity is Door)\r\n\t\t{\r\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantDeployOnDoor, false);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\ttarget.ray = msg.ray;\r\n\ttarget.onTerrain = msg.onterrain;\r\n\ttarget.position = msg.position;\r\n\ttarget.normal = msg.normal;\r\n\ttarget.rotation = msg.rotation;\r\n\ttarget.player = ownerPlayer;\r\n\ttarget.isHoldingShift = msg.isHoldingShift;\r\n\ttarget.valid = true;\r\n\tif (ShouldParent(target.entity, deployable))\r\n\t{\r\n\t\tUnityEngine.Vector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);\r\n\t\tfloat num = target.entity.Distance(position);\r\n\t\tif (num > 1f)\r\n\t\t{\r\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.ParentTooFar, false);\r\n\t\t\tConstructionErrors.Log(ownerPlayer, num.ToString());\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tBaseEntity baseEntity = DoBuild(target, construction);\r\n\tif (baseEntity != null && baseEntity is BuildingBlock buildingBlock && ownerPlayer.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n\t\tConstructionGrade constructionGrade = construction.grades[msg.setToGrade];\r\n\t\tif (buildingBlock.currentGrade != constructionGrade)\r\n\t\t{\r\n\t\t\tbuildingBlock.ChangeGradeAndSkin(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\r\n\t\t}\r\n\t}\r\n\tif (baseEntity != null && baseEntity is DecayEntity decayEntity)\r\n\t{\r\n\t\tdecayEntity.timePlaced = GetNetworkTime();\r\n\t}\r\n}\r\n",
    "targetName": "Planner",
    "methodName": "DoBuild",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEntityBuilt",
    "fullName": "OnEntityBuilt",
    "category": "Structure",
    "parameters": [
      {
        "name": "planner",
        "type": "Planner, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "UnityEngine.GameObject, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void DoBuild(ProtoBuf.CreateBuilding msg)\r\n{\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredMovementAntiHack())\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.AntihackWithReason, false, ownerPlayer.lastViolationType.ToString());\r\n\t\treturn;\r\n\t}\r\n\tConstruction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);\r\n\tif (construction == null)\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindConstruction, false);\r\n\t\tConstructionErrors.Log(ownerPlayer, msg.blockID.ToString());\r\n\t\treturn;\r\n\t}\r\n\tif (!CanAffordToPlace(construction))\r\n\t{\r\n\t\tusing (ProtoBuf.ItemAmountList itemAmountList = Facepunch.Pool.Get<ProtoBuf.ItemAmountList>())\r\n\t\t{\r\n\t\t\titemAmountList.amount = Facepunch.Pool.Get<System.Collections.Generic.List<float>>();\r\n\t\t\titemAmountList.itemID = Facepunch.Pool.Get<System.Collections.Generic.List<int>>();\r\n\t\t\tGetConstructionCost(itemAmountList, construction);\r\n\t\t\townerPlayer.ClientRPC(RpcTarget.Player(\"Client_OnRepairFailedResources\", ownerPlayer), itemAmountList);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);\r\n\t\treturn;\r\n\t}\r\n\tDeployable deployable = GetDeployable(msg.entity);\r\n\tif (construction.deployable != deployable)\r\n\t{\r\n\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.DeployableMismatch, false);\r\n\t\treturn;\r\n\t}\r\n\tConstruction.Target target = default(Construction.Target);\r\n\tif (msg.entity.IsValid)\r\n\t{\r\n\t\ttarget.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;\r\n\t\tif (target.entity == null)\r\n\t\t{\r\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindEntity, false);\r\n\t\t\tConstructionErrors.Log(ownerPlayer, msg.entity.ToString());\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tmsg.ray = new UnityEngine.Ray(target.entity.transform.TransformPoint(msg.ray.origin), target.entity.transform.TransformDirection(msg.ray.direction));\r\n\t\tmsg.position = target.entity.transform.TransformPoint(msg.position);\r\n\t\tmsg.normal = target.entity.transform.TransformDirection(msg.normal);\r\n\t\tmsg.rotation = target.entity.transform.rotation * msg.rotation;\r\n\t\tif (msg.socket != 0)\r\n\t\t{\r\n\t\t\tstring text = StringPool.Get(msg.socket);\r\n\t\t\tif (text != \"\")\r\n\t\t\t{\r\n\t\t\t\ttarget.socket = FindSocket(text, target.entity.prefabID);\r\n\t\t\t}\r\n\t\t\tif (target.socket == null)\r\n\t\t\t{\r\n\t\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindSocket, false);\r\n\t\t\t\tConstructionErrors.Log(ownerPlayer, msg.socket.ToString());\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (target.entity is Door)\r\n\t\t{\r\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantDeployOnDoor, false);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\ttarget.ray = msg.ray;\r\n\ttarget.onTerrain = msg.onterrain;\r\n\ttarget.position = msg.position;\r\n\ttarget.normal = msg.normal;\r\n\ttarget.rotation = msg.rotation;\r\n\ttarget.player = ownerPlayer;\r\n\ttarget.isHoldingShift = msg.isHoldingShift;\r\n\ttarget.valid = true;\r\n\tif (ShouldParent(target.entity, deployable))\r\n\t{\r\n\t\tUnityEngine.Vector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);\r\n\t\tfloat num = target.entity.Distance(position);\r\n\t\tif (num > 1f)\r\n\t\t{\r\n\t\t\townerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.ParentTooFar, false);\r\n\t\t\tConstructionErrors.Log(ownerPlayer, num.ToString());\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tBaseEntity baseEntity = DoBuild(target, construction);\r\n\tif (baseEntity != null && baseEntity is BuildingBlock buildingBlock && ownerPlayer.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n\t\tConstructionGrade constructionGrade = construction.grades[msg.setToGrade];\r\n\t\tif (buildingBlock.currentGrade != constructionGrade)\r\n\t\t{\r\n\t\t\tbuildingBlock.ChangeGradeAndSkin(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\r\n\t\t}\r\n\t}\r\n\tif (baseEntity != null && baseEntity is DecayEntity decayEntity)\r\n\t{\r\n\t\tdecayEntity.timePlaced = GetNetworkTime();\r\n\t}\r\n}\r\n",
    "targetName": "Planner",
    "methodName": "DoBuild",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanAffordToPlace",
    "fullName": "CanAffordToPlace",
    "category": "Structure",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "planner",
        "type": "Planner, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "component",
        "type": "Construction, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanAffordToPlace(Construction component)\r\n{\r\n\tif (isTypeDeployable)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (ownerPlayer.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tforeach (ItemAmount item in component.defaultGrade.CostToBuild())\r\n\t{\r\n\t\tif ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) < item.amount)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "Planner",
    "methodName": "CanAffordToPlace",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnConstructionPlace",
    "fullName": "OnConstructionPlace",
    "category": "Structure",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public UnityEngine.GameObject DoPlacement(Construction.Target placement, Construction component)\r\n{\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tBaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);\r\n\tif (!baseEntity)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tfloat num = 1f;\r\n\tfloat num2 = 0f;\r\n\tItem ownerItem = GetOwnerItem();\r\n\tif (ownerItem != null)\r\n\t{\r\n\t\tbaseEntity.skinID = ownerItem.skin;\r\n\t\tif (ownerItem.hasCondition)\r\n\t\t{\r\n\t\t\tnum = ownerItem.conditionNormalized;\r\n\t\t}\r\n\t}\r\n\tbaseEntity.gameObject.AwakeFromInstantiate();\r\n\tBuildingBlock buildingBlock = baseEntity as BuildingBlock;\r\n\tif ((bool)buildingBlock)\r\n\t{\r\n\t\tbuildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);\r\n\t\tif (!buildingBlock.blockDefinition)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(\"Placing a building block that has no block definition!\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tbuildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);\r\n\t}\r\n\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\r\n\tif ((bool)baseCombatEntity)\r\n\t{\r\n\t\tnum2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);\r\n\t\tbaseCombatEntity.ResetLifeStateOnSpawn = false;\r\n\t\tbaseCombatEntity.InitializeHealth(num2 * num, baseCombatEntity.StartMaxHealth());\r\n\t}\r\n\tbaseEntity.OnPlaced(ownerPlayer);\r\n\tbaseEntity.OwnerID = ownerPlayer.userID;\r\n\tbaseEntity.Spawn();\r\n\tif ((bool)buildingBlock)\r\n\t{\r\n\t\tEffect.server.Run(\"assets/bundled/prefabs/fx/build/frame_place.prefab\", baseEntity, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t}\r\n\tStabilityEntity stabilityEntity = baseEntity as StabilityEntity;\r\n\tif ((bool)stabilityEntity)\r\n\t{\r\n\t\tstabilityEntity.UpdateSurroundingEntities();\r\n\t}\r\n\treturn baseEntity.gameObject;\r\n}\r\n",
    "targetName": "Planner",
    "methodName": "DoPlacement",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCodeEntered",
    "fullName": "OnCodeEntered",
    "category": "Structure",
    "parameters": [
      {
        "name": "codeLock",
        "type": "CodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f, CheckParent = true)]\r\npublic void UnlockWithCode(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!rpc.player.CanInteract() || !IsLocked() || IsCodeEntryBlocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = rpc.read.String();\r\n\tbool flag = text == guestCode;\r\n\tbool flag2 = text == code;\r\n\tif (!(text == code) && (!hasGuestCode || !(text == guestCode)))\r\n\t{\r\n\t\tif (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 60f)\r\n\t\t{\r\n\t\t\twrongCodes = 0;\r\n\t\t}\r\n\t\tDoEffect(effectDenied.resourcePath);\r\n\t\tDoEffect(effectShock.resourcePath);\r\n\t\trpc.player.Hurt((float)(wrongCodes + 1) * 5f, Rust.DamageType.ElectricShock, this, useProtection: false);\r\n\t\twrongCodes++;\r\n\t\tif (wrongCodes > 5)\r\n\t\t{\r\n\t\t\trpc.player.ShowToast(GameTip.Styles.Red_Normal, blockwarning, false);\r\n\t\t}\r\n\t\tif ((float)wrongCodes >= maxFailedAttempts)\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved11, b: true);\r\n\t\t\tInvoke(ClearCodeEntryBlocked, lockoutCooldown);\r\n\t\t}\r\n\t\tlastWrongTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\treturn;\r\n\t}\r\n\tSendNetworkUpdate();\r\n\tif (flag2)\r\n\t{\r\n\t\tif (!whitelistPlayers.Contains(rpc.player.userID))\r\n\t\t{\r\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\r\n\t\t\twhitelistPlayers.Add(rpc.player.userID);\r\n\t\t\twrongCodes = 0;\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: false);\r\n\t}\r\n\telse if (flag && !guestPlayers.Contains(rpc.player.userID))\r\n\t{\r\n\t\tDoEffect(effectCodeChanged.resourcePath);\r\n\t\tguestPlayers.Add(rpc.player.userID);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: true);\r\n\t}\r\n}\r\n",
    "targetName": "CodeLock",
    "methodName": "UnlockWithCode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCodeChanged",
    "fullName": "OnCodeChanged",
    "category": "Structure",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "codeLock",
        "type": "CodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f, CheckParent = true)]\r\npublic void RPC_ChangeCode(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = rpc.read.String();\r\n\tbool flag = rpc.read.Bit();\r\n\tif (!IsLocked() && text.Length == 4 && UnityEngine.StringEx.IsNumeric(text) && !(!hasCode && flag))\r\n\t{\r\n\t\tif (!hasCode && !flag)\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Locked, b: true);\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tcode = text;\r\n\t\t\thasCode = code.Length > 0;\r\n\t\t\twhitelistPlayers.Clear();\r\n\t\t\twhitelistPlayers.Add(rpc.player.userID);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tguestCode = text;\r\n\t\t\thasGuestCode = guestCode.Length > 0;\r\n\t\t\tguestPlayers.Clear();\r\n\t\t\tguestPlayers.Add(rpc.player.userID);\r\n\t\t}\r\n\t\tDoEffect(effectCodeChanged.resourcePath);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "CodeLock",
    "methodName": "RPC_ChangeCode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnBuildingSplit",
    "fullName": "OnBuildingSplit",
    "category": "Structure",
    "parameters": [
      {
        "name": "building",
        "type": "BuildingManager+Building, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "newID",
        "type": "System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Split(BuildingManager.Building building)\r\n{\r\n\twhile (building.HasBuildingBlocks())\r\n\t{\r\n\t\tBuildingBlock buildingBlock = building.buildingBlocks[0];\r\n\t\tuint newID = BuildingManager.server.NewBuildingID();\r\n\t\tbuildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)\r\n\t\t{\r\n\t\t\tb.AttachToBuilding(newID);\r\n\t\t});\r\n\t}\r\n\twhile (building.HasBuildingPrivileges())\r\n\t{\r\n\t\tBuildingPrivlidge buildingPrivlidge = building.buildingPrivileges[0];\r\n\t\tBuildingBlock nearbyBuildingBlock = buildingPrivlidge.GetNearbyBuildingBlock();\r\n\t\tbuildingPrivlidge.AttachToBuilding(nearbyBuildingBlock ? nearbyBuildingBlock.buildingID : 0u);\r\n\t}\r\n\twhile (building.HasDecayEntities())\r\n\t{\r\n\t\tDecayEntity decayEntity = building.decayEntities[0];\r\n\t\tBuildingBlock nearbyBuildingBlock2 = decayEntity.GetNearbyBuildingBlock();\r\n\t\tdecayEntity.AttachToBuilding(nearbyBuildingBlock2 ? nearbyBuildingBlock2.buildingID : 0u);\r\n\t}\r\n\tif (ConVar.AI.nav_carve_use_building_optimization)\r\n\t{\r\n\t\tbuilding.isNavMeshCarvingDirty = true;\r\n\t\tint ticks = 2;\r\n\t\tUpdateNavMeshCarver(building, ref ticks, 0);\r\n\t}\r\n}\r\n",
    "targetName": "ServerBuildingManager",
    "methodName": "Split",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnBuildingMerge",
    "fullName": "OnBuildingMerge",
    "category": "Structure",
    "parameters": [
      {
        "name": "serverBuildingManager",
        "type": "ServerBuildingManager, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Merge(BuildingManager.Building building1, BuildingManager.Building building2)\r\n{\r\n\twhile (building2.HasDecayEntities())\r\n\t{\r\n\t\tbuilding2.decayEntities[0].AttachToBuilding(building1.ID);\r\n\t}\r\n\tif (ConVar.AI.nav_carve_use_building_optimization)\r\n\t{\r\n\t\tbuilding1.isNavMeshCarvingDirty = true;\r\n\t\tbuilding2.isNavMeshCarvingDirty = true;\r\n\t\tint ticks = 3;\r\n\t\tUpdateNavMeshCarver(building1, ref ticks, 0);\r\n\t\tUpdateNavMeshCarver(building1, ref ticks, 0);\r\n\t}\r\n}\r\n",
    "targetName": "ServerBuildingManager",
    "methodName": "Merge",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSignLocked",
    "fullName": "OnSignLocked [PhotoFrame]",
    "category": "Structure",
    "parameters": [
      {
        "name": "photoFrame",
        "type": "PhotoFrame, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void LockSign(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && CanUpdateSign(msg.player))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Locked, b: true);\r\n\t\tSendNetworkUpdate();\r\n\t\tbase.OwnerID = msg.player.userID;\r\n\t}\r\n}\r\n",
    "targetName": "PhotoFrame",
    "methodName": "LockSign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnSignUpdated",
    "fullName": "OnSignUpdated [PhotoFrame]",
    "category": "Structure",
    "parameters": [
      {
        "name": "photoFrame",
        "type": "PhotoFrame, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(5f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(3uL)]\r\npublic void UpdateSign(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!(msg.player == null) && CanUpdateSign(msg.player))\r\n\t{\r\n\t\tbyte[] array = msg.read.BytesWithSize();\r\n\t\tif (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))\r\n\t\t{\r\n\t\t\tFileStorage.server.RemoveAllByEntity(net.ID);\r\n\t\t\t_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);\r\n\t\t\tLogEdit(msg.player);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "PhotoFrame",
    "methodName": "UpdateSign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCupboardAuthorize",
    "fullName": "OnCupboardAuthorize [ItemModDeployable]",
    "category": "Structure",
    "parameters": [
      {
        "name": "local0",
        "type": "BuildingPrivlidge, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OnDeployed(BaseEntity ent, BasePlayer player)\r\n{\r\n\tif (player.IsValid() && !string.IsNullOrEmpty(UnlockAchievement))\r\n\t{\r\n\t\tplayer.GiveAchievement(UnlockAchievement);\r\n\t}\r\n\tif (ent is BuildingPrivlidge buildingPrivlidge)\r\n\t{\r\n\t\tbuildingPrivlidge.AddPlayer(player, player.userID);\r\n\t}\r\n}\r\n",
    "targetName": "ItemModDeployable",
    "methodName": "OnDeployed",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSignUpdated",
    "fullName": "OnSignUpdated [CarvablePumpkin]",
    "category": "Structure",
    "parameters": [
      {
        "name": "carvablePumpkin",
        "type": "CarvablePumpkin, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\n[BaseEntity.RPC_Server.MaxDistance(5f)]\r\npublic void UpdateSign(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player == null || !CanUpdateSign(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tif (num < 0 || num >= paintableSources.Length)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbyte[] array = msg.read.BytesWithSize();\r\n\tif (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning($\"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring\");\r\n\t\treturn;\r\n\t}\r\n\tEnsureInitialized();\r\n\tif (array == null)\r\n\t{\r\n\t\tif (textureIDs[num] != 0)\r\n\t\t{\r\n\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\r\n\t\t}\r\n\t\ttextureIDs[num] = 0u;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!ImageProcessing.IsValidPNG(array, 1024, 1024))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (textureIDs[num] != 0)\r\n\t\t{\r\n\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\r\n\t\t}\r\n\t\ttextureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);\r\n\t}\r\n\tLogEdit(msg.player);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "CarvablePumpkin",
    "methodName": "UpdateSign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDoorKnocked",
    "fullName": "OnDoorKnocked [DoorKnocker]",
    "category": "Structure",
    "parameters": [
      {
        "name": "doorKnocker",
        "type": "DoorKnocker, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Knock(BasePlayer player)\r\n{\r\n\tClientRPC(RpcTarget.NetworkGroup(\"ClientKnock\"), player.transform.position);\r\n}\r\n",
    "targetName": "DoorKnocker",
    "methodName": "Knock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnLockerSwap",
    "fullName": "OnLockerSwap",
    "category": "Structure",
    "parameters": [
      {
        "name": "locker",
        "type": "Locker, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Equip(BaseEntity.RPCMessage msg)\r\n{\r\n\tint num = msg.read.Int32();\r\n\tif (num < 0 || num >= 3 || IsEquipping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = msg.player;\r\n\tint num2 = num * 14;\r\n\tbool flag = false;\r\n\tfor (int i = 0; i < clothingBuffer.Length; i++)\r\n\t{\r\n\t\tItem slot = player.inventory.containerWear.GetSlot(i);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tslot.RemoveFromContainer();\r\n\t\t\tclothingBuffer[i] = slot;\r\n\t\t}\r\n\t}\r\n\tfor (int j = 0; j < 8; j++)\r\n\t{\r\n\t\tint num3 = num2 + j;\r\n\t\tItem slot2 = base.inventory.GetSlot(num3);\r\n\t\tItem item = clothingBuffer[j];\r\n\t\tif (slot2 != null)\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t\tif (slot2.info.category != ItemCategory.Attire || !slot2.MoveToContainer(player.inventory.containerWear, j))\r\n\t\t\t{\r\n\t\t\t\tslot2.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t\tif (!item.MoveToContainer(base.inventory, num3) && !item.MoveToContainer(player.inventory.containerWear, j))\r\n\t\t\t{\r\n\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t\t}\r\n\t\t}\r\n\t\tclothingBuffer[j] = null;\r\n\t}\r\n\tfor (int k = 0; k < 6; k++)\r\n\t{\r\n\t\tint num4 = num2 + k + 8;\r\n\t\tint iTargetPos = k;\r\n\t\tItem slot3 = base.inventory.GetSlot(num4);\r\n\t\tItem slot4 = player.inventory.containerBelt.GetSlot(k);\r\n\t\tslot4?.RemoveFromContainer();\r\n\t\tif (slot3 != null)\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t\tif (!slot3.MoveToContainer(player.inventory.containerBelt, iTargetPos))\r\n\t\t\t{\r\n\t\t\t\tslot3.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (slot4 != null)\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t\tif (!slot4.MoveToContainer(base.inventory, num4))\r\n\t\t\t{\r\n\t\t\t\tslot4.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tEffect.server.Run(equipSound.resourcePath, player, StringPool.Get(\"spine3\"), UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\tSetFlag(BaseEntity.Flags.Reserved1, b: true);\r\n\t\tInvoke(ClearEquipping, 1.5f);\r\n\t}\r\n}\r\n",
    "targetName": "Locker",
    "methodName": "RPC_Equip",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPoweredLightsPointAdd",
    "fullName": "OnPoweredLightsPointAdd",
    "category": "Structure",
    "parameters": [
      {
        "name": "poweredLightsDeployer",
        "type": "PoweredLightsDeployer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void AddPoint(BaseEntity.RPCMessage msg)\r\n{\r\n\tUnityEngine.Vector3 vector = msg.read.Vector3();\r\n\tUnityEngine.Vector3 vector2 = msg.read.Vector3();\r\n\tfloat slackLevel = msg.read.Float();\r\n\tBasePlayer player = msg.player;\r\n\tif (GetItem() == null || GetItem().amount < 1 || !IsVisible(vector) || !CanPlayerUse(player) || UnityEngine.Vector3.Distance(vector, player.eyes.position) > maxPlaceDistance || !CheckValidPlacement(vector, 0.1f, 10551297))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = 1;\r\n\tif (active == null)\r\n\t{\r\n\t\tAdvancedChristmasLights component = GameManager.server.CreateEntity(poweredLightsPrefab.resourcePath, vector, UnityEngine.Quaternion.LookRotation(vector2, player.eyes.HeadUp())).GetComponent<AdvancedChristmasLights>();\r\n\t\tcomponent.Spawn();\r\n\t\tactive = component;\r\n\t\tnum = 1;\r\n\t\tif (player.IsInCreativeMode && ConVar.Creative.unlimitedIo)\r\n\t\t{\r\n\t\t\tnum = 0;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (active.IsFinalized())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat a = 0f;\r\n\t\tUnityEngine.Vector3 vector3 = active.transform.position;\r\n\t\tif (active.points.Count > 0)\r\n\t\t{\r\n\t\t\tvector3 = active.points[active.points.Count - 1].point;\r\n\t\t\ta = UnityEngine.Vector3.Distance(vector, vector3);\r\n\t\t}\r\n\t\ta = UnityEngine.Mathf.Max(a, lengthPerAmount);\r\n\t\tfloat num2 = (float)GetItem().amount * lengthPerAmount;\r\n\t\tif (player.IsInCreativeMode && ConVar.Creative.unlimitedIo)\r\n\t\t{\r\n\t\t\tnum2 = 200f;\r\n\t\t}\r\n\t\tif (a > num2)\r\n\t\t{\r\n\t\t\ta = num2;\r\n\t\t\tvector = vector3 + UnityEngine.Vector3Ex.Direction(vector, vector3) * a;\r\n\t\t}\r\n\t\ta = UnityEngine.Mathf.Min(num2, a);\r\n\t\tnum = UnityEngine.Mathf.CeilToInt(a / lengthPerAmount);\r\n\t\tif (player.IsInCreativeMode && ConVar.Creative.unlimitedIo)\r\n\t\t{\r\n\t\t\tnum = 0;\r\n\t\t}\r\n\t}\r\n\tactive.AddPoint(vector, vector2, slackLevel);\r\n\tSetFlag(BaseEntity.Flags.Reserved8, active != null);\r\n\tint iAmount = num;\r\n\tUseItemAmount(iAmount);\r\n\tactive.AddLengthUsed(num);\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "PoweredLightsDeployer",
    "methodName": "AddPoint",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSignContentCopied",
    "fullName": "OnSignContentCopied",
    "category": "Structure",
    "parameters": [
      {
        "name": "signContent",
        "type": "SignContent, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "s",
        "type": "ISignage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "b",
        "type": "IUGCBrowserEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void CopyInfoToSign(ISignage s, IUGCBrowserEntity b)\r\n{\r\n\tFileStorage.server.ReassignEntityId(net.ID, s.NetworkID);\r\n\ts.SetTextureCRCs(textureIDs);\r\n\tb.EditingHistory.Clear();\r\n\tforeach (ulong item in editHistory)\r\n\t{\r\n\t\tb.EditingHistory.Add(item);\r\n\t}\r\n}\r\n",
    "targetName": "SignContent",
    "methodName": "CopyInfoToSign",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTeamCreate",
    "fullName": "OnTeamCreate",
    "category": "Team",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerUserVar]\r\npublic static void trycreateteam(ConsoleSystem.Arg arg)\r\n{\r\n\tif (maxTeamSize == 0)\r\n\t{\r\n\t\targ.ReplyWith(\"Teams are disabled on this server\");\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (basePlayer.currentTeam == 0L)\r\n\t{\r\n\t\tRelationshipManager.PlayerTeam playerTeam = ServerInstance.CreateTeam();\r\n\t\tplayerTeam.teamLeader = basePlayer.userID;\r\n\t\tplayerTeam.AddPlayer(basePlayer);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnTeamChanged(\"created\", playerTeam.teamID, basePlayer.userID, basePlayer.userID, playerTeam.members);\r\n\t}\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "trycreateteam",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTeamInvite",
    "fullName": "OnTeamInvite",
    "category": "Team",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerUserVar]\r\npublic static void sendinvite(ConsoleSystem.Arg arg)\r\n{\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tRelationshipManager.PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);\r\n\tif (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tulong uLong = arg.GetULong(0, 0uL);\r\n\tif (uLong == 0L)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer2 = BaseNetworkable.serverEntities.Find(new NetworkableId(uLong)) as BasePlayer;\r\n\tif ((bool)basePlayer2 && basePlayer2 != basePlayer && !basePlayer2.IsNpc && basePlayer2.currentTeam == 0L)\r\n\t{\r\n\t\tfloat num = 7f;\r\n\t\tif (!(UnityEngine.Vector3.Distance(basePlayer2.transform.position, basePlayer.transform.position) > num))\r\n\t\t{\r\n\t\t\tplayerTeam.SendInvite(basePlayer2);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "sendinvite",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTeamRejectInvite",
    "fullName": "OnTeamRejectInvite",
    "category": "Team",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "RelationshipManager+PlayerTeam, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerUserVar]\r\npublic static void rejectinvite(ConsoleSystem.Arg arg)\r\n{\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (!(basePlayer == null) && basePlayer.currentTeam == 0L)\r\n\t{\r\n\t\tulong uLong = arg.GetULong(0, 0uL);\r\n\t\tRelationshipManager.PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);\r\n\t\tif (playerTeam == null)\r\n\t\t{\r\n\t\t\tbasePlayer.ClearPendingInvite();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tplayerTeam.RejectInvite(basePlayer);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "rejectinvite",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTeamPromote",
    "fullName": "OnTeamPromote",
    "category": "Team",
    "parameters": [
      {
        "name": "local2",
        "type": "RelationshipManager+PlayerTeam, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerUserVar]\r\npublic static void promote(ConsoleSystem.Arg arg)\r\n{\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (basePlayer.currentTeam == 0L)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);\r\n\tif (!(lookingAtPlayer == null) && !lookingAtPlayer.IsDead() && !(lookingAtPlayer == basePlayer) && lookingAtPlayer.currentTeam == basePlayer.currentTeam)\r\n\t{\r\n\t\tRelationshipManager.PlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];\r\n\t\tif (playerTeam != null && playerTeam.teamLeader == (ulong)basePlayer.userID)\r\n\t\t{\r\n\t\t\tplayerTeam.SetTeamLeader(lookingAtPlayer.userID);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "promote",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTeamLeave",
    "fullName": "OnTeamLeave",
    "category": "Team",
    "parameters": [
      {
        "name": "local1",
        "type": "RelationshipManager+PlayerTeam, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerUserVar]\r\npublic static void leaveteam(ConsoleSystem.Arg arg)\r\n{\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (!(basePlayer == null) && basePlayer.currentTeam != 0L)\r\n\t{\r\n\t\tRelationshipManager.PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);\r\n\t\tif (playerTeam != null)\r\n\t\t{\r\n\t\t\tplayerTeam.RemovePlayer(basePlayer.userID);\r\n\t\t\tbasePlayer.ClearTeam();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "leaveteam",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTeamKick",
    "fullName": "OnTeamKick",
    "category": "Team",
    "parameters": [
      {
        "name": "local1",
        "type": "RelationshipManager+PlayerTeam, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerUserVar]\r\npublic static void kickmember(ConsoleSystem.Arg arg)\r\n{\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (basePlayer == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tRelationshipManager.PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);\r\n\tif (playerTeam != null && !(playerTeam.GetLeader() != basePlayer))\r\n\t{\r\n\t\tulong uLong = arg.GetULong(0, 0uL);\r\n\t\tif ((ulong)basePlayer.userID != uLong)\r\n\t\t{\r\n\t\t\tplayerTeam.RemovePlayer(uLong);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "kickmember",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTeamAcceptInvite",
    "fullName": "OnTeamAcceptInvite",
    "category": "Team",
    "parameters": [
      {
        "name": "local2",
        "type": "RelationshipManager+PlayerTeam, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerUserVar]\r\npublic static void acceptinvite(ConsoleSystem.Arg arg)\r\n{\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (!(basePlayer == null) && basePlayer.currentTeam == 0L)\r\n\t{\r\n\t\tulong uLong = arg.GetULong(0, 0uL);\r\n\t\tRelationshipManager.PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);\r\n\t\tif (playerTeam == null)\r\n\t\t{\r\n\t\t\tbasePlayer.ClearPendingInvite();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tplayerTeam.AcceptInvite(basePlayer);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "acceptinvite",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTeamDisband",
    "fullName": "OnTeamDisband",
    "category": "Team",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DisbandTeam(RelationshipManager.PlayerTeam teamToDisband)\r\n{\r\n\tteams.Remove(teamToDisband.teamID);\r\n\tFacepunch.Pool.Free(ref teamToDisband);\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "DisbandTeam",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTeamCreated",
    "fullName": "OnTeamCreated",
    "category": "Team",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[ServerUserVar]\r\npublic static void trycreateteam(ConsoleSystem.Arg arg)\r\n{\r\n\tif (maxTeamSize == 0)\r\n\t{\r\n\t\targ.ReplyWith(\"Teams are disabled on this server\");\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (basePlayer.currentTeam == 0L)\r\n\t{\r\n\t\tRelationshipManager.PlayerTeam playerTeam = ServerInstance.CreateTeam();\r\n\t\tplayerTeam.teamLeader = basePlayer.userID;\r\n\t\tplayerTeam.AddPlayer(basePlayer);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnTeamChanged(\"created\", playerTeam.teamID, basePlayer.userID, basePlayer.userID, playerTeam.members);\r\n\t}\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "trycreateteam",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTeamDisbanded",
    "fullName": "OnTeamDisbanded",
    "category": "Team",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DisbandTeam(RelationshipManager.PlayerTeam teamToDisband)\r\n{\r\n\tteams.Remove(teamToDisband.teamID);\r\n\tFacepunch.Pool.Free(ref teamToDisband);\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "DisbandTeam",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTeamUpdate",
    "fullName": "OnTeamUpdate",
    "category": "Team",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "newTeam",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateTeam(ulong newTeam)\r\n{\r\n\tcurrentTeam = newTeam;\r\n\tSendNetworkUpdate();\r\n\tif (RelationshipManager.ServerInstance.FindTeam(newTeam) == null)\r\n\t{\r\n\t\tClearTeam();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tTeamUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "UpdateTeam",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTeamUpdated",
    "fullName": "OnTeamUpdated",
    "category": "Team",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "ProtoBuf.PlayerTeam, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TeamUpdate()\r\n{\r\n\tTeamUpdate(fullTeamUpdate: false);\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "TeamUpdate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanUnlockTechTreeNode",
    "fullName": "CanUnlockTechTreeNode",
    "category": "TechTree",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "node",
        "type": "TechTreeData+NodeInstance, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "techTreeData",
        "type": "TechTreeData, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool PlayerCanUnlock(BasePlayer player, TechTreeData.NodeInstance node)\r\n{\r\n\tif (PlayerHasPathForUnlock(player, node))\r\n\t{\r\n\t\treturn !HasPlayerUnlocked(player, node);\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "TechTreeData",
    "methodName": "PlayerCanUnlock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanUnlockTechTreeNodePath",
    "fullName": "CanUnlockTechTreeNodePath",
    "category": "TechTree",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "node",
        "type": "TechTreeData+NodeInstance, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "techTreeData",
        "type": "TechTreeData, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool PlayerHasPathForUnlock(BasePlayer player, TechTreeData.NodeInstance node)\r\n{\r\n\tTechTreeData.NodeInstance entryNode = GetEntryNode();\r\n\tif (entryNode == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn CheckChainRecursive(player, entryNode, node);\r\n}\r\n",
    "targetName": "TechTreeData",
    "methodName": "PlayerHasPathForUnlock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnTechTreeNodeUnlock",
    "fullName": "OnTechTreeNodeUnlock",
    "category": "TechTree",
    "parameters": [
      {
        "name": "workbench",
        "type": "Workbench, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "TechTreeData+NodeInstance, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_TechTreeUnlock(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tint id = msg.read.Int32();\r\n\tint level = msg.read.Int32();\r\n\tTechTreeData techTreeForLevel = GetTechTreeForLevel(level);\r\n\tif (techTreeForLevel == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tTechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);\r\n\tif (byID == null)\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"Node for unlock not found :\" + id);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!techTreeForLevel.PlayerCanUnlock(player, byID))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (byID.IsGroup())\r\n\t\t{\r\n\t\t\tforeach (int output in byID.outputs)\r\n\t\t\t{\r\n\t\t\t\tTechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);\r\n\t\t\t\tif (byID2 != null && byID2.itemDef != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tplayer.blueprints.Unlock(byID2.itemDef);\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, \"techtree\", 0, this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tUnityEngine.Debug.Log(\"Player unlocked group :\" + byID.groupName);\r\n\t\t}\r\n\t\telse if (byID.itemDef != null)\r\n\t\t{\r\n\t\t\tint tax;\r\n\t\t\tint num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);\r\n\t\t\tint itemid = ItemManager.FindItemDefinition(\"scrap\").itemid;\r\n\t\t\tif (player.inventory.GetAmount(itemid) >= num + tax)\r\n\t\t\t{\r\n\t\t\t\tplayer.inventory.Take(null, itemid, num + tax);\r\n\t\t\t\tplayer.blueprints.Unlock(byID.itemDef);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, \"techtree\", num + tax, this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Workbench",
    "methodName": "RPC_TechTreeUnlock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTechTreeNodeUnlocked",
    "fullName": "OnTechTreeNodeUnlocked",
    "category": "TechTree",
    "parameters": [
      {
        "name": "workbench",
        "type": "Workbench, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "TechTreeData+NodeInstance, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_TechTreeUnlock(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tint id = msg.read.Int32();\r\n\tint level = msg.read.Int32();\r\n\tTechTreeData techTreeForLevel = GetTechTreeForLevel(level);\r\n\tif (techTreeForLevel == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tTechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);\r\n\tif (byID == null)\r\n\t{\r\n\t\tUnityEngine.Debug.Log(\"Node for unlock not found :\" + id);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!techTreeForLevel.PlayerCanUnlock(player, byID))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (byID.IsGroup())\r\n\t\t{\r\n\t\t\tforeach (int output in byID.outputs)\r\n\t\t\t{\r\n\t\t\t\tTechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);\r\n\t\t\t\tif (byID2 != null && byID2.itemDef != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tplayer.blueprints.Unlock(byID2.itemDef);\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, \"techtree\", 0, this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tUnityEngine.Debug.Log(\"Player unlocked group :\" + byID.groupName);\r\n\t\t}\r\n\t\telse if (byID.itemDef != null)\r\n\t\t{\r\n\t\t\tint tax;\r\n\t\t\tint num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);\r\n\t\t\tint itemid = ItemManager.FindItemDefinition(\"scrap\").itemid;\r\n\t\t\tif (player.inventory.GetAmount(itemid) >= num + tax)\r\n\t\t\t{\r\n\t\t\t\tplayer.inventory.Take(null, itemid, num + tax);\r\n\t\t\t\tplayer.blueprints.Unlock(byID.itemDef);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, \"techtree\", num + tax, this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Workbench",
    "methodName": "RPC_TechTreeUnlock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTrapSnapped",
    "fullName": "OnTrapSnapped",
    "category": "Traps",
    "parameters": [
      {
        "name": "baseTrapTrigger",
        "type": "BaseTrapTrigger, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnObjectAdded(UnityEngine.GameObject obj, UnityEngine.Collider col)\r\n{\r\n\tbase.OnObjectAdded(obj, col);\r\n\t_trap.ObjectEntered(obj);\r\n}\r\n",
    "targetName": "BaseTrapTrigger",
    "methodName": "OnObjectAdded",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTrapDisarm",
    "fullName": "OnTrapDisarm",
    "category": "Traps",
    "parameters": [
      {
        "name": "landmine",
        "type": "Landmine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_Disarm(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif ((ulong)rpc.player.userID != triggerPlayerID && Armed() && Triggered())\r\n\t{\r\n\t\tif (UnityEngine.Random.Range(0, 100) < 15)\r\n\t\t{\r\n\t\t\tInvoke(TryExplode, 0.05f);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSetFlag(BaseEntity.Flags.On, b: false);\r\n\t\trpc.player.GiveItem(ItemManager.CreateByName(\"trap.landmine\", 1, 0uL), BaseEntity.GiveItemReason.PickedUp);\r\n\t\tKill();\r\n\t}\r\n}\r\n",
    "targetName": "Landmine",
    "methodName": "RPC_Disarm",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTrapTrigger",
    "fullName": "OnTrapTrigger [Landmine]",
    "category": "Traps",
    "parameters": [
      {
        "name": "landmine",
        "type": "Landmine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void ObjectEntered(UnityEngine.GameObject obj)\r\n{\r\n\tif (!base.isClient)\r\n\t{\r\n\t\tif (!Armed())\r\n\t\t{\r\n\t\t\tCancelInvoke(Arm);\r\n\t\t\tblocked = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tBasePlayer ply = UnityEngine.GameObjectEx.ToBaseEntity(obj) as BasePlayer;\r\n\t\t\tTrigger(ply);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "Landmine",
    "methodName": "ObjectEntered",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTrapArm",
    "fullName": "OnTrapArm",
    "category": "Traps",
    "parameters": [
      {
        "name": "bearTrap",
        "type": "BearTrap, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_Arm(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!Armed())\r\n\t{\r\n\t\tArm();\r\n\t}\r\n}\r\n",
    "targetName": "BearTrap",
    "methodName": "RPC_Arm",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTrapTrigger",
    "fullName": "OnTrapTrigger [BearTrap]",
    "category": "Traps",
    "parameters": [
      {
        "name": "bearTrap",
        "type": "BearTrap, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void ObjectEntered(UnityEngine.GameObject obj)\r\n{\r\n\tif (Armed())\r\n\t{\r\n\t\thurtTarget = obj;\r\n\t\tInvoke(DelayedFire, 0.05f);\r\n\t}\r\n}\r\n",
    "targetName": "BearTrap",
    "methodName": "ObjectEntered",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWildlifeTrap",
    "fullName": "OnWildlifeTrap",
    "category": "Traps",
    "parameters": [
      {
        "name": "wildlifeTrap",
        "type": "WildlifeTrap, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "trapped",
        "type": "TrappableWildlife, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TrapWildlife(TrappableWildlife trapped)\r\n{\r\n\tItem item = ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);\r\n\tif (base.LastLootedByPlayer != null)\r\n\t{\r\n\t\titem.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);\r\n\t}\r\n\tif (!item.MoveToContainer(base.inventory))\r\n\t{\r\n\t\titem.Remove();\r\n\t\tOnTrappedWildlife(setFlag: false);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tOnTrappedWildlife(setFlag: true);\r\n\t}\r\n}\r\n",
    "targetName": "WildlifeTrap",
    "methodName": "TrapWildlife",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWildlifeTrap",
    "fullName": "OnWildlifeTrap [SurvivalFishTrap]",
    "category": "Traps",
    "parameters": [
      {
        "name": "survivalFishTrap",
        "type": "SurvivalFishTrap, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void TrapThink()\r\n{\r\n\tItemDefinition itemDefinition = null;\r\n\tItem item = null;\r\n\tint usedLureAmount = 0;\r\n\tusing (System.Collections.Generic.List<Item>.Enumerator enumerator = base.inventory.itemList.GetEnumerator())\r\n\t{\r\n\t\tif (enumerator.MoveNext())\r\n\t\t{\r\n\t\t\tItem current = enumerator.Current;\r\n\t\t\tif ((current.info.TryGetComponent<ItemModCompostable>(out var component) ? component.BaitValue : 0f) > 0f)\r\n\t\t\t{\r\n\t\t\t\titem = current;\r\n\t\t\t\titemDefinition = FishLookup.Instance.GetFish(base.transform.position, cachedWaterBody, current, out var _, current.info.GetComponent<ItemModFishable>(), out usedLureAmount, 5f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\titem?.UseItem(usedLureAmount);\r\n\tif (UnityEngine.Random.Range(0f, 1f) <= trapSuccessRate || !(itemDefinition != null))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttry\r\n\t{\r\n\t\tbypassItemFilter = true;\r\n\t\tItem item2 = ItemManager.Create(itemDefinition, 1, 0uL);\r\n\t\tif (base.LastLootedByPlayer != null)\r\n\t\t{\r\n\t\t\titem2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);\r\n\t\t}\r\n\t\tif (!item2.MoveToContainer(base.inventory))\r\n\t\t{\r\n\t\t\titem2.Drop(base.transform.position, UnityEngine.Vector3.zero, UnityEngine.Quaternion.identity);\r\n\t\t}\r\n\t\tOnTrappedWildlife(setFlag: true);\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\tbypassItemFilter = false;\r\n\t}\r\n}\r\n",
    "targetName": "SurvivalFishTrap",
    "methodName": "TrapThink",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretTarget",
    "fullName": "OnTurretTarget",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetTarget(BaseCombatEntity targ)\r\n{\r\n\tif (targ != target || targ.IsRealNull() != target.IsRealNull())\r\n\t{\r\n\t\tEffect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t\tif (outputs != null && outputs.Length != 0 && outputs[0].connectedTo.Get() != null)\r\n\t\t{\r\n\t\t\tMarkDirtyForceUpdateOutputs();\r\n\t\t}\r\n\t\tnextShotTime += 0.1f;\r\n\t\tauthDirty = true;\r\n\t}\r\n\ttarget = targ;\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "SetTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretStartup",
    "fullName": "OnTurretStartup",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void InitiateStartup()\r\n{\r\n\tif (!IsOnline() && !booting)\r\n\t{\r\n\t\tEffect.server.Run(onlineSound.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\tInvoke(SetOnline, 2f);\r\n\t\tbooting = true;\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "InitiateStartup",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretShutdown",
    "fullName": "OnTurretShutdown",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void InitiateShutdown()\r\n{\r\n\tif (!IsOffline() || booting)\r\n\t{\r\n\t\tCancelInvoke(SetOnline);\r\n\t\tbooting = false;\r\n\t\tEffect.server.Run(offlineSound.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\tSetIsOnline(online: false);\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "InitiateShutdown",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretToggle",
    "fullName": "OnTurretToggle",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetIsOnline(bool online)\r\n{\r\n\tif (online != IsOn())\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.On, online);\r\n\t\tif (online)\r\n\t\t{\r\n\t\t\tTryRegisterForInterferenceUpdate();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.OnFire, b: false);\r\n\t\t\tUpdateInterferenceOnOthers();\r\n\t\t}\r\n\t\tbooting = false;\r\n\t\tGetAttachedWeapon()?.SetLightsOn(online);\r\n\t\tSendNetworkUpdate();\r\n\t\tif (IsOffline())\r\n\t\t{\r\n\t\t\tSetTarget(null);\r\n\t\t\tisLootable = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tisLootable = false;\r\n\t\t\tauthDirty = true;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "SetIsOnline",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretDeauthorize",
    "fullName": "OnTurretDeauthorize",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RemoveSelfAuthorize(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!booting && !IsOnline() && IsAuthed(rpc.player))\r\n\t{\r\n\t\tauthorizedPlayers.RemoveWhere((ProtoBuf.PlayerNameID x) => x.userid == (ulong)rpc.player.userID);\r\n\t\tauthDirty = true;\r\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, System.Linq.Enumerable.Select(authorizedPlayers, (ProtoBuf.PlayerNameID x) => x.userid), \"removed\", rpc.player.userID);\r\n\t\tUpdateMaxAuthCapacity();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "RemoveSelfAuthorize",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretClearList",
    "fullName": "OnTurretClearList",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ClearList(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!booting && !IsOnline() && IsAuthed(rpc.player))\r\n\t{\r\n\t\tauthorizedPlayers.Clear();\r\n\t\tauthDirty = true;\r\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, System.Linq.Enumerable.Select(authorizedPlayers, (ProtoBuf.PlayerNameID x) => x.userid), \"clear\", rpc.player.userID);\r\n\t\tUpdateMaxAuthCapacity();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "ClearList",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretModeToggle",
    "fullName": "OnTurretModeToggle [Peacekeeper]",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_Peacekeeper(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (IsAuthed(rpc.player))\r\n\t{\r\n\t\tSetPeacekeepermode(isOn: true);\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "SERVER_Peacekeeper",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretRotate",
    "fullName": "OnTurretRotate",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void FlipAim(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!IsOnline() && IsAuthed(rpc.player) && !booting)\r\n\t{\r\n\t\tbase.transform.rotation = UnityEngine.Quaternion.LookRotation(-base.transform.forward, base.transform.up);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "FlipAim",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretAuthorize",
    "fullName": "OnTurretAuthorize",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void AddSelfAuthorize(BaseEntity.RPCMessage rpc)\r\n{\r\n\tAddSelfAuthorize(rpc.player);\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "AddSelfAuthorize",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretAssign",
    "fullName": "OnTurretAssign",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void AssignToFriend(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tulong num = msg.read.UInt64();\r\n\tif (num != 0L && !IsAuthed(num))\r\n\t{\r\n\t\tstring username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);\r\n\t\tProtoBuf.PlayerNameID playerNameID = new ProtoBuf.PlayerNameID();\r\n\t\tplayerNameID.userid = num;\r\n\t\tplayerNameID.username = username;\r\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, System.Linq.Enumerable.Select(authorizedPlayers, (ProtoBuf.PlayerNameID x) => x.userid), \"added\", num);\r\n\t\tauthorizedPlayers.Add(playerNameID);\r\n\t\tUpdateMaxAuthCapacity();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "AssignToFriend",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretAssigned",
    "fullName": "OnTurretAssigned",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void AssignToFriend(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tulong num = msg.read.UInt64();\r\n\tif (num != 0L && !IsAuthed(num))\r\n\t{\r\n\t\tstring username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);\r\n\t\tProtoBuf.PlayerNameID playerNameID = new ProtoBuf.PlayerNameID();\r\n\t\tplayerNameID.userid = num;\r\n\t\tplayerNameID.username = username;\r\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, System.Linq.Enumerable.Select(authorizedPlayers, (ProtoBuf.PlayerNameID x) => x.userid), \"added\", num);\r\n\t\tauthorizedPlayers.Add(playerNameID);\r\n\t\tUpdateMaxAuthCapacity();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "AssignToFriend",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnInterferenceUpdate",
    "fullName": "OnInterferenceUpdate",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateInterference()\r\n{\r\n\tif (!IsOn())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 0f;\r\n\tforeach (AutoTurret nearbyTurret in nearbyTurrets)\r\n\t{\r\n\t\tif (!nearbyTurret.isClient && nearbyTurret.IsValid() && nearbyTurret.gameObject.activeSelf && !nearbyTurret.EqualNetID(net.ID) && nearbyTurret.IsOn() && !nearbyTurret.HasInterference())\r\n\t\t{\r\n\t\t\tnum += 1f;\r\n\t\t}\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.OnFire, num >= (float)ConVar.Sentry.maxinterference);\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "UpdateInterference",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnInterferenceOthersUpdate",
    "fullName": "OnInterferenceOthersUpdate",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateInterferenceOnOthers()\r\n{\r\n\tforeach (AutoTurret nearbyTurret in nearbyTurrets)\r\n\t{\r\n\t\tif (nearbyTurret != null)\r\n\t\t{\r\n\t\t\tnearbyTurret.TryRegisterForInterferenceUpdate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "UpdateInterferenceOnOthers",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretModeToggle",
    "fullName": "OnTurretModeToggle [AttackAll]",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_AttackAll(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (IsAuthed(rpc.player))\r\n\t{\r\n\t\tSetPeacekeepermode(isOn: false);\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "SERVER_AttackAll",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTurretIdentifierSet",
    "fullName": "OnTurretIdentifierSet",
    "category": "Turret",
    "parameters": [
      {
        "name": "autoTurret",
        "type": "AutoTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void Server_SetID(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player == null || !CanChangeID(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String();\r\n\tif (string.IsNullOrEmpty(text) || ComputerStation.IsValidIdentifier(text))\r\n\t{\r\n\t\tstring text2 = msg.read.String();\r\n\t\tif (ComputerStation.IsValidIdentifier(text2) && text == GetIdentifier())\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.Log(\"SetID success!\");\r\n\t\t\tUpdateIdentifier(text2);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "Server_SetID",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnNearbyTurretsScan",
    "fullName": "OnNearbyTurretsScan",
    "category": "Turret",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateNearbyTurrets(bool created)\r\n{\r\n\tSystem.Collections.Generic.List<AutoTurret> obj = Facepunch.Pool.Get<System.Collections.Generic.List<AutoTurret>>();\r\n\tVis.Entities(base.transform.position, ConVar.Sentry.interferenceradius, obj, 256, UnityEngine.QueryTriggerInteraction.Ignore);\r\n\tforeach (AutoTurret item in obj)\r\n\t{\r\n\t\tif (!(item == this))\r\n\t\t{\r\n\t\t\tif (created)\r\n\t\t\t{\r\n\t\t\t\tnearbyTurrets.Add(item);\r\n\t\t\t\titem.nearbyTurrets.Add(this);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\titem.nearbyTurrets.Remove(this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (!created)\r\n\t{\r\n\t\tnearbyTurrets.Clear();\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "UpdateNearbyTurrets",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnHelicopterTarget",
    "fullName": "OnHelicopterTarget",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "helicopterTurret",
        "type": "HelicopterTurret, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetTarget(BaseCombatEntity newTarget)\r\n{\r\n\t_target = newTarget;\r\n\tUpdateTargetVisibility();\r\n}\r\n",
    "targetName": "HelicopterTurret",
    "methodName": "SetTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanHelicopterStrafeTarget",
    "fullName": "CanHelicopterStrafeTarget",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "patrolHelicopterAI",
        "type": "PatrolHelicopterAI, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool ValidRocketTarget(BasePlayer ply)\r\n{\r\n\tif (ply == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn !ply.IsNearEnemyBase();\r\n}\r\n",
    "targetName": "PatrolHelicopterAI",
    "methodName": "ValidRocketTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanHelicopterUseNapalm",
    "fullName": "CanHelicopterUseNapalm",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "patrolHelicopterAI",
        "type": "PatrolHelicopterAI, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanUseNapalm()\r\n{\r\n\treturn UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= UnityEngine.Random.Range(25f, 35f);\r\n}\r\n",
    "targetName": "PatrolHelicopterAI",
    "methodName": "CanUseNapalm",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanHelicopterStrafe",
    "fullName": "CanHelicopterStrafe",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "patrolHelicopterAI",
        "type": "PatrolHelicopterAI, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanStrafe()\r\n{\r\n\tif (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= UnityEngine.Random.Range(15f, 25f))\r\n\t{\r\n\t\treturn CanInterruptState();\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "PatrolHelicopterAI",
    "methodName": "CanStrafe",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanHelicopterTarget",
    "fullName": "CanHelicopterTarget",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "patrolHelicopterAI",
        "type": "PatrolHelicopterAI, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "ply",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool PlayerVisible(BasePlayer ply)\r\n{\r\n\tusing (TimeWarning.New(\"PatrolHelicoperAI.PlayerVisible\"))\r\n\t{\r\n\t\tUnityEngine.Vector3 position = ply.eyes.position;\r\n\t\tif (ply.eyes.position.y < WaterSystem.OceanLevel && UnityEngine.Mathf.Abs(WaterSystem.OceanLevel - ply.eyes.position.y) > oceanDepthTargetCutoff)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (TOD_Sky.Instance.IsNight && UnityEngine.Vector3.Distance(position, interestZoneOrigin) > 40f)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tUnityEngine.Vector3 vector = base.transform.position - UnityEngine.Vector3.up * 6f;\r\n\t\tfloat num = UnityEngine.Vector3.Distance(position, vector);\r\n\t\tUnityEngine.Vector3 normalized = (position - vector).normalized;\r\n\t\tif (GamePhysics.Trace(new UnityEngine.Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && UnityEngine.GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n",
    "targetName": "PatrolHelicopterAI",
    "methodName": "PlayerVisible",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnHelicopterStrafeEnter",
    "fullName": "OnHelicopterStrafeEnter",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "patrolHelicopterAI",
        "type": "PatrolHelicopterAI, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "position",
        "type": "UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "strafeTarget",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm = false)\r\n{\r\n\tstrafe_target = strafeTarget;\r\n\tget_out_of_strafe_distance = UnityEngine.Random.Range(13f, 17f);\r\n\tif (CanUseNapalm() && shouldUseNapalm)\r\n\t{\r\n\t\tpassNapalm = shouldUseNapalm;\r\n\t\tuseNapalm = true;\r\n\t\tlastNapalmTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t}\r\n\tlastStrafeTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t_currentState = PatrolHelicopterAI.aiState.STRAFE;\r\n\tRefreshTargetPosition();\r\n\tnumRocketsLeft = 12 + UnityEngine.Random.Range(-1, 1);\r\n\tlastRocketTime = 0f;\r\n\tmovementLockingAiming = true;\r\n\tUnityEngine.Vector3 randomOffset = GetRandomOffset(strafe_target_position, 175f, 192.5f);\r\n\tSetTargetDestination(randomOffset, 10f);\r\n\tSetIdealRotation(GetYawRotationTo(randomOffset));\r\n\tputtingDistance = true;\r\n}\r\n",
    "targetName": "PatrolHelicopterAI",
    "methodName": "StartStrafe",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnHelicopterRetire",
    "fullName": "OnHelicopterRetire",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "patrolHelicopterAI",
        "type": "PatrolHelicopterAI, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Retire()\r\n{\r\n\tif (!isRetiring)\r\n\t{\r\n\t\tInvoke(DestroyMe, 240f);\r\n\t\tfloat x = TerrainMeta.Size.x;\r\n\t\tfloat y = 200f;\r\n\t\tUnityEngine.Vector3 newPos = UnityEngine.Vector3Ex.Range(-1f, 1f);\r\n\t\tnewPos.y = 0f;\r\n\t\tnewPos.Normalize();\r\n\t\tnewPos *= x * 20f;\r\n\t\tnewPos.y = y;\r\n\t\tExitCurrentState();\r\n\t\tisRetiring = true;\r\n\t\tState_Move_Enter(newPos);\r\n\t}\r\n}\r\n",
    "targetName": "PatrolHelicopterAI",
    "methodName": "Retire",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanBradleyApcTarget",
    "fullName": "CanBradleyApcTarget",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "bradleyAPC",
        "type": "BradleyAPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool VisibilityTest(BaseEntity ent)\r\n{\r\n\tif (ent == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!(UnityEngine.Vector3.Distance(ent.transform.position, base.transform.position) < viewDistance))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tbool flag = false;\r\n\tif (ent is BasePlayer)\r\n\t{\r\n\t\tBasePlayer basePlayer = ent as BasePlayer;\r\n\t\tUnityEngine.Vector3 position = mainTurret.transform.position;\r\n\t\tflag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position + UnityEngine.Vector3.up * 0.1f, position);\r\n\t\tif (!flag && basePlayer.isMounted && basePlayer.GetMounted().VehicleParent() != null && basePlayer.GetMounted().VehicleParent().AlwaysAllowBradleyTargeting)\r\n\t\t{\r\n\t\t\tflag = IsVisible(basePlayer.GetMounted().VehicleParent().bounds.center, position);\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tflag = !UnityEngine.Physics.SphereCast(new UnityEngine.Ray(position, UnityEngine.Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, UnityEngine.Vector3.Distance(basePlayer.eyes.position, position), 10551297);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Standard vis test!\");\r\n\t\tflag = IsVisible(ent.CenterPoint());\r\n\t}\r\n\treturn flag;\r\n}\r\n",
    "targetName": "BradleyAPC",
    "methodName": "VisibilityTest",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnBradleyApcInitialize",
    "fullName": "OnBradleyApcInitialize",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "bradleyAPC",
        "type": "BradleyAPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Initialize()\r\n{\r\n\tmyRigidBody.centerOfMass = centerOfMass.localPosition;\r\n\tdestination = base.transform.position;\r\n\tfinalDestination = base.transform.position;\r\n}\r\n",
    "targetName": "BradleyAPC",
    "methodName": "Initialize",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBradleyApcHunt",
    "fullName": "OnBradleyApcHunt",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "bradleyAPC",
        "type": "BradleyAPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateMovement_Hunt()\r\n{\r\n\tif (patrolPath == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBradleyAPC.TargetInfo targetInfo = targetList[0];\r\n\tif (!targetInfo.IsValid())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (HasPath() && targetInfo.IsVisible())\r\n\t{\r\n\t\tif (currentPath.Count > 1)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 item = currentPath[currentPathIndex];\r\n\t\t\tClearPath();\r\n\t\t\tcurrentPath.Add(item);\r\n\t\t\tfinalDestination = item;\r\n\t\t\tcurrentPathIndex = 0;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag = false;\r\n\t\tIAIPathNode start = patrolPath.GetClosestToPoint(base.transform.position);\r\n\t\tSystem.Collections.Generic.List<IAIPathNode> nodes = Facepunch.Pool.Get<System.Collections.Generic.List<IAIPathNode>>();\r\n\t\tif (GetEngagementPath(ref nodes))\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t\tstart = nodes[nodes.Count - 1];\r\n\t\t}\r\n\t\tIAIPathNode iAIPathNode = null;\r\n\t\tSystem.Collections.Generic.List<IAIPathNode> nearNodes = Facepunch.Pool.Get<System.Collections.Generic.List<IAIPathNode>>();\r\n\t\tpatrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);\r\n\t\tSystem.Collections.Generic.Stack<IAIPathNode> stack = null;\r\n\t\tfloat num = float.PositiveInfinity;\r\n\t\tfloat y = mainTurretEyePos.localPosition.y;\r\n\t\tforeach (IAIPathNode item2 in nearNodes)\r\n\t\t{\r\n\t\t\tSystem.Collections.Generic.Stack<IAIPathNode> path = new System.Collections.Generic.Stack<IAIPathNode>();\r\n\t\t\tif (targetInfo.entity.IsVisible(item2.Position + new UnityEngine.Vector3(0f, y, 0f)) && Rust.Ai.AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)\r\n\t\t\t{\r\n\t\t\t\tstack = path;\r\n\t\t\t\tnum = pathCost;\r\n\t\t\t\tiAIPathNode = item2;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (stack == null && nearNodes.Count > 0)\r\n\t\t{\r\n\t\t\tSystem.Collections.Generic.Stack<IAIPathNode> path2 = new System.Collections.Generic.Stack<IAIPathNode>();\r\n\t\t\tIAIPathNode iAIPathNode2 = nearNodes[UnityEngine.Random.Range(0, nearNodes.Count)];\r\n\t\t\tif (Rust.Ai.AStarPath.FindPath(start, iAIPathNode2, out path2, out var pathCost2) && pathCost2 < num)\r\n\t\t\t{\r\n\t\t\t\tstack = path2;\r\n\t\t\t\tiAIPathNode = iAIPathNode2;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (stack != null)\r\n\t\t{\r\n\t\t\tcurrentPath.Clear();\r\n\t\t\tif (flag)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < nodes.Count - 1; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tcurrentPath.Add(nodes[i].Position);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tforeach (IAIPathNode item3 in stack)\r\n\t\t\t{\r\n\t\t\t\tcurrentPath.Add(item3.Position);\r\n\t\t\t}\r\n\t\t\tcurrentPathIndex = -1;\r\n\t\t\tpathLooping = false;\r\n\t\t\tfinalDestination = iAIPathNode.Position;\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref nearNodes);\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref nodes);\r\n\t\tnextEngagementPathTime = UnityEngine.Time.time + 5f;\r\n\t}\r\n}\r\n",
    "targetName": "BradleyAPC",
    "methodName": "UpdateMovement_Hunt",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBradleyApcPatrol",
    "fullName": "OnBradleyApcPatrol",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "bradleyAPC",
        "type": "BradleyAPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateMovement_Patrol()\r\n{\r\n\tif (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tnextPatrolTime = UnityEngine.Time.time + 20f;\r\n\tif (HasPath() && !IsAtFinalDestination())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIAIPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);\r\n\tIAIPathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);\r\n\tbool flag = false;\r\n\tSystem.Collections.Generic.List<IAIPathNode> nodes = Facepunch.Pool.Get<System.Collections.Generic.List<IAIPathNode>>();\r\n\tIAIPathNode iAIPathNode;\r\n\tif (GetEngagementPath(ref nodes))\r\n\t{\r\n\t\tflag = true;\r\n\t\tiAIPathNode = nodes[nodes.Count - 1];\r\n\t}\r\n\telse\r\n\t{\r\n\t\tiAIPathNode = patrolPath.GetClosestToPoint(base.transform.position);\r\n\t}\r\n\tif (!(UnityEngine.Vector3.Distance(finalDestination, closestToPoint.Position) > 2f))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (closestToPoint == iAIPathNode)\r\n\t{\r\n\t\tcurrentPath.Clear();\r\n\t\tcurrentPath.Add(closestToPoint.Position);\r\n\t\tcurrentPathIndex = -1;\r\n\t\tpathLooping = false;\r\n\t\tfinalDestination = closestToPoint.Position;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!Rust.Ai.AStarPath.FindPath(iAIPathNode, closestToPoint, out var path, out var _))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcurrentPath.Clear();\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < nodes.Count - 1; i++)\r\n\t\t\t{\r\n\t\t\t\tcurrentPath.Add(nodes[i].Position);\r\n\t\t\t}\r\n\t\t}\r\n\t\tforeach (IAIPathNode item in path)\r\n\t\t{\r\n\t\t\tcurrentPath.Add(item.Position);\r\n\t\t}\r\n\t\tcurrentPathIndex = -1;\r\n\t\tpathLooping = false;\r\n\t\tfinalDestination = closestToPoint.Position;\r\n\t}\r\n}\r\n",
    "targetName": "BradleyAPC",
    "methodName": "UpdateMovement_Patrol",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBradleyApcThink",
    "fullName": "OnBradleyApcThink",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "bradleyAPC",
        "type": "BradleyAPC, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoSimpleAI()\r\n{\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.Reserved5, TOD_Sky.Instance.IsNight);\r\n\tif (!DoAI)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSetTarget();\r\n\tif (mountingScientists || inDeployedState)\r\n\t{\r\n\t\tClearPath();\r\n\t}\r\n\telse if (!IsOnSpline())\r\n\t{\r\n\t\tif (targetList.Count > 0)\r\n\t\t{\r\n\t\t\tUpdateMovement_Hunt();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tUpdateMovement_Patrol();\r\n\t\t}\r\n\t}\r\n\tif (!IsOnSpline())\r\n\t{\r\n\t\tAdvancePathMovement(force: false);\r\n\t\tfloat num = UnityEngine.Vector3.Distance(base.transform.position, destination);\r\n\t\tfloat value = UnityEngine.Vector3.Distance(base.transform.position, finalDestination);\r\n\t\tif (num > stoppingDist)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 lhs = Direction2D(destination, base.transform.position);\r\n\t\t\tfloat num2 = UnityEngine.Vector3.Dot(lhs, base.transform.right);\r\n\t\t\tfloat num3 = UnityEngine.Vector3.Dot(lhs, base.transform.right);\r\n\t\t\tfloat num4 = UnityEngine.Vector3.Dot(lhs, -base.transform.right);\r\n\t\t\tif (UnityEngine.Vector3.Dot(lhs, -base.transform.forward) > num2)\r\n\t\t\t{\r\n\t\t\t\tif (num3 >= num4)\r\n\t\t\t\t{\r\n\t\t\t\t\tturning = 1f;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tturning = -1f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tturning = UnityEngine.Mathf.Clamp(num2 * 3f, -1f, 1f);\r\n\t\t\t}\r\n\t\t\tfloat throttleScaleFromTurn = 1f - UnityEngine.Mathf.InverseLerp(0f, 0.3f, UnityEngine.Mathf.Abs(turning));\r\n\t\t\tAvoidObstacles(ref throttleScaleFromTurn);\r\n\t\t\tfloat num5 = UnityEngine.Vector3.Dot(myRigidBody.velocity, base.transform.forward);\r\n\t\t\tif (!(throttle > 0f) || !(num5 < 0.5f))\r\n\t\t\t{\r\n\t\t\t\ttimeSinceSeemingStuck = 0f;\r\n\t\t\t}\r\n\t\t\telse if ((float)timeSinceSeemingStuck > 10f)\r\n\t\t\t{\r\n\t\t\t\ttimeSinceStuckReverseStart = 0f;\r\n\t\t\t\ttimeSinceSeemingStuck = 0f;\r\n\t\t\t}\r\n\t\t\tfloat num6 = UnityEngine.Mathf.InverseLerp(0.1f, 0.4f, UnityEngine.Vector3.Dot(base.transform.forward, UnityEngine.Vector3.up));\r\n\t\t\tif ((float)timeSinceStuckReverseStart < 3f)\r\n\t\t\t{\r\n\t\t\t\tthrottle = -0.75f;\r\n\t\t\t\tturning = 1f;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthrottle = (0.1f + UnityEngine.Mathf.InverseLerp(0f, 20f, value) * 1f) * throttleScaleFromTurn + num6;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tDoWeaponAiming();\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "BradleyAPC",
    "methodName": "DoSimpleAI",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanHelicopterDropCrate",
    "fullName": "CanHelicopterDropCrate",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "cH47HelicopterAIController",
        "type": "CH47HelicopterAIController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanDropCrate()\r\n{\r\n\treturn numCrates > 0;\r\n}\r\n",
    "targetName": "CH47HelicopterAIController",
    "methodName": "CanDropCrate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnHelicopterDropCrate",
    "fullName": "OnHelicopterDropCrate",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "cH47HelicopterAIController",
        "type": "CH47HelicopterAIController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DropCrate()\r\n{\r\n\tif (numCrates > 0)\r\n\t{\r\n\t\tUnityEngine.Vector3 pos = base.transform.position + UnityEngine.Vector3.down * 5f;\r\n\t\tUnityEngine.Quaternion rot = UnityEngine.Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.SendMessage(\"SetWasDropped\");\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t\tnumCrates--;\r\n\t}\r\n}\r\n",
    "targetName": "CH47HelicopterAIController",
    "methodName": "DropCrate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnHelicopterAttack",
    "fullName": "OnHelicopterAttack",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "cH47HelicopterAIController",
        "type": "CH47HelicopterAIController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnAttacked(HitInfo info)\r\n{\r\n\tbase.OnAttacked(info);\r\n\tInitiateAnger();\r\n\tSetFlag(BaseEntity.Flags.Reserved9, base.healthFraction <= 0.8f);\r\n\tSetFlag(BaseEntity.Flags.OnFire, base.healthFraction <= 0.33f);\r\n}\r\n",
    "targetName": "CH47HelicopterAIController",
    "methodName": "OnAttacked",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnHelicopterOutOfCrates",
    "fullName": "OnHelicopterOutOfCrates",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "cH47HelicopterAIController",
        "type": "CH47HelicopterAIController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool OutOfCrates()\r\n{\r\n\treturn numCrates <= 0;\r\n}\r\n",
    "targetName": "CH47HelicopterAIController",
    "methodName": "OutOfCrates",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnHelicopterDropDoorOpen",
    "fullName": "OnHelicopterDropDoorOpen",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "cH47HelicopterAIController",
        "type": "CH47HelicopterAIController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetDropDoorOpen(bool open)\r\n{\r\n\tSetFlag(BaseEntity.Flags.Reserved8, open);\r\n}\r\n",
    "targetName": "CH47HelicopterAIController",
    "methodName": "SetDropDoorOpen",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanUseHelicopter",
    "fullName": "CanUseHelicopter",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "cH47HelicopterAIController",
        "type": "CH47HelicopterAIController, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void AttemptMount(BasePlayer player, bool doMountChecks = true)\r\n{\r\n\tif (player.IsNpc || player.IsAdmin)\r\n\t{\r\n\t\tbase.AttemptMount(player, doMountChecks);\r\n\t}\r\n}\r\n",
    "targetName": "CH47HelicopterAIController",
    "methodName": "AttemptMount",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBoatPathGenerate",
    "fullName": "OnBoatPathGenerate",
    "category": "Vehicle",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static System.Collections.Generic.List<UnityEngine.Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)\r\n{\r\n\tfloat x = TerrainMeta.Size.x;\r\n\tfloat num = x * 2f * System.MathF.PI;\r\n\tfloat num2 = 30f;\r\n\tint num3 = UnityEngine.Mathf.CeilToInt(num / num2);\r\n\tSystem.Collections.Generic.List<UnityEngine.Vector3> list = new System.Collections.Generic.List<UnityEngine.Vector3>();\r\n\tfloat num4 = x;\r\n\tfloat y = 0f;\r\n\tfor (int i = 0; i < num3; i++)\r\n\t{\r\n\t\tfloat num5 = (float)i / (float)num3 * 360f;\r\n\t\tlist.Add(new UnityEngine.Vector3(UnityEngine.Mathf.Sin(num5 * (System.MathF.PI / 180f)) * num4, y, UnityEngine.Mathf.Cos(num5 * (System.MathF.PI / 180f)) * num4));\r\n\t}\r\n\tfloat num6 = 4f;\r\n\tfloat num7 = 200f;\r\n\tbool flag = true;\r\n\tfor (int j = 0; j < ConVar.AI.ocean_patrol_path_iterations && flag; j++)\r\n\t{\r\n\t\tflag = false;\r\n\t\tfor (int k = 0; k < num3; k++)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 vector = list[k];\r\n\t\t\tint index = ((k == 0) ? (num3 - 1) : (k - 1));\r\n\t\t\tint index2 = ((k != num3 - 1) ? (k + 1) : 0);\r\n\t\t\tUnityEngine.Vector3 b = list[index2];\r\n\t\t\tUnityEngine.Vector3 b2 = list[index];\r\n\t\t\tUnityEngine.Vector3 origin = vector;\r\n\t\t\tUnityEngine.Vector3 normalized = (UnityEngine.Vector3.zero - vector).normalized;\r\n\t\t\tUnityEngine.Vector3 vector2 = vector + normalized * num6;\r\n\t\t\tif (UnityEngine.Vector3.Distance(vector2, b) > num7 || UnityEngine.Vector3.Distance(vector2, b2) > num7)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tbool flag2 = true;\r\n\t\t\tint num8 = 16;\r\n\t\t\tfor (int l = 0; l < num8; l++)\r\n\t\t\t{\r\n\t\t\t\tfloat num9 = (float)l / (float)num8 * 360f;\r\n\t\t\t\tUnityEngine.Vector3 normalized2 = new UnityEngine.Vector3(UnityEngine.Mathf.Sin(num9 * (System.MathF.PI / 180f)), y, UnityEngine.Mathf.Cos(num9 * (System.MathF.PI / 180f))).normalized;\r\n\t\t\t\tUnityEngine.Vector3 vector3 = vector2 + normalized2 * 1f;\r\n\t\t\t\tUnityEngine.Vector3 direction = normalized;\r\n\t\t\t\tif (vector3 != UnityEngine.Vector3.zero)\r\n\t\t\t\t{\r\n\t\t\t\t\tdirection = (vector3 - vector2).normalized;\r\n\t\t\t\t}\r\n\t\t\t\tif (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1084293377))\r\n\t\t\t\t{\r\n\t\t\t\t\tflag2 = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (flag2)\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t\tlist[k] = vector2;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Failed to generate ocean patrol path\");\r\n\t\treturn null;\r\n\t}\r\n\tSystem.Collections.Generic.List<int> list2 = new System.Collections.Generic.List<int>();\r\n\tUnityEngine.LineUtility.Simplify(list, 5f, list2);\r\n\tSystem.Collections.Generic.List<UnityEngine.Vector3> list3 = list;\r\n\tlist = new System.Collections.Generic.List<UnityEngine.Vector3>();\r\n\tforeach (int item in list2)\r\n\t{\r\n\t\tlist.Add(list3[item]);\r\n\t}\r\n\tUnityEngine.Debug.Log(\"Generated ocean patrol path with node count: \" + list.Count);\r\n\treturn list;\r\n}\r\n",
    "targetName": "BaseBoat",
    "methodName": "GenerateOceanPatrolPath",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Collections.Generic.List`1[[UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]"
  },
  {
    "name": "OnVehiclePush",
    "fullName": "OnVehiclePush",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "baseVehicle",
        "type": "BaseVehicle, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(5f)]\r\npublic void RPC_WantsPush(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!player.isMounted && !RecentlyPushed && CanPushNow(player) && !(rigidBody == null) && (!OnlyOwnerAccessible() || !(player != creatorEntity)))\r\n\t{\r\n\t\tplayer.metabolism.calories.Subtract(3f);\r\n\t\tplayer.metabolism.SendChangesToClient();\r\n\t\tif (rigidBody.IsSleeping())\r\n\t\t{\r\n\t\t\trigidBody.WakeUp();\r\n\t\t}\r\n\t\tDoPushAction(player);\r\n\t\ttimeSinceLastPush = 0f;\r\n\t}\r\n}\r\n",
    "targetName": "BaseVehicle",
    "methodName": "RPC_WantsPush",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEngineStatsRefresh",
    "fullName": "OnEngineStatsRefresh",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "vehicleModuleEngine",
        "type": "VehicleModuleEngine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "engineStorage",
        "type": "Rust.Modular.EngineStorage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RefreshPerformanceStats(Rust.Modular.EngineStorage engineStorage)\r\n{\r\n\tif (engineStorage == null)\r\n\t{\r\n\t\tIsUsable = false;\r\n\t\tPerformanceFractionAcceleration = 0f;\r\n\t\tPerformanceFractionTopSpeed = 0f;\r\n\t\tPerformanceFractionFuelEconomy = 0f;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tIsUsable = engineStorage.isUsable;\r\n\t\tPerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);\r\n\t\tPerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);\r\n\t\tPerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);\r\n\t}\r\n\tOverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;\r\n}\r\n",
    "targetName": "VehicleModuleEngine",
    "methodName": "RefreshPerformanceStats",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEngineStatsRefreshed",
    "fullName": "OnEngineStatsRefreshed",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "vehicleModuleEngine",
        "type": "VehicleModuleEngine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "engineStorage",
        "type": "Rust.Modular.EngineStorage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RefreshPerformanceStats(Rust.Modular.EngineStorage engineStorage)\r\n{\r\n\tif (engineStorage == null)\r\n\t{\r\n\t\tIsUsable = false;\r\n\t\tPerformanceFractionAcceleration = 0f;\r\n\t\tPerformanceFractionTopSpeed = 0f;\r\n\t\tPerformanceFractionFuelEconomy = 0f;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tIsUsable = engineStorage.isUsable;\r\n\t\tPerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);\r\n\t\tPerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);\r\n\t\tPerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);\r\n\t}\r\n\tOverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;\r\n}\r\n",
    "targetName": "VehicleModuleEngine",
    "methodName": "RefreshPerformanceStats",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnVehicleModulesAssign",
    "fullName": "OnVehicleModulesAssign",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "modularCar",
        "type": "ModularCar, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "socketItemDefs",
        "type": "Rust.Modular.ItemModVehicleModule[], Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SpawnPreassignedModules()\r\n{\r\n\tif (!spawnSettings.useSpawnSettings || spawnSettings.configurationOptions.IsNullOrEmpty())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];\r\n\tfor (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)\r\n\t{\r\n\t\tRust.Modular.ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];\r\n\t\tif (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);\r\n\t\t\tfloat num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);\r\n\t\t\titem.condition = item.maxCondition * num;\r\n\t\t\tif (!TryAddModule(item))\r\n\t\t\t{\r\n\t\t\t\titem.Remove();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tInvoke(HandleAdminBonus, 0f);\r\n}\r\n",
    "targetName": "ModularCar",
    "methodName": "SpawnPreassignedModules",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnVehicleModulesAssigned",
    "fullName": "OnVehicleModulesAssigned",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "modularCar",
        "type": "ModularCar, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "socketItemDefs",
        "type": "Rust.Modular.ItemModVehicleModule[], Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SpawnPreassignedModules()\r\n{\r\n\tif (!spawnSettings.useSpawnSettings || spawnSettings.configurationOptions.IsNullOrEmpty())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];\r\n\tfor (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)\r\n\t{\r\n\t\tRust.Modular.ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];\r\n\t\tif (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);\r\n\t\t\tfloat num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);\r\n\t\t\titem.condition = item.maxCondition * num;\r\n\t\t\tif (!TryAddModule(item))\r\n\t\t\t{\r\n\t\t\t\titem.Remove();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tInvoke(HandleAdminBonus, 0f);\r\n}\r\n",
    "targetName": "ModularCar",
    "methodName": "SpawnPreassignedModules",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanDestroyLock",
    "fullName": "CanDestroyLock",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "modularCar",
        "type": "ModularCar, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "viaModule",
        "type": "BaseVehicleModule, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)\r\n{\r\n\treturn CarLock.PlayerCanDestroyLock(viaModule);\r\n}\r\n",
    "targetName": "ModularCar",
    "methodName": "PlayerCanDestroyLock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnVehicleModuleSelect",
    "fullName": "OnVehicleModuleSelect",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "local2",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "modularCarGarage",
        "type": "ModularCarGarage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_SelectedLootItem(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tItemId itemUID = msg.read.ItemID();\r\n\tif (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem vehicleItem = carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = player.inventory.loot.RemoveContainerAt(3);\r\n\tif (TryGetModuleForItem(vehicleItem, out var result))\r\n\t{\r\n\t\tif (result is VehicleModuleStorage vehicleModuleStorage)\r\n\t\t{\r\n\t\t\tIItemContainerEntity container = vehicleModuleStorage.GetContainer();\r\n\t\t\tif (!container.IsUnityNull())\r\n\t\t\t{\r\n\t\t\t\tplayer.inventory.loot.AddContainer(container.inventory);\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (result is VehicleModuleCamper vehicleModuleCamper)\r\n\t\t{\r\n\t\t\tIItemContainerEntity container2 = vehicleModuleCamper.GetContainer();\r\n\t\t\tif (!container2.IsUnityNull())\r\n\t\t\t{\r\n\t\t\t\tplayer.inventory.loot.AddContainer(container2.inventory);\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "ModularCarGarage",
    "methodName": "RPC_SelectedLootItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnVehicleModuleSelected",
    "fullName": "OnVehicleModuleSelected",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "local2",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "modularCarGarage",
        "type": "ModularCarGarage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_SelectedLootItem(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tItemId itemUID = msg.read.ItemID();\r\n\tif (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem vehicleItem = carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = player.inventory.loot.RemoveContainerAt(3);\r\n\tif (TryGetModuleForItem(vehicleItem, out var result))\r\n\t{\r\n\t\tif (result is VehicleModuleStorage vehicleModuleStorage)\r\n\t\t{\r\n\t\t\tIItemContainerEntity container = vehicleModuleStorage.GetContainer();\r\n\t\t\tif (!container.IsUnityNull())\r\n\t\t\t{\r\n\t\t\t\tplayer.inventory.loot.AddContainer(container.inventory);\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (result is VehicleModuleCamper vehicleModuleCamper)\r\n\t\t{\r\n\t\t\tIItemContainerEntity container2 = vehicleModuleCamper.GetContainer();\r\n\t\t\tif (!container2.IsUnityNull())\r\n\t\t\t{\r\n\t\t\t\tplayer.inventory.loot.AddContainer(container2.inventory);\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "ModularCarGarage",
    "methodName": "RPC_SelectedLootItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnVehicleModuleDeselected",
    "fullName": "OnVehicleModuleDeselected",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "modularCarGarage",
        "type": "ModularCarGarage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_DeselectedLootItem(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (player.inventory.loot.IsLooting() && !(player.inventory.loot.entitySource != this) && player.inventory.loot.RemoveContainerAt(3))\r\n\t{\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "ModularCarGarage",
    "methodName": "RPC_DeselectedLootItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnVehicleLockRequest",
    "fullName": "OnVehicleLockRequest",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "modularCarGarage",
        "type": "ModularCarGarage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_RequestAddLock(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!HasOccupant || carOccupant.CarLock.HasALock)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null))\r\n\t{\r\n\t\tstring code = msg.read.String();\r\n\t\tItemAmount itemAmount = lockResourceCost;\r\n\t\tif ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && carOccupant.CarLock.TryAddALock(code, player.userID))\r\n\t\t{\r\n\t\t\tplayer.inventory.Take(null, itemAmount.itemDef.itemid, UnityEngine.Mathf.CeilToInt(itemAmount.amount));\r\n\t\t\tEffect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ModularCarGarage",
    "methodName": "RPC_RequestAddLock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLockRemove",
    "fullName": "OnLockRemove",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "modularCarGarage",
        "type": "ModularCarGarage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_RequestRemoveLock(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (HasOccupant && carOccupant.CarLock.HasALock)\r\n\t{\r\n\t\tcarOccupant.CarLock.RemoveLock();\r\n\t\tEffect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t}\r\n}\r\n",
    "targetName": "ModularCarGarage",
    "methodName": "RPC_RequestRemoveLock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCodeChange",
    "fullName": "OnCodeChange",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "modularCarGarage",
        "type": "ModularCarGarage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_RequestNewCode(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!HasOccupant || !carOccupant.CarLock.HasALock)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null))\r\n\t{\r\n\t\tstring newCode = msg.read.String();\r\n\t\tif (carOccupant.CarLock.TrySetNewCode(newCode, player.userID))\r\n\t\t{\r\n\t\t\tEffect.server.Run(changeLockCodeEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ModularCarGarage",
    "methodName": "RPC_RequestNewCode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnVehicleModuleSelectedFix [patch]",
    "fullName": "OnVehicleModuleSelectedFix [patch]",
    "category": "Vehicle",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_SelectedLootItem(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tItemId itemUID = msg.read.ItemID();\r\n\tif (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem vehicleItem = carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = player.inventory.loot.RemoveContainerAt(3);\r\n\tif (TryGetModuleForItem(vehicleItem, out var result))\r\n\t{\r\n\t\tif (result is VehicleModuleStorage vehicleModuleStorage)\r\n\t\t{\r\n\t\t\tIItemContainerEntity container = vehicleModuleStorage.GetContainer();\r\n\t\t\tif (!container.IsUnityNull())\r\n\t\t\t{\r\n\t\t\t\tplayer.inventory.loot.AddContainer(container.inventory);\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (result is VehicleModuleCamper vehicleModuleCamper)\r\n\t\t{\r\n\t\t\tIItemContainerEntity container2 = vehicleModuleCamper.GetContainer();\r\n\t\t\tif (!container2.IsUnityNull())\r\n\t\t\t{\r\n\t\t\t\tplayer.inventory.loot.AddContainer(container2.inventory);\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "ModularCarGarage",
    "methodName": "RPC_SelectedLootItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnVehicleLockableCheck",
    "fullName": "OnVehicleLockableCheck",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "modularCarCodeLock",
        "type": "ModularCarCodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanHaveALock()\r\n{\r\n\tif (!owner.IsDead())\r\n\t{\r\n\t\treturn owner.HasDriverMountPoints();\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "ModularCarCodeLock",
    "methodName": "CanHaveALock",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanLock",
    "fullName": "CanLock",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "modularCarCodeLock",
        "type": "ModularCarCodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "ModularCarCodeLock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool HasLockPermission(ulong steamId)\r\n{\r\n\tif (!HasALock)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn whitelistPlayers.Contains(steamId);\r\n}\r\n",
    "targetName": "ModularCarCodeLock",
    "methodName": "HasLockPermission",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEngineLoadoutRefresh",
    "fullName": "OnEngineLoadoutRefresh",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "engineStorage",
        "type": "Rust.Modular.EngineStorage, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RefreshLoadoutData()\r\n{\r\n\tisUsable = base.inventory.IsFull() && System.Linq.Enumerable.All(base.inventory.itemList, (Item item) => !item.isBroken);\r\n\taccelerationBoostPercent = GetContainerItemsValueFor(Rust.Modular.EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;\r\n\ttopSpeedBoostPercent = GetContainerItemsValueFor(Rust.Modular.EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;\r\n\tfuelEconomyBoostPercent = GetContainerItemsValueFor(Rust.Modular.EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;\r\n\tSendNetworkUpdate();\r\n\tGetEngineModule()?.RefreshPerformanceStats(this);\r\n}\r\n",
    "targetName": "Rust.Modular.EngineStorage",
    "methodName": "RefreshLoadoutData",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnVehicleModuleMove",
    "fullName": "OnVehicleModuleMove",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "local0",
        "type": "BaseVehicleModule, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "baseModularVehicle",
        "type": "BaseModularVehicle, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanMoveFrom(BasePlayer player, Item item)\r\n{\r\n\tBaseVehicleModule moduleForItem = GetModuleForItem(item);\r\n\tif (moduleForItem != null)\r\n\t{\r\n\t\treturn moduleForItem.CanBeMovedNow();\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "BaseModularVehicle",
    "methodName": "CanMoveFrom",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnMlrsFire",
    "fullName": "OnMlrsFire",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "mLRS",
        "type": "MLRS, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "owner",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Fire(BasePlayer owner)\r\n{\r\n\tUpdateStorageState();\r\n\tif (CanFire && !(GetMounted() == null))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Reserved6, b: true);\r\n\t\tradiusModIndex = 0;\r\n\t\tnextRocketIndex = UnityEngine.Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);\r\n\t\trocketOwnerRef.Set(owner);\r\n\t\tInvokeRepeating(FireNextRocket, 0f, 0.5f);\r\n\t}\r\n}\r\n",
    "targetName": "MLRS",
    "methodName": "Fire",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMlrsFired",
    "fullName": "OnMlrsFired",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "mLRS",
        "type": "MLRS, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "owner",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Fire(BasePlayer owner)\r\n{\r\n\tUpdateStorageState();\r\n\tif (CanFire && !(GetMounted() == null))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Reserved6, b: true);\r\n\t\tradiusModIndex = 0;\r\n\t\tnextRocketIndex = UnityEngine.Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);\r\n\t\trocketOwnerRef.Set(owner);\r\n\t\tInvokeRepeating(FireNextRocket, 0f, 0.5f);\r\n\t}\r\n}\r\n",
    "targetName": "MLRS",
    "methodName": "Fire",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMlrsRocketFired",
    "fullName": "OnMlrsRocketFired",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "mLRS",
        "type": "MLRS, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local7",
        "type": "ServerProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void FireNextRocket()\r\n{\r\n\tRocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount(Rust.AmmoTypes.MLRS_ROCKET);\r\n\tif (nextRocketIndex < 0 || nextRocketIndex >= RocketAmmoCount || IsBroken())\r\n\t{\r\n\t\tEndFiring();\r\n\t\treturn;\r\n\t}\r\n\tStorageContainer rocketContainer = GetRocketContainer();\r\n\tUnityEngine.Vector3 firingPos = firingPoint.position + firingPoint.rotation * rocketTubes[nextRocketIndex].firingOffset;\r\n\tfloat num = 1f;\r\n\tif (radiusModIndex < radiusMods.Length)\r\n\t{\r\n\t\tnum = radiusMods[radiusModIndex];\r\n\t}\r\n\tradiusModIndex++;\r\n\tUnityEngine.Vector2 vector = UnityEngine.Random.insideUnitCircle * (targetAreaRadius - RocketDamageRadius) * num;\r\n\tUnityEngine.Vector3 target = TrueHitPos + new UnityEngine.Vector3(vector.x, 0f, vector.y);\r\n\tfloat requiredGravity;\r\n\tUnityEngine.Vector3 aimToTarget = Ballistics.GetAimToTarget(firingPoint.position, target, rocketSpeed, vRotMax, rocketBaseGravity, minRange, out requiredGravity);\r\n\tif (TryFireProjectile(rocketContainer, Rust.AmmoTypes.MLRS_ROCKET, firingPos, aimToTarget, rocketOwnerRef.Get(serverside: true) as BasePlayer, 0f, 0f, out var projectile))\r\n\t{\r\n\t\tprojectile.gravityModifier = requiredGravity / (0f - UnityEngine.Physics.gravity.y);\r\n\t\tnextRocketIndex--;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tEndFiring();\r\n\t}\r\n}\r\n",
    "targetName": "MLRS",
    "methodName": "FireNextRocket",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMlrsFiringEnded",
    "fullName": "OnMlrsFiringEnded",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "mLRS",
        "type": "MLRS, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void EndFiring()\r\n{\r\n\tCancelInvoke(FireNextRocket);\r\n\trocketOwnerRef.Set(null);\r\n\tif (TryGetAimingModule(out var item))\r\n\t{\r\n\t\titem.LoseCondition(1f);\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.Reserved6, b: false, recursive: false, networkupdate: false);\r\n\tSetFlag(BaseEntity.Flags.Broken, b: true, recursive: false, networkupdate: false);\r\n\tSendNetworkUpdate_Flags();\r\n\ttimeSinceBroken = 0f;\r\n}\r\n",
    "targetName": "MLRS",
    "methodName": "EndFiring",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMlrsTarget",
    "fullName": "OnMlrsTarget",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "mLRS",
        "type": "MLRS, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "worldPos",
        "type": "UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "MLRS, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetUserTargetHitPos(UnityEngine.Vector3 worldPos)\r\n{\r\n\tif (UserTargetHitPos == worldPos)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (base.isServer)\r\n\t{\r\n\t\tUnityEngine.Vector3 position = TerrainMeta.Position;\r\n\t\tUnityEngine.Vector3 vector = position + TerrainMeta.Size;\r\n\t\tworldPos.x = UnityEngine.Mathf.Clamp(worldPos.x, position.x, vector.x);\r\n\t\tworldPos.z = UnityEngine.Mathf.Clamp(worldPos.z, position.z, vector.z);\r\n\t\tworldPos.y = GetSurfaceHeight(worldPos);\r\n\t}\r\n\tUserTargetHitPos = worldPos;\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttrueTargetHitPos = UserTargetHitPos;\r\n\tforeach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)\r\n\t{\r\n\t\tUnityEngine.Vector3 center = allSafeZone.triggerCollider.bounds.center;\r\n\t\tcenter.y = 0f;\r\n\t\tfloat num = UnityEngine.ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;\r\n\t\ttrueTargetHitPos.y = 0f;\r\n\t\tif (UnityEngine.Vector3.Distance(center, trueTargetHitPos) < num)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 vector2 = trueTargetHitPos - center;\r\n\t\t\ttrueTargetHitPos = center + vector2.normalized * num;\r\n\t\t\ttrueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "MLRS",
    "methodName": "SetUserTargetHitPos",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMlrsTargetSet",
    "fullName": "OnMlrsTargetSet",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "mLRS",
        "type": "MLRS, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "MLRS, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self2",
        "type": "MLRS, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetUserTargetHitPos(UnityEngine.Vector3 worldPos)\r\n{\r\n\tif (UserTargetHitPos == worldPos)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (base.isServer)\r\n\t{\r\n\t\tUnityEngine.Vector3 position = TerrainMeta.Position;\r\n\t\tUnityEngine.Vector3 vector = position + TerrainMeta.Size;\r\n\t\tworldPos.x = UnityEngine.Mathf.Clamp(worldPos.x, position.x, vector.x);\r\n\t\tworldPos.z = UnityEngine.Mathf.Clamp(worldPos.z, position.z, vector.z);\r\n\t\tworldPos.y = GetSurfaceHeight(worldPos);\r\n\t}\r\n\tUserTargetHitPos = worldPos;\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttrueTargetHitPos = UserTargetHitPos;\r\n\tforeach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)\r\n\t{\r\n\t\tUnityEngine.Vector3 center = allSafeZone.triggerCollider.bounds.center;\r\n\t\tcenter.y = 0f;\r\n\t\tfloat num = UnityEngine.ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;\r\n\t\ttrueTargetHitPos.y = 0f;\r\n\t\tif (UnityEngine.Vector3.Distance(center, trueTargetHitPos) < num)\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 vector2 = trueTargetHitPos - center;\r\n\t\t\ttrueTargetHitPos = center + vector2.normalized * num;\r\n\t\t\ttrueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "MLRS",
    "methodName": "SetUserTargetHitPos",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTrainCarUncouple",
    "fullName": "OnTrainCarUncouple",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "trainCar",
        "type": "TrainCar, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\npublic void RPC_WantsUncouple(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!(player == null) && !(UnityEngine.Vector3.SqrMagnitude(base.transform.position - player.transform.position) > 200f))\r\n\t{\r\n\t\tbool front = msg.read.Bit();\r\n\t\tcoupling.Uncouple(front);\r\n\t}\r\n}\r\n",
    "targetName": "TrainCar",
    "methodName": "RPC_WantsUncouple",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanTrainCarCouple",
    "fullName": "CanTrainCarCouple",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "trainCoupling",
        "type": "TrainCoupling, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "owner",
        "type": "TrainCar, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool TryCouple(TrainCoupling theirCoupling, bool reflect)\r\n{\r\n\tif (!isValid)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (CoupledTo == theirCoupling)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (IsCoupled)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (reflect && !theirCoupling.TryCouple(this, reflect: false))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tCoupledTo = theirCoupling;\r\n\towner.SetFlag(flag, b: true, recursive: false, networkupdate: false);\r\n\towner.SendNetworkUpdate();\r\n\treturn true;\r\n}\r\n",
    "targetName": "TrainCoupling",
    "methodName": "TryCouple",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnVehicleHornPressed",
    "fullName": "OnVehicleHornPressed",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "vehicleModuleSeating",
        "type": "VehicleModuleSeating, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void PlayerServerInput(InputState inputState, BasePlayer player)\r\n{\r\n\tbase.PlayerServerInput(inputState, player);\r\n\tif (hornLoop != null && IsOnThisModule(player))\r\n\t{\r\n\t\tbool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);\r\n\t\tif (flag != HasFlag(BaseEntity.Flags.Reserved8))\r\n\t\t{\r\n\t\t\tSetFlag(BaseEntity.Flags.Reserved8, flag);\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\thornPlayer = player;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "VehicleModuleSeating",
    "methodName": "PlayerServerInput",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnCupboardAuthorize",
    "fullName": "OnCupboardAuthorize [VehiclePrivilege]",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "vehiclePrivilege",
        "type": "VehiclePrivilege, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void AddSelfAuthorize(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && IsDriver(rpc.player))\r\n\t{\r\n\t\tAddPlayer(rpc.player);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "VehiclePrivilege",
    "methodName": "AddSelfAuthorize",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCupboardDeauthorize",
    "fullName": "OnCupboardDeauthorize [VehiclePrivilege]",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "vehiclePrivilege",
        "type": "VehiclePrivilege, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RemoveSelfAuthorize(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && IsDriver(rpc.player))\r\n\t{\r\n\t\tauthorizedPlayers.RemoveAll((ProtoBuf.PlayerNameID x) => x.userid == (ulong)rpc.player.userID);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, System.Linq.Enumerable.Select(authorizedPlayers, (ProtoBuf.PlayerNameID x) => x.userid), \"removed\", rpc.player.userID);\r\n\t\tUpdateMaxAuthCapacity();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "VehiclePrivilege",
    "methodName": "RemoveSelfAuthorize",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCupboardClearList",
    "fullName": "OnCupboardClearList [VehiclePrivilege]",
    "category": "Vehicle",
    "parameters": [
      {
        "name": "vehiclePrivilege",
        "type": "VehiclePrivilege, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void ClearList(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (rpc.player.CanInteract() && IsDriver(rpc.player))\r\n\t{\r\n\t\tauthorizedPlayers.Clear();\r\n\t\tUpdateMaxAuthCapacity();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "VehiclePrivilege",
    "methodName": "ClearList",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEngineStart",
    "fullName": "OnEngineStart [MotorRowboat]",
    "category": "Vehicle",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void EngineToggle(bool wantsOn)\r\n{\r\n\tif (fuelSystem.HasFuel(forceCheck: true))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.On, wantsOn);\r\n\t\tif (wantsOn)\r\n\t\t{\r\n\t\t\trigidBody.WakeUp();\r\n\t\t\tbuoyancy.Wake();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "MotorRowboat",
    "methodName": "EngineToggle",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEngineStarted",
    "fullName": "OnEngineStarted [MotorRowboat]",
    "category": "Vehicle",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void EngineToggle(bool wantsOn)\r\n{\r\n\tif (fuelSystem.HasFuel(forceCheck: true))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.On, wantsOn);\r\n\t\tif (wantsOn)\r\n\t\t{\r\n\t\t\trigidBody.WakeUp();\r\n\t\t\tbuoyancy.Wake();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "MotorRowboat",
    "methodName": "EngineToggle",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEngineStart",
    "fullName": "OnEngineStart",
    "category": "Vehicle",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "VehicleEngineController`1",
    "methodName": "TryStartEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEngineStarted",
    "fullName": "OnEngineStarted",
    "category": "Vehicle",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "VehicleEngineController`1",
    "methodName": "TryStartEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEngineStop",
    "fullName": "OnEngineStop",
    "category": "Vehicle",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "VehicleEngineController`1",
    "methodName": "StopEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEngineStopped",
    "fullName": "OnEngineStopped",
    "category": "Vehicle",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "VehicleEngineController`1",
    "methodName": "StopEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnEngineStartFinished",
    "fullName": "OnEngineStartFinished",
    "category": "Vehicle",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "VehicleEngineController`1",
    "methodName": "FinishStartingEngine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnBuyVendingItem",
    "fullName": "OnBuyVendingItem",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(5uL)]\r\npublic void BuyItem(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (!OccupiedCheck(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = rpc.read.Int32();\r\n\tint numberOfTransactions = rpc.read.Int32();\r\n\tif (IsVending())\r\n\t{\r\n\t\trpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage, false);\r\n\t\treturn;\r\n\t}\r\n\tint num2 = 0;\r\n\tfor (int i = 0; i < sellOrders.sellOrders.Count; i++)\r\n\t{\r\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].itemToSellID);\r\n\t\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].currencyID);\r\n\t\tif (itemDefinition.IsAllowedInEra(CurrentEraRestriction) && itemDefinition2.IsAllowedInEra(CurrentEraRestriction))\r\n\t\t{\r\n\t\t\tif (num2 == num)\r\n\t\t\t{\r\n\t\t\t\tnum = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tnum2++;\r\n\t\t}\r\n\t}\r\n\tSetPendingOrder(rpc.player, num, numberOfTransactions);\r\n\tInvoke(CompletePendingOrder, GetBuyDuration());\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "BuyItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanUseVending",
    "fullName": "CanUseVending",
    "category": "Vending",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool CanOpenLootPanel(BasePlayer player, string panelName)\r\n{\r\n\tif (panelName == customerPanel)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (base.CanOpenLootPanel(player, panelName))\r\n\t{\r\n\t\treturn CanPlayerAdmin(player);\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "CanOpenLootPanel",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanAdministerVending",
    "fullName": "CanAdministerVending",
    "category": "Vending",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CanPlayerAdmin(BasePlayer player)\r\n{\r\n\tif (PlayerBehind(player))\r\n\t{\r\n\t\treturn OccupiedCheck(player);\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "CanPlayerAdmin",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnRefreshVendingStock",
    "fullName": "OnRefreshVendingStock",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "itemDef",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)\r\n{\r\n\tint num = 0;\r\n\tforeach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)\r\n\t{\r\n\t\tif (!(itemDef == null) && itemDef.itemid != sellOrder.itemToSellID)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tSystem.Collections.Generic.List<Item> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Item>>();\r\n\t\tGetItemsToSell(sellOrder, obj);\r\n\t\tint num2 = sellOrder.itemToSellAmount;\r\n\t\tif (ItemManager.FindItemDefinition(sellOrder.itemToSellID) == NPCVendingMachine.ScrapItem && sellOrder.receivedQuantityMultiplier != 1f)\r\n\t\t{\r\n\t\t\tnum2 = GetTotalPriceForOrder(num2, sellOrder.receivedQuantityMultiplier);\r\n\t\t}\r\n\t\tsellOrder.inStock = ((obj.Count >= 0) ? (System.Linq.Enumerable.Sum(obj, (Item x) => x.amount) / num2) : 0);\r\n\t\tfloat itemCondition = 0f;\r\n\t\tfloat itemConditionMax = 0f;\r\n\t\tint instanceData = 0;\r\n\t\tSystem.Collections.Generic.List<int> list = Facepunch.Pool.Get<System.Collections.Generic.List<int>>();\r\n\t\tint totalAttachmentSlots = 0;\r\n\t\tint ammoType = 0;\r\n\t\tint ammoCount = 0;\r\n\t\tif (obj.Count > 0)\r\n\t\t{\r\n\t\t\tif (obj[0].hasCondition)\r\n\t\t\t{\r\n\t\t\t\titemCondition = obj[0].condition;\r\n\t\t\t\titemConditionMax = obj[0].maxCondition;\r\n\t\t\t}\r\n\t\t\tif (obj[0].info != null && (obj[0].info.amountType == ItemDefinition.AmountType.Genetics || obj[0].info.amountType == ItemDefinition.AmountType.NucleusGrades) && obj[0].instanceData != null)\r\n\t\t\t{\r\n\t\t\t\tinstanceData = obj[0].instanceData.dataInt;\r\n\t\t\t\tsellOrder.inStock = obj[0].amount;\r\n\t\t\t}\r\n\t\t\tif (obj[0].contents != null && obj[0].contents.capacity > 0 && obj[0].contents.HasFlag(ItemContainer.Flag.ShowSlotsOnIcon))\r\n\t\t\t{\r\n\t\t\t\tforeach (Item item in obj[0].contents.itemList)\r\n\t\t\t\t{\r\n\t\t\t\t\tlist.Add(item.info.itemid);\r\n\t\t\t\t}\r\n\t\t\t\ttotalAttachmentSlots = obj[0].contents.capacity;\r\n\t\t\t}\r\n\t\t\tif (obj[0].ammoCount.HasValue)\r\n\t\t\t{\r\n\t\t\t\tammoCount = obj[0].ammoCount.Value;\r\n\t\t\t\tBaseEntity heldEntity = obj[0].GetHeldEntity();\r\n\t\t\t\tif ((bool)heldEntity)\r\n\t\t\t\t{\r\n\t\t\t\t\tBaseProjectile component = heldEntity.GetComponent<BaseProjectile>();\r\n\t\t\t\t\tif ((bool)component)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tammoType = component.primaryMagazine.ammoType.itemid;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsellOrder.ammoType = ammoType;\r\n\t\tsellOrder.ammoCount = ammoCount;\r\n\t\tsellOrder.itemCondition = itemCondition;\r\n\t\tsellOrder.itemConditionMax = itemConditionMax;\r\n\t\tsellOrder.instanceData = instanceData;\r\n\t\tif (sellOrder.attachmentsList != null)\r\n\t\t{\r\n\t\t\tFacepunch.Pool.FreeUnmanaged(ref sellOrder.attachmentsList);\r\n\t\t}\r\n\t\tsellOrder.attachmentsList = list;\r\n\t\tsellOrder.totalAttachmentSlots = totalAttachmentSlots;\r\n\t\tsellOrder.priceMultiplier = GetDiscountForSlot(num, sellOrder);\r\n\t\tsellOrder.receivedQuantityMultiplier = GetReceivedQuantityMultiplier(num, sellOrder);\r\n\t\tnum++;\r\n\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "RefreshSellOrderStockLevel",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnToggleVendingBroadcast",
    "fullName": "OnToggleVendingBroadcast",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Broadcast(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tbool b = msg.read.Bit();\r\n\tif (CanPlayerAdmin(player))\r\n\t{\r\n\t\tSetFlag(BaseEntity.Flags.Reserved4, b);\r\n\t\tUpdateMapMarker();\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "RPC_Broadcast",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnDeleteVendingOffer",
    "fullName": "OnDeleteVendingOffer",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_DeleteSellOrder(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (CanPlayerAdmin(player))\r\n\t{\r\n\t\tint num = msg.read.Int32();\r\n\t\tif (num >= 0 && num < sellOrders.sellOrders.Count)\r\n\t\t{\r\n\t\t\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[num];\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, added: false);\r\n\t\t\tsellOrders.sellOrders.RemoveAt(num);\r\n\t\t}\r\n\t\tRefreshSellOrderStockLevel();\r\n\t\tUpdateMapMarker();\r\n\t\tSendSellOrders(player);\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "RPC_DeleteSellOrder",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnOpenVendingAdmin",
    "fullName": "OnOpenVendingAdmin",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_OpenAdmin(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (CanPlayerAdmin(player))\r\n\t{\r\n\t\tOpenShop(player);\r\n\t\tClientRPC(RpcTarget.Player(\"CLIENT_OpenAdminMenu\", player));\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "RPC_OpenAdmin",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnVendingShopOpen",
    "fullName": "OnVendingShopOpen [VendingMachine]",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_OpenShop(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (OccupiedCheck(msg.player))\r\n\t{\r\n\t\tOpenShop(msg.player);\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "RPC_OpenShop",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnRotateVendingMachine",
    "fullName": "OnRotateVendingMachine",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_RotateVM(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (CanRotate())\r\n\t{\r\n\t\tUpdateEmptyFlag();\r\n\t\tif (msg.player.CanBuild() && IsInventoryEmpty())\r\n\t\t{\r\n\t\t\tbase.transform.rotation = UnityEngine.Quaternion.LookRotation(-base.transform.forward, base.transform.up);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "RPC_RotateVM",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanVendingAcceptItem",
    "fullName": "CanVendingAcceptItem",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanAcceptItem(Item item, int targetSlot)\r\n{\r\n\tBasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();\r\n\tif (transactionActive || industrialItemIncoming)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (item.parent == null)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (base.inventory.itemList.Contains(item))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (basePlayer == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn CanPlayerAdmin(basePlayer);\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "CanAcceptItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnAddVendingOffer",
    "fullName": "OnAddVendingOffer",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "ProtoBuf.VendingMachine+SellOrder, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)\r\n{\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);\r\n\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);\r\n\tif (!(itemDefinition == null) && !(itemDefinition2 == null))\r\n\t{\r\n\t\tcurrencyAmount = UnityEngine.Mathf.Clamp(currencyAmount, 1, 10000);\r\n\t\titemToSellAmount = UnityEngine.Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);\r\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();\r\n\t\tsellOrder.ShouldPool = false;\r\n\t\tsellOrder.itemToSellID = itemToSellID;\r\n\t\tsellOrder.itemToSellAmount = itemToSellAmount;\r\n\t\tsellOrder.currencyID = currencyToUseID;\r\n\t\tsellOrder.currencyAmountPerItem = currencyAmount;\r\n\t\tsellOrder.currencyIsBP = bpState == 3 || bpState == 2;\r\n\t\tsellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;\r\n\t\tsellOrders.sellOrders.Add(sellOrder);\r\n\t\tRefreshSellOrderStockLevel(itemDefinition);\r\n\t\tUpdateMapMarker();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "AddSellOrder",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnGiveSoldItem",
    "fullName": "OnGiveSoldItem",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "soldItem",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "buyer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)\r\n{\r\n\twhile (soldItem.amount > soldItem.MaxStackable())\r\n\t{\r\n\t\tItem item = soldItem.SplitItem(soldItem.MaxStackable());\r\n\t\tbuyer.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);\r\n\t}\r\n\tbuyer.GiveItem(soldItem, BaseEntity.GiveItemReason.PickedUp);\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "GiveSoldItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnVendingShopRename",
    "fullName": "OnVendingShopRename",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_UpdateShopName(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tstring text = msg.read.String(32);\r\n\tif (CanPlayerAdmin(player))\r\n\t{\r\n\t\tshopName = text;\r\n\t\tnameLastEditedBy = player.userID.Get();\r\n\t\tUpdateMapMarker();\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "RPC_UpdateShopName",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTakeCurrencyItem",
    "fullName": "OnTakeCurrencyItem",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "takenCurrencyItem",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void TakeCurrencyItem(Item takenCurrencyItem)\r\n{\r\n\tif (!takenCurrencyItem.MoveToContainer(base.inventory))\r\n\t{\r\n\t\ttakenCurrencyItem.Drop(base.inventory.dropPosition, UnityEngine.Vector3.zero);\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "TakeCurrencyItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnVendingTransaction",
    "fullName": "OnVendingTransaction",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "buyer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "sellOrderId",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "numberOfTransactions",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "targetContainer",
        "type": "ItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, System.Action<BasePlayer, Item> onCurrencyRemoved = null, System.Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)\r\n{\r\n\tif (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (targetContainer == null && UnityEngine.Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];\r\n\tSystem.Collections.Generic.List<Item> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Item>>();\r\n\tGetItemsToSell(sellOrder, obj);\r\n\tif (obj == null || obj.Count == 0)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn false;\r\n\t}\r\n\tnumberOfTransactions = UnityEngine.Mathf.Clamp(numberOfTransactions, 1, obj[0].hasCondition ? 1 : 1000000);\r\n\tint num = sellOrder.itemToSellAmount * numberOfTransactions;\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrder.itemToSellID);\r\n\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(sellOrder.currencyID);\r\n\tif (!itemDefinition.IsAllowedInEra(CurrentEraRestriction) || !itemDefinition2.IsAllowedInEra(CurrentEraRestriction))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (itemDefinition == NPCVendingMachine.ScrapItem && sellOrder.receivedQuantityMultiplier != 1f)\r\n\t{\r\n\t\tnum = GetTotalReceivedMerchandiseForOrder(sellOrder.itemToSellAmount, sellOrder.receivedQuantityMultiplier) * numberOfTransactions;\r\n\t}\r\n\tint num2 = System.Linq.Enumerable.Sum(obj, (Item x) => x.amount);\r\n\tif (num > num2)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn false;\r\n\t}\r\n\tSystem.Collections.Generic.List<Item> source = buyer.inventory.FindItemsByItemID(sellOrder.currencyID);\r\n\tif (sellOrder.currencyIsBP)\r\n\t{\r\n\t\tsource = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid), (Item x) => x.blueprintTarget == sellOrder.currencyID));\r\n\t}\r\n\tsource = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(System.Linq.Enumerable.Where(source, (Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)), (Item x) => x.GetItemVolume() <= maxCurrencyVolume));\r\n\tif (source.Count == 0)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn false;\r\n\t}\r\n\tint num3 = System.Linq.Enumerable.Sum(source, (Item x) => x.amount);\r\n\tint num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;\r\n\tif (num3 < num4)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn false;\r\n\t}\r\n\ttransactionActive = true;\r\n\tint num5 = 0;\r\n\tforeach (Item item3 in source)\r\n\t{\r\n\t\tint num6 = UnityEngine.Mathf.Min(num4 - num5, item3.amount);\r\n\t\tItem item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);\r\n\t\tTakeCurrencyItem(item);\r\n\t\tonCurrencyRemoved?.Invoke(buyer, item);\r\n\t\tnum5 += num6;\r\n\t\tif (num5 >= num4)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tint num7 = 0;\r\n\tforeach (Item item4 in obj)\r\n\t{\r\n\t\tint num8 = num - num7;\r\n\t\tItem item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);\r\n\t\tif (item2 == null)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(\"Vending machine error, contact developers!\");\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnum7 += item2.amount;\r\n\t\t\tRecordSaleAnalytics(item2, sellOrderId, sellOrder.currencyAmountPerItem);\r\n\t\t\tif (targetContainer == null)\r\n\t\t\t{\r\n\t\t\t\tGiveSoldItem(item2, buyer);\r\n\t\t\t}\r\n\t\t\telse if (!item2.MoveToContainer(targetContainer))\r\n\t\t\t{\r\n\t\t\t\titem2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);\r\n\t\t\t}\r\n\t\t\tif (ShouldRecordStats)\r\n\t\t\t{\r\n\t\t\t\tRegisterCustomer(buyer.userID);\r\n\t\t\t}\r\n\t\t\tonItemPurchased?.Invoke(buyer, item2);\r\n\t\t}\r\n\t\tif (num7 >= num)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, num, sellOrder.itemToSellIsBP, sellOrder.currencyID, num5, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);\r\n\tif (ShouldRecordStats)\r\n\t{\r\n\t\tAddPurchaseHistory(sellOrder.itemToSellID, num, sellOrder.currencyID, num5, sellOrder.itemToSellIsBP, sellOrder.currencyIsBP);\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\tUpdateEmptyFlag();\r\n\ttransactionActive = false;\r\n\treturn true;\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "DoTransaction",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanPurchaseItem",
    "fullName": "CanPurchaseItem",
    "category": "Vending",
    "parameters": [
      {
        "name": "buyer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local15",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "onItemPurchased",
        "type": "System.Action`2[[BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null],[Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "targetContainer",
        "type": "ItemContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, System.Action<BasePlayer, Item> onCurrencyRemoved = null, System.Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)\r\n{\r\n\tif (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (targetContainer == null && UnityEngine.Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];\r\n\tSystem.Collections.Generic.List<Item> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Item>>();\r\n\tGetItemsToSell(sellOrder, obj);\r\n\tif (obj == null || obj.Count == 0)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn false;\r\n\t}\r\n\tnumberOfTransactions = UnityEngine.Mathf.Clamp(numberOfTransactions, 1, obj[0].hasCondition ? 1 : 1000000);\r\n\tint num = sellOrder.itemToSellAmount * numberOfTransactions;\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrder.itemToSellID);\r\n\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(sellOrder.currencyID);\r\n\tif (!itemDefinition.IsAllowedInEra(CurrentEraRestriction) || !itemDefinition2.IsAllowedInEra(CurrentEraRestriction))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (itemDefinition == NPCVendingMachine.ScrapItem && sellOrder.receivedQuantityMultiplier != 1f)\r\n\t{\r\n\t\tnum = GetTotalReceivedMerchandiseForOrder(sellOrder.itemToSellAmount, sellOrder.receivedQuantityMultiplier) * numberOfTransactions;\r\n\t}\r\n\tint num2 = System.Linq.Enumerable.Sum(obj, (Item x) => x.amount);\r\n\tif (num > num2)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn false;\r\n\t}\r\n\tSystem.Collections.Generic.List<Item> source = buyer.inventory.FindItemsByItemID(sellOrder.currencyID);\r\n\tif (sellOrder.currencyIsBP)\r\n\t{\r\n\t\tsource = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid), (Item x) => x.blueprintTarget == sellOrder.currencyID));\r\n\t}\r\n\tsource = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(System.Linq.Enumerable.Where(source, (Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)), (Item x) => x.GetItemVolume() <= maxCurrencyVolume));\r\n\tif (source.Count == 0)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn false;\r\n\t}\r\n\tint num3 = System.Linq.Enumerable.Sum(source, (Item x) => x.amount);\r\n\tint num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;\r\n\tif (num3 < num4)\r\n\t{\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\treturn false;\r\n\t}\r\n\ttransactionActive = true;\r\n\tint num5 = 0;\r\n\tforeach (Item item3 in source)\r\n\t{\r\n\t\tint num6 = UnityEngine.Mathf.Min(num4 - num5, item3.amount);\r\n\t\tItem item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);\r\n\t\tTakeCurrencyItem(item);\r\n\t\tonCurrencyRemoved?.Invoke(buyer, item);\r\n\t\tnum5 += num6;\r\n\t\tif (num5 >= num4)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tint num7 = 0;\r\n\tforeach (Item item4 in obj)\r\n\t{\r\n\t\tint num8 = num - num7;\r\n\t\tItem item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);\r\n\t\tif (item2 == null)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(\"Vending machine error, contact developers!\");\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnum7 += item2.amount;\r\n\t\t\tRecordSaleAnalytics(item2, sellOrderId, sellOrder.currencyAmountPerItem);\r\n\t\t\tif (targetContainer == null)\r\n\t\t\t{\r\n\t\t\t\tGiveSoldItem(item2, buyer);\r\n\t\t\t}\r\n\t\t\telse if (!item2.MoveToContainer(targetContainer))\r\n\t\t\t{\r\n\t\t\t\titem2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);\r\n\t\t\t}\r\n\t\t\tif (ShouldRecordStats)\r\n\t\t\t{\r\n\t\t\t\tRegisterCustomer(buyer.userID);\r\n\t\t\t}\r\n\t\t\tonItemPurchased?.Invoke(buyer, item2);\r\n\t\t}\r\n\t\tif (num7 >= num)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, num, sellOrder.itemToSellIsBP, sellOrder.currencyID, num5, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);\r\n\tif (ShouldRecordStats)\r\n\t{\r\n\t\tAddPurchaseHistory(sellOrder.itemToSellID, num, sellOrder.currencyID, num5, sellOrder.itemToSellIsBP, sellOrder.currencyIsBP);\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\tUpdateEmptyFlag();\r\n\ttransactionActive = false;\r\n\treturn true;\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "DoTransaction",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnVendingShopOpened",
    "fullName": "OnVendingShopOpened [VendingMachine]",
    "category": "Vending",
    "parameters": [
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_OpenShop(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (OccupiedCheck(msg.player))\r\n\t{\r\n\t\tOpenShop(msg.player);\r\n\t}\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "RPC_OpenShop",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanAdministerVending",
    "fullName": "CanAdministerVending [NPC]",
    "category": "Vending",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "nPCVendingMachine",
        "type": "NPCVendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool CanPlayerAdmin(BasePlayer player)\r\n{\r\n\treturn false;\r\n}\r\n",
    "targetName": "NPCVendingMachine",
    "methodName": "CanPlayerAdmin",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnTakeCurrencyItem",
    "fullName": "OnTakeCurrencyItem [NPC]",
    "category": "Vending",
    "parameters": [
      {
        "name": "nPCVendingMachine",
        "type": "NPCVendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "takenCurrencyItem",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void TakeCurrencyItem(Item takenCurrencyItem)\r\n{\r\n\ttakenCurrencyItem.MoveToContainer(base.inventory);\r\n\ttakenCurrencyItem.RemoveFromContainer();\r\n\ttakenCurrencyItem.Remove();\r\n}\r\n",
    "targetName": "NPCVendingMachine",
    "methodName": "TakeCurrencyItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanAccessVendingMachine",
    "fullName": "CanAccessVendingMachine",
    "category": "Vending",
    "parameters": [
      {
        "name": "marketTerminal",
        "type": "MarketTerminal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "vendingMachine",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[System.Runtime.CompilerServices.CompilerGenerated]\r\npublic bool <GetDeliveryEligibleVendingMachines>g__IsEligible|42_0(VendingMachine vendingMachine, UnityEngine.Vector3 offset, int n)\r\n{\r\n\tif (vendingMachine is NPCVendingMachine)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (!vendingMachine.IsBroadcasting())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!config.IsVendingMachineAccessible(vendingMachine, offset, out var _))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "MarketTerminal",
    "methodName": "<GetDeliveryEligibleVendingMachines>g__IsEligible|42_0",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnVendingShopOpen",
    "fullName": "OnVendingShopOpen [NPCTalking]",
    "category": "Vending",
    "parameters": [
      {
        "name": "local1",
        "type": "InvisibleVendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnConversationAction(BasePlayer player, string action)\r\n{\r\n\tif (action == \"openvending\")\r\n\t{\r\n\t\tInvisibleVendingMachine vendingMachine = GetVendingMachine();\r\n\t\tif (vendingMachine != null && UnityEngine.Vector3.Distance(player.transform.position, base.transform.position) < 5f)\r\n\t\t{\r\n\t\t\tForceEndConversation(player);\r\n\t\t\tvendingMachine.PlayerOpenLoot(player, \"vendingmachine.customer\", doPositionChecks: false);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(\"scrap\");\r\n\tNPCTalking.NPCConversationResultAction[] array = conversationResultActions;\r\n\tforeach (NPCTalking.NPCConversationResultAction nPCConversationResultAction in array)\r\n\t{\r\n\t\tif (!(nPCConversationResultAction.action == action))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tCleanupConversingPlayers();\r\n\t\tforeach (BasePlayer conversingPlayer in conversingPlayers)\r\n\t\t{\r\n\t\t\tif (!(conversingPlayer == player) && !(conversingPlayer == null))\r\n\t\t\t{\r\n\t\t\t\tint speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex(\"startbusy\");\r\n\t\t\t\tForceSpeechNode(conversingPlayer, speechNodeIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tint num = nPCConversationResultAction.scrapCost;\r\n\t\tSystem.Collections.Generic.List<Item> list = player.inventory.FindItemsByItemID(itemDefinition.itemid);\r\n\t\tforeach (Item item in list)\r\n\t\t{\r\n\t\t\tnum -= item.amount;\r\n\t\t}\r\n\t\tif (num > 0)\r\n\t\t{\r\n\t\t\tint speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex(\"toopoor\");\r\n\t\t\tForceSpeechNode(player, speechNodeIndex2);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);\r\n\t\tnum = nPCConversationResultAction.scrapCost;\r\n\t\tforeach (Item item2 in list)\r\n\t\t{\r\n\t\t\tint num2 = UnityEngine.Mathf.Min(num, item2.amount);\r\n\t\t\titem2.UseItem(num2);\r\n\t\t\tnum -= num2;\r\n\t\t\tif (num <= 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tlastActionPlayer = player;\r\n\t\tBroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);\r\n\t\tlastActionPlayer = null;\r\n\t\tbreak;\r\n\t}\r\n}\r\n",
    "targetName": "NPCTalking",
    "methodName": "OnConversationAction",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnVendingShopOpened",
    "fullName": "OnVendingShopOpened [NPCTalking]",
    "category": "Vending",
    "parameters": [
      {
        "name": "local1",
        "type": "InvisibleVendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void OnConversationAction(BasePlayer player, string action)\r\n{\r\n\tif (action == \"openvending\")\r\n\t{\r\n\t\tInvisibleVendingMachine vendingMachine = GetVendingMachine();\r\n\t\tif (vendingMachine != null && UnityEngine.Vector3.Distance(player.transform.position, base.transform.position) < 5f)\r\n\t\t{\r\n\t\t\tForceEndConversation(player);\r\n\t\t\tvendingMachine.PlayerOpenLoot(player, \"vendingmachine.customer\", doPositionChecks: false);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(\"scrap\");\r\n\tNPCTalking.NPCConversationResultAction[] array = conversationResultActions;\r\n\tforeach (NPCTalking.NPCConversationResultAction nPCConversationResultAction in array)\r\n\t{\r\n\t\tif (!(nPCConversationResultAction.action == action))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tCleanupConversingPlayers();\r\n\t\tforeach (BasePlayer conversingPlayer in conversingPlayers)\r\n\t\t{\r\n\t\t\tif (!(conversingPlayer == player) && !(conversingPlayer == null))\r\n\t\t\t{\r\n\t\t\t\tint speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex(\"startbusy\");\r\n\t\t\t\tForceSpeechNode(conversingPlayer, speechNodeIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tint num = nPCConversationResultAction.scrapCost;\r\n\t\tSystem.Collections.Generic.List<Item> list = player.inventory.FindItemsByItemID(itemDefinition.itemid);\r\n\t\tforeach (Item item in list)\r\n\t\t{\r\n\t\t\tnum -= item.amount;\r\n\t\t}\r\n\t\tif (num > 0)\r\n\t\t{\r\n\t\t\tint speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex(\"toopoor\");\r\n\t\t\tForceSpeechNode(player, speechNodeIndex2);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);\r\n\t\tnum = nPCConversationResultAction.scrapCost;\r\n\t\tforeach (Item item2 in list)\r\n\t\t{\r\n\t\t\tint num2 = UnityEngine.Mathf.Min(num, item2.amount);\r\n\t\t\titem2.UseItem(num2);\r\n\t\t\tnum -= num2;\r\n\t\t\tif (num <= 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tlastActionPlayer = player;\r\n\t\tBroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);\r\n\t\tlastActionPlayer = null;\r\n\t\tbreak;\r\n\t}\r\n}\r\n",
    "targetName": "NPCTalking",
    "methodName": "OnConversationAction",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnVendingShopOpen",
    "fullName": "OnVendingShopOpen [TravellingVendor]",
    "category": "Vending",
    "parameters": [
      {
        "name": "travellingVendor",
        "type": "TravellingVendor, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SV_OpenMenu(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (vendingMachine == null)\r\n\t{\r\n\t\tvendingMachine = GetComponentInChildren<NPCVendingMachine>();\r\n\t}\r\n\tvendingMachine.OpenShop(msg.player);\r\n}\r\n",
    "targetName": "TravellingVendor",
    "methodName": "SV_OpenMenu",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnVendingShopOpened",
    "fullName": "OnVendingShopOpened [TravellingVendor]",
    "category": "Vending",
    "parameters": [
      {
        "name": "travellingVendor",
        "type": "TravellingVendor, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SV_OpenMenu(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (vendingMachine == null)\r\n\t{\r\n\t\tvendingMachine = GetComponentInChildren<NPCVendingMachine>();\r\n\t}\r\n\tvendingMachine.OpenShop(msg.player);\r\n}\r\n",
    "targetName": "TravellingVendor",
    "methodName": "SV_OpenMenu",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnExplosiveThrown",
    "fullName": "OnExplosiveThrown",
    "category": "Weapon",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "thrownWeapon",
        "type": "ThrownWeapon, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void DoThrow(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!HasItemAmount() || HasAttackCooldown())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tUnityEngine.Vector3 vector = msg.read.Vector3();\r\n\tUnityEngine.Vector3 normalized = msg.read.Vector3().normalized;\r\n\tfloat num = UnityEngine.Mathf.Clamp01(msg.read.Float());\r\n\tif (msg.player.isMounted || msg.player.HasParent())\r\n\t{\r\n\t\tvector = msg.player.eyes.position;\r\n\t}\r\n\telse if (!ValidateEyePos(msg.player, vector))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!canThrowUnderwater && msg.player.IsHeadUnderwater())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, UnityEngine.Quaternion.LookRotation((overrideAngle == UnityEngine.Vector3.zero) ? (-normalized) : overrideAngle));\r\n\tif (!(baseEntity == null))\r\n\t{\r\n\t\tItem ownerItem = GetOwnerItem();\r\n\t\tif (ownerItem != null && ownerItem.instanceData != null && ownerItem.HasFlag(Item.Flag.IsOn))\r\n\t\t{\r\n\t\t\tbaseEntity.gameObject.SendMessage(\"SetFrequency\", GetOwnerItem().instanceData.dataInt, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t\t}\r\n\t\tbaseEntity.SetCreatorEntity(msg.player);\r\n\t\tbaseEntity.skinID = skinID;\r\n\t\tbaseEntity.SetVelocity(GetInheritedVelocity(msg.player, normalized) + normalized * maxThrowVelocity * num + msg.player.estimatedVelocity * 0.5f);\r\n\t\tif (tumbleVelocity > 0f)\r\n\t\t{\r\n\t\t\tbaseEntity.SetAngularVelocity(new UnityEngine.Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * tumbleVelocity);\r\n\t\t}\r\n\t\tbaseEntity.Spawn();\r\n\t\tif (baseEntity is TimedExplosive timedExplosive)\r\n\t\t{\r\n\t\t\tItemOwnershipShare itemOwnership = ownerItem.TakeOwnershipShare();\r\n\t\t\ttimedExplosive.ItemOwnership = itemOwnership;\r\n\t\t\ttimedExplosive.SetCreator(msg.player);\r\n\t\t}\r\n\t\tSetUpThrownWeapon(baseEntity);\r\n\t\tStartAttackCooldown(repeatDelay);\r\n\t\tUseItemAmount(1, reduceItemOwnership: false);\r\n\t}\r\n}\r\n",
    "targetName": "ThrownWeapon",
    "methodName": "DoThrow",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnExplosiveDropped",
    "fullName": "OnExplosiveDropped",
    "category": "Weapon",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "thrownWeapon",
        "type": "ThrownWeapon, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void DoDrop(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!HasItemAmount() || HasAttackCooldown() || (!canThrowUnderwater && msg.player.IsHeadUnderwater()))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tUnityEngine.Vector3 vector = msg.read.Vector3();\r\n\tUnityEngine.Vector3 normalized = msg.read.Vector3().normalized;\r\n\tif (msg.player.isMounted || msg.player.HasParent())\r\n\t{\r\n\t\tvector = msg.player.eyes.position;\r\n\t}\r\n\telse if (!ValidateEyePos(msg.player, vector))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3.up));\r\n\tif (baseEntity == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (canStick && UnityEngine.Physics.SphereCast(new UnityEngine.Ray(vector, normalized), 0.05f, out var hitInfo, 1.5f, 1237003025))\r\n\t{\r\n\t\tUnityEngine.Vector3 point = hitInfo.point;\r\n\t\tUnityEngine.Vector3 normal = hitInfo.normal;\r\n\t\tBaseEntity entity = hitInfo.GetEntity();\r\n\t\tUnityEngine.Collider collider = hitInfo.collider;\r\n\t\tif ((bool)entity && entity is StabilityEntity && baseEntity is TimedExplosive)\r\n\t\t{\r\n\t\t\tentity = entity.ToServer<BaseEntity>();\r\n\t\t\tTimedExplosive timedExplosive = baseEntity as TimedExplosive;\r\n\t\t\ttimedExplosive.onlyDamageParent = true;\r\n\t\t\ttimedExplosive.DoStick(point, normal, entity, collider);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnExplosiveLaunched(msg.player, timedExplosive);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbaseEntity.SetVelocity(normalized);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tbaseEntity.SetVelocity(normalized);\r\n\t}\r\n\tbaseEntity.creatorEntity = msg.player;\r\n\tbaseEntity.skinID = skinID;\r\n\tbaseEntity.Spawn();\r\n\tSetUpThrownWeapon(baseEntity);\r\n\tStartAttackCooldown(repeatDelay);\r\n\tUseItemAmount(1);\r\n}\r\n",
    "targetName": "ThrownWeapon",
    "methodName": "DoDrop",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnMeleeThrown",
    "fullName": "OnMeleeThrown",
    "category": "Weapon",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void CLProject(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!VerifyClientAttack(player))\r\n\t{\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (player == null || player.IsHeadUnderwater())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!canThrowAsProjectile)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Not throwable (\" + base.ShortPrefabName + \")\");\r\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \"not_throwable\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItem item = GetItem();\r\n\t\tif (item == null)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Item not found (\" + base.ShortPrefabName + \")\");\r\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \"item_missing\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemModProjectile component = item.info.GetComponent<ItemModProjectile>();\r\n\t\tif (component == null)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Item mod not found (\" + base.ShortPrefabName + \")\");\r\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \"mod_missing\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tProtoBuf.ProjectileShoot projectileShoot = ProtoBuf.ProjectileShoot.Deserialize(msg.read);\r\n\t\tif (projectileShoot.projectiles.Count != 1)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Projectile count mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \"count_mismatch\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayer.CleanupExpiredProjectiles();\r\n\t\tSystem.Guid projectileGroupId = System.Guid.NewGuid();\r\n\t\tforeach (ProtoBuf.ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\r\n\t\t{\r\n\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\r\n\t\t\t{\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Duplicate ID (\" + projectile.projectileID + \")\");\r\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \"duplicate_id\");\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tUnityEngine.Vector3 positionOffset = UnityEngine.Vector3.zero;\r\n\t\t\tif (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))\r\n\t\t\t{\r\n\t\t\t\tif (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tUnityEngine.Vector3 position = player.eyes.position;\r\n\t\t\t\tpositionOffset = position - projectile.startPos;\r\n\t\t\t\tprojectile.startPos = position;\r\n\t\t\t}\r\n\t\t\telse if (!ValidateEyePos(player, projectile.startPos))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tItem pickupItem = (ThrowFullStack ? item : ItemManager.CreateByItemID(item.info.itemid, 1, 0uL));\r\n\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, projectileGroupId, positionOffset, pickupItem);\r\n\t\t\tEffect effect = new Effect();\r\n\t\t\teffect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);\r\n\t\t\teffect.scale = 1f;\r\n\t\t\teffect.pooledString = component.projectileObject.resourcePath;\r\n\t\t\teffect.number = projectile.seed;\r\n\t\t\tEffectNetwork.Send(effect);\r\n\t\t}\r\n\t\tprojectileShoot?.Dispose();\r\n\t\tif (ThrowFullStack)\r\n\t\t{\r\n\t\t\titem.SetParent(null);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\titem.UseItem();\r\n\t\t\tif (item.amount == 0)\r\n\t\t\t{\r\n\t\t\t\titem.SetParent(null);\r\n\t\t\t}\r\n\t\t}\r\n\t\tSingletonComponent<NpcNoiseManager>.Instance.OnWeaponThrown(player, this, canAiHearIt);\r\n\t}\r\n}\r\n",
    "targetName": "BaseMelee",
    "methodName": "CLProject",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRocketLaunched",
    "fullName": "OnRocketLaunched",
    "category": "Weapon",
    "parameters": [
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local8",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void SV_Launch(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!VerifyClientAttack(player))\r\n\t{\r\n\t\tSendNetworkUpdate();\r\n\t\treturn;\r\n\t}\r\n\tif (reloadFinished && HasReloadCooldown())\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Reloading (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"reload_cooldown\");\r\n\t\treturn;\r\n\t}\r\n\treloadStarted = false;\r\n\treloadFinished = false;\r\n\tif (!base.UsingInfiniteAmmoCheat)\r\n\t{\r\n\t\tif (primaryMagazine.contents <= 0)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Magazine empty (\" + base.ShortPrefabName + \")\");\r\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \"magazine_empty\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tModifyAmmoCount(-1);\r\n\t}\r\n\tSignalBroadcast(BaseEntity.Signal.Attack, string.Empty, player.net.connection);\r\n\tUnityEngine.Vector3 vector = msg.read.Vector3();\r\n\tUnityEngine.Vector3 vector2 = msg.read.Vector3().normalized;\r\n\tbool num = msg.read.Bit();\r\n\tBaseEntity mounted = player.GetParentEntity();\r\n\tif (mounted == null)\r\n\t{\r\n\t\tmounted = player.GetMounted();\r\n\t}\r\n\tif (num)\r\n\t{\r\n\t\tif (mounted != null)\r\n\t\t{\r\n\t\t\tvector = mounted.transform.TransformPoint(vector);\r\n\t\t\tvector2 = mounted.transform.TransformDirection(vector2);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvector = player.eyes.position;\r\n\t\t\tvector2 = player.eyes.BodyForward();\r\n\t\t}\r\n\t}\r\n\tif (!ValidateEyePos(player, vector))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();\r\n\tif (!component)\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Item mod not found (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"mod_missing\");\r\n\t\treturn;\r\n\t}\r\n\tfloat num2 = GetAimCone() + component.projectileSpread;\r\n\tif (num2 > 0f)\r\n\t{\r\n\t\tvector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);\r\n\t}\r\n\tfloat num3 = 1f;\r\n\tif (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1237003025))\r\n\t{\r\n\t\tnum3 = hitInfo.distance - 0.1f;\r\n\t}\r\n\tBaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num3);\r\n\tif (baseEntity == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbaseEntity.creatorEntity = player;\r\n\tServerProjectile component2 = baseEntity.GetComponent<ServerProjectile>();\r\n\tif ((bool)component2)\r\n\t{\r\n\t\tcomponent2.InitializeVelocity(GetInheritedVelocity(player, vector2) + vector2 * component2.speed * initialSpeedMultiplier);\r\n\t}\r\n\tbaseEntity.Spawn();\r\n\tProjectileLaunched_Server(component2);\r\n\tFacepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity, this);\r\n\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay));\r\n\tItem ownerItem = GetOwnerItem();\r\n\tif (ownerItem != null)\r\n\t{\r\n\t\tif (!base.UsingInfiniteAmmoCheat)\r\n\t\t{\r\n\t\t\townerItem.LoseCondition(UnityEngine.Random.Range(1f, 2f));\r\n\t\t}\r\n\t\tBaseMountable mounted2 = player.GetMounted();\r\n\t\tif (mounted2 != null)\r\n\t\t{\r\n\t\t\tmounted2.OnWeaponFired(this);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseLauncher",
    "methodName": "SV_Launch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnWeaponFired",
    "fullName": "OnWeaponFired",
    "category": "Weapon",
    "parameters": [
      {
        "name": "baseProjectile",
        "type": "BaseProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local3",
        "type": "ItemModProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "ProtoBuf.ProjectileShoot, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void CLProject(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!VerifyClientAttack(player))\r\n\t{\r\n\t\tSendNetworkUpdate();\r\n\t\treturn;\r\n\t}\r\n\tif (reloadFinished && HasReloadCooldown())\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Reloading (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"reload_cooldown\");\r\n\t\treturn;\r\n\t}\r\n\treloadStarted = false;\r\n\treloadFinished = false;\r\n\tif (primaryMagazine.contents <= 0 && !base.UsingInfiniteAmmoCheat)\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Magazine empty (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"ammo_missing\");\r\n\t\treturn;\r\n\t}\r\n\tItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;\r\n\tProtoBuf.ProjectileShoot projectileShoot = ProtoBuf.ProjectileShoot.Deserialize(msg.read);\r\n\tif (primaryMagazineAmmo.itemid != projectileShoot.ammoType)\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Ammo mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"ammo_mismatch\");\r\n\t\treturn;\r\n\t}\r\n\tif (!base.UsingInfiniteAmmoCheat)\r\n\t{\r\n\t\tModifyAmmoCount(-1);\r\n\t}\r\n\tItemModProjectile component = primaryMagazineAmmo.GetComponent<ItemModProjectile>();\r\n\tif (component == null)\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Item mod not found (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"mod_missing\");\r\n\t}\r\n\telse if (projectileShoot.projectiles.Count > component.numProjectiles)\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Count mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"count_mismatch\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (player.InGesture)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSignalBroadcast(BaseEntity.Signal.Attack, string.Empty, msg.connection, GetAttackEffect());\r\n\t\tplayer.CleanupExpiredProjectiles();\r\n\t\tSystem.Guid projectileGroupId = System.Guid.NewGuid();\r\n\t\tforeach (ProtoBuf.ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\r\n\t\t{\r\n\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\r\n\t\t\t{\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Duplicate ID (\" + projectile.projectileID + \")\");\r\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \"duplicate_id\");\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tUnityEngine.Vector3 positionOffset = UnityEngine.Vector3.zero;\r\n\t\t\tif (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))\r\n\t\t\t{\r\n\t\t\t\tif (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tUnityEngine.Vector3 position = player.eyes.position;\r\n\t\t\t\tpositionOffset = position - projectile.startPos;\r\n\t\t\t\tprojectile.startPos = position;\r\n\t\t\t}\r\n\t\t\telse if (!ValidateEyePos(player, projectile.startPos))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo, projectileGroupId, positionOffset);\r\n\t\t\tCreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());\r\n\t\t}\r\n\t\tplayer.MakeNoise(player.transform.position, BaseCombatEntity.ActionVolume.Loud);\r\n\t\tSingletonComponent<NpcNoiseManager>.Instance.OnWeaponShot(player, this);\r\n\t\tplayer.stats.Add(component.category + \"_fired\", System.Linq.Enumerable.Count(projectileShoot.projectiles), (Stats)5);\r\n\t\tplayer.LifeStoryShotFired(this);\r\n\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);\r\n\t\tplayer.MarkHostileFor();\r\n\t\tUpdateItemCondition();\r\n\t\tDidAttackServerside();\r\n\t\tBaseMountable mounted = player.GetMounted();\r\n\t\tif (mounted != null)\r\n\t\t{\r\n\t\t\tmounted.OnWeaponFired(this);\r\n\t\t}\r\n\t\tEACServer.LogPlayerUseWeapon(player, this);\r\n\t}\r\n}\r\n",
    "targetName": "BaseProjectile",
    "methodName": "CLProject",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnWeaponReload",
    "fullName": "OnWeaponReload",
    "category": "Weapon",
    "parameters": [
      {
        "name": "baseProjectile",
        "type": "BaseProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void StartReload(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!VerifyClientRPC(player))\r\n\t{\r\n\t\tSendNetworkUpdate();\r\n\t\treloadStarted = false;\r\n\t\treloadFinished = false;\r\n\t\treturn;\r\n\t}\r\n\treloadFinished = false;\r\n\treloadStarted = true;\r\n\tfractionalInsertCounter = 0;\r\n\tif (CanRefundAmmo)\r\n\t{\r\n\t\tSwitchAmmoTypesIfNeeded(player.inventory);\r\n\t}\r\n\tOnReloadStarted();\r\n\tStartReloadCooldown(GetReloadDuration());\r\n}\r\n",
    "targetName": "BaseProjectile",
    "methodName": "StartReload",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnAmmoSwitch",
    "fullName": "OnAmmoSwitch",
    "category": "Weapon",
    "parameters": [
      {
        "name": "baseProjectile",
        "type": "BaseProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void SwitchAmmoTo(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tif (num == primaryMagazine.ammoType.itemid)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();\r\n\tif ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes))\r\n\t{\r\n\t\tif (primaryMagazine.contents > 0)\r\n\t\t{\r\n\t\t\townerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));\r\n\t\t\tSetAmmoCount(0);\r\n\t\t}\r\n\t\tprimaryMagazine.ammoType = itemDefinition;\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tItemManager.DoRemoves();\r\n\t\townerPlayer.inventory.ServerUpdate(0f);\r\n\t}\r\n}\r\n",
    "targetName": "BaseProjectile",
    "methodName": "SwitchAmmoTo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnAmmoUnload",
    "fullName": "OnAmmoUnload",
    "category": "Weapon",
    "parameters": [
      {
        "name": "local0",
        "type": "BaseProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UnloadAmmo(Item item, BasePlayer player)\r\n{\r\n\tBaseProjectile component = item.GetHeldEntity().GetComponent<BaseProjectile>();\r\n\tif (!component.canUnloadAmmo || !component)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = component.primaryMagazine.contents;\r\n\tif (num <= 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tcomponent.SetAmmoCount(0);\r\n\titem.MarkDirty();\r\n\tSendNetworkUpdateImmediate();\r\n\tint stackable = component.primaryMagazine.ammoType.stackable;\r\n\tif (num > stackable)\r\n\t{\r\n\t\tint num2 = UnityEngine.Mathf.FloorToInt(num / component.primaryMagazine.ammoType.stackable);\r\n\t\tnum %= stackable;\r\n\t\tfor (int i = 0; i < num2; i++)\r\n\t\t{\r\n\t\t\tItem item2 = ItemManager.Create(component.primaryMagazine.ammoType, stackable, 0uL);\r\n\t\t\tplayer.GiveItem(item2);\r\n\t\t}\r\n\t}\r\n\tif (num > 0)\r\n\t{\r\n\t\tItem item3 = ItemManager.Create(component.primaryMagazine.ammoType, num, 0uL);\r\n\t\tplayer.GiveItem(item3);\r\n\t}\r\n}\r\n",
    "targetName": "BaseProjectile",
    "methodName": "UnloadAmmo",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWeaponModChange",
    "fullName": "OnWeaponModChange",
    "category": "Weapon",
    "parameters": [
      {
        "name": "baseProjectile",
        "type": "BaseProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BaseProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DelayedModsChanged()\r\n{\r\n\tint num = UnityEngine.Mathf.CeilToInt(ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.magazineCapacity, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * (float)primaryMagazine.definition.builtInSize);\r\n\tif (num == primaryMagazine.capacity)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (primaryMagazine.contents > 0 && primaryMagazine.contents > num)\r\n\t{\r\n\t\t_ = primaryMagazine.ammoType;\r\n\t\tint contents = primaryMagazine.contents;\r\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\t\tItemContainer itemContainer = null;\r\n\t\tif (ownerPlayer != null)\r\n\t\t{\r\n\t\t\titemContainer = ownerPlayer.inventory.containerMain;\r\n\t\t}\r\n\t\telse if (GetCachedItem() != null)\r\n\t\t{\r\n\t\t\titemContainer = GetCachedItem().parent;\r\n\t\t}\r\n\t\tSetAmmoCount(0);\r\n\t\tif (itemContainer != null)\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(primaryMagazine.ammoType, contents, 0uL);\r\n\t\t\tif (!item.MoveToContainer(itemContainer))\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Vector3 vPos = base.transform.position;\r\n\t\t\t\tif (itemContainer.entityOwner != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvPos = itemContainer.entityOwner.transform.position + UnityEngine.Vector3.up * 0.25f;\r\n\t\t\t\t}\r\n\t\t\t\titem.Drop(vPos, UnityEngine.Vector3.up * 5f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tprimaryMagazine.capacity = num;\r\n\tSendNetworkUpdate();\r\n}\r\n",
    "targetName": "BaseProjectile",
    "methodName": "DelayedModsChanged",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMagazineReload",
    "fullName": "OnMagazineReload",
    "category": "Weapon",
    "parameters": [
      {
        "name": "baseProjectile",
        "type": "BaseProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "ammoSource",
        "type": "IAmmoContainer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "self1",
        "type": "BaseProjectile, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount = -1)\r\n{\r\n\tif (!TryReload(ammoSource, desiredAmount))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tSendNetworkUpdateImmediate();\r\n\tItemManager.DoRemoves();\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (ownerPlayer != null)\r\n\t{\r\n\t\townerPlayer.inventory.ServerUpdate(0f);\r\n\t}\r\n\tif (!fractionalReload)\r\n\t{\r\n\t\tUpdateShieldState(bHeld: true);\r\n\t}\r\n\telse if (primaryMagazine.contents == primaryMagazine.capacity || !ammoSource.HasAmmo(primaryMagazine.definition.ammoTypes))\r\n\t{\r\n\t\tUpdateShieldState(bHeld: true);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "BaseProjectile",
    "methodName": "TryReloadMagazine",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanCreateWorldProjectile",
    "fullName": "CanCreateWorldProjectile",
    "category": "Weapon",
    "parameters": [
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "itemDef",
        "type": "ItemDefinition, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\r\n{\r\n\tUnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;\r\n\tItem item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));\r\n\tBaseEntity baseEntity = null;\r\n\tif (!info.DidHit)\r\n\t{\r\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\r\n\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\r\n\t\treturn;\r\n\t}\r\n\tif (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)\r\n\t{\r\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\r\n\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\r\n\t\treturn;\r\n\t}\r\n\tif (projectilePrefab.conditionLoss > 0f)\r\n\t{\r\n\t\titem.LoseCondition(projectilePrefab.conditionLoss * 100f);\r\n\t\tif (item.isBroken)\r\n\t\t{\r\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\r\n\t\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)\r\n\t{\r\n\t\tbaseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));\r\n\t\tDroppedItem droppedItem = baseEntity as DroppedItem;\r\n\t\tif (droppedItem != null)\r\n\t\t{\r\n\t\t\tdroppedItem.StickIn();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbaseEntity.GetComponent<UnityEngine.Rigidbody>().isKinematic = true;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\r\n\t\tUnityEngine.Rigidbody component = baseEntity.GetComponent<UnityEngine.Rigidbody>();\r\n\t\tcomponent.AddForce(projectileVelocity.normalized * 200f);\r\n\t\tcomponent.WakeUp();\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "CreateWorldProjectile",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnWorldProjectileCreate",
    "fullName": "OnWorldProjectileCreate",
    "category": "Weapon",
    "parameters": [
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\r\n{\r\n\tUnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;\r\n\tItem item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));\r\n\tBaseEntity baseEntity = null;\r\n\tif (!info.DidHit)\r\n\t{\r\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\r\n\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\r\n\t\treturn;\r\n\t}\r\n\tif (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)\r\n\t{\r\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\r\n\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\r\n\t\treturn;\r\n\t}\r\n\tif (projectilePrefab.conditionLoss > 0f)\r\n\t{\r\n\t\titem.LoseCondition(projectilePrefab.conditionLoss * 100f);\r\n\t\tif (item.isBroken)\r\n\t\t{\r\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\r\n\t\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)\r\n\t{\r\n\t\tbaseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));\r\n\t\tDroppedItem droppedItem = baseEntity as DroppedItem;\r\n\t\tif (droppedItem != null)\r\n\t\t{\r\n\t\t\tdroppedItem.StickIn();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbaseEntity.GetComponent<UnityEngine.Rigidbody>().isKinematic = true;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\r\n\t\tUnityEngine.Rigidbody component = baseEntity.GetComponent<UnityEngine.Rigidbody>();\r\n\t\tcomponent.AddForce(projectileVelocity.normalized * 200f);\r\n\t\tcomponent.WakeUp();\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "CreateWorldProjectile",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnProjectileRicochet",
    "fullName": "OnProjectileRicochet",
    "category": "Weapon",
    "parameters": [
      {
        "name": "basePlayer",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "ProtoBuf.PlayerProjectileRicochet, Rust.Data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\npublic void OnProjectileRicochet(BaseEntity.RPCMessage msg)\r\n{\r\n\tProtoBuf.PlayerProjectileRicochet playerProjectileRicochet = ProtoBuf.PlayerProjectileRicochet.Deserialize(msg.read);\r\n\tif (playerProjectileRicochet != null)\r\n\t{\r\n\t\tBasePlayer.FiredProjectile value;\r\n\t\tif (UnityEngine.Vector3Ex.IsNaNOrInfinity(playerProjectileRicochet.hitPosition) || UnityEngine.Vector3Ex.IsNaNOrInfinity(playerProjectileRicochet.inVelocity) || UnityEngine.Vector3Ex.IsNaNOrInfinity(playerProjectileRicochet.outVelocity) || UnityEngine.Vector3Ex.IsNaNOrInfinity(playerProjectileRicochet.hitNormal) || float.IsNaN(playerProjectileRicochet.travelTime) || float.IsInfinity(playerProjectileRicochet.travelTime))\r\n\t\t{\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Contains NaN (\" + playerProjectileRicochet.projectileID + \")\");\r\n\t\t\tplayerProjectileRicochet.ResetToPool();\r\n\t\t\tplayerProjectileRicochet = null;\r\n\t\t}\r\n\t\telse if (!firedProjectiles.TryGetValue(playerProjectileRicochet.projectileID, out value))\r\n\t\t{\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Missing ID (\" + playerProjectileRicochet.projectileID + \")\", logToAnalytics: false);\r\n\t\t\tplayerProjectileRicochet.ResetToPool();\r\n\t\t\tplayerProjectileRicochet = null;\r\n\t\t}\r\n\t\telse if (value.firedTime < UnityEngine.Time.realtimeSinceStartup - 8f)\r\n\t\t{\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \"Lifetime is zero (\" + playerProjectileRicochet.projectileID + \")\");\r\n\t\t\tplayerProjectileRicochet.ResetToPool();\r\n\t\t\tplayerProjectileRicochet = null;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvalue.ricochets++;\r\n\t\t\tfiredProjectiles[playerProjectileRicochet.projectileID] = value;\r\n\t\t\tplayerProjectileRicochet.ResetToPool();\r\n\t\t\tplayerProjectileRicochet = null;\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnProjectileRicochet",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFlameThrowerBurn",
    "fullName": "OnFlameThrowerBurn",
    "category": "Weapon",
    "parameters": [
      {
        "name": "flameThrower",
        "type": "FlameThrower, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local13",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void FlameTick()\r\n{\r\n\tfloat num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;\r\n\tlastFlameTick = UnityEngine.Time.realtimeSinceStartup;\r\n\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSingletonComponent<NpcFireManager>.Instance.Move(this);\r\n\tReduceAmmo(num);\r\n\tSendNetworkUpdate();\r\n\tUnityEngine.Ray ray = ownerPlayer.eyes.BodyRay();\r\n\tUnityEngine.Vector3 origin = ray.origin;\r\n\tUnityEngine.RaycastHit hitInfo;\r\n\tbool num2 = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);\r\n\tif (!num2)\r\n\t{\r\n\t\thitInfo.point = origin + ray.direction * flameRange;\r\n\t}\r\n\tfloat num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);\r\n\tfloat amount = damagePerSec[0].amount;\r\n\tdamagePerSec[0].amount = amount * num * num3;\r\n\tint num4 = 2146305;\r\n\tint layers = 133376;\r\n\tif (!ownerPlayer.IsNpc)\r\n\t{\r\n\t\tnum4 |= 0x800;\r\n\t}\r\n\tDamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, num4, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true, extendedLineOfSight: true);\r\n\tdamagePerSec[0].amount = damagePerSec[0].amount * playerDamageMultiplier;\r\n\tDamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, layers, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true, extendedLineOfSight: true);\r\n\tdamagePerSec[0].amount = amount;\r\n\tif (num2 && UnityEngine.Time.realtimeSinceStartup >= nextFlameTime && hitInfo.distance > 1.1f)\r\n\t{\r\n\t\tnextFlameTime = UnityEngine.Time.realtimeSinceStartup + (ownerPlayer.IsNpc ? 0.25f : 0.45f);\r\n\t\tUnityEngine.Vector3 vector = hitInfo.point - ray.direction * 0.25f;\r\n\t\tUnityEngine.Vector3 vector2 = vector + new UnityEngine.Vector3(0f, 0.2f, 0f);\r\n\t\tbool flag = !GamePhysics.CheckSphere(vector, 0.1f, 1084293377);\r\n\t\tif (!flag && GamePhysics.LineOfSight(vector, vector2, 1084293377))\r\n\t\t{\r\n\t\t\tvector = vector2;\r\n\t\t\tflag = !GamePhysics.CheckSphere(vector, 0.1f, 1084293377);\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, vector);\r\n\t\t\tif ((bool)baseEntity)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity.creatorEntity = ownerPlayer;\r\n\t\t\t\tFireBall fireBall = baseEntity as FireBall;\r\n\t\t\t\tif (fireBall != null && ownerPlayer.IsNpc)\r\n\t\t\t\t{\r\n\t\t\t\t\tfireBall.ignoreNPC = true;\r\n\t\t\t\t}\r\n\t\t\t\tbaseEntity.Spawn();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (ammo == 0)\r\n\t{\r\n\t\tSetFlameState(wantsOn: false);\r\n\t}\r\n\tItem ownerItem = GetOwnerItem();\r\n\tif (ownerItem != null && !base.UsingInfiniteAmmoCheat && !ownerPlayer.IsNpc)\r\n\t{\r\n\t\townerItem.LoseCondition(num);\r\n\t}\r\n}\r\n",
    "targetName": "FlameThrower",
    "methodName": "FlameTick",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFireBallDamage",
    "fullName": "OnFireBallDamage",
    "category": "Weapon",
    "parameters": [
      {
        "name": "fireBall",
        "type": "FireBall, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local4",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local2",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void DoRadialDamage()\r\n{\r\n\tSystem.Collections.Generic.List<BaseCombatEntity> obj = Facepunch.Pool.Get<System.Collections.Generic.List<BaseCombatEntity>>();\r\n\tUnityEngine.Vector3 position = base.transform.position + new UnityEngine.Vector3(0f, radius * 0.75f, 0f);\r\n\tVis.Entities(position, radius, obj, AttackLayers, UnityEngine.QueryTriggerInteraction.Ignore);\r\n\tHitInfo hitInfo = new HitInfo();\r\n\thitInfo.DoHitEffects = true;\r\n\thitInfo.DidHit = true;\r\n\thitInfo.HitBone = 0u;\r\n\thitInfo.Initiator = ((creatorEntity == null) ? UnityEngine.GameObjectEx.ToBaseEntity(base.gameObject) : creatorEntity);\r\n\thitInfo.PointStart = base.transform.position;\r\n\tforeach (BaseCombatEntity item in obj)\r\n\t{\r\n\t\tif (!(item == null) && item.isServer && item.IsAlive() && (!ignoreNPC || !item.IsNpc) && item.IsVisible(position))\r\n\t\t{\r\n\t\t\tif (item is BasePlayer)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(\"assets/bundled/prefabs/fx/impacts/additive/fire.prefab\", item, 0u, new UnityEngine.Vector3(0f, 1f, 0f), UnityEngine.Vector3.up);\r\n\t\t\t}\r\n\t\t\thitInfo.PointEnd = item.transform.position;\r\n\t\t\thitInfo.HitPositionWorld = item.transform.position;\r\n\t\t\thitInfo.damageTypes.Set(Rust.DamageType.Heat, damagePerSecond * tickRate);\r\n\t\t\titem.OnAttacked(hitInfo);\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n}\r\n",
    "targetName": "FireBall",
    "methodName": "DoRadialDamage",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnFireBallSpread",
    "fullName": "OnFireBallSpread",
    "category": "Weapon",
    "parameters": [
      {
        "name": "fireBall",
        "type": "FireBall, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TryToSpread()\r\n{\r\n\tfloat num = 0.9f - generation * 0.1f;\r\n\tif (UnityEngine.Random.Range(0f, 1f) < num && spreadSubEntity.isValid)\r\n\t{\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.transform.position = base.transform.position + UnityEngine.Vector3.up * 0.25f;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tUnityEngine.Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, UnityEngine.Vector3.up);\r\n\t\t\tbaseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);\r\n\t\t\tbaseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));\r\n\t\t\tbaseEntity.SendMessage(\"SetGeneration\", generation + 1f);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "FireBall",
    "methodName": "TryToSpread",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnExplosiveFuseSet",
    "fullName": "OnExplosiveFuseSet",
    "category": "Weapon",
    "parameters": [
      {
        "name": "timedExplosive",
        "type": "TimedExplosive, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "fuseLength",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void SetFuse(float fuseLength)\r\n{\r\n\tif (base.isServer)\r\n\t{\r\n\t\tInvoke(Explode, fuseLength);\r\n\t\tSetFlag(BaseEntity.Flags.Reserved2, b: true);\r\n\t}\r\n}\r\n",
    "targetName": "TimedExplosive",
    "methodName": "SetFuse",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTimedExplosiveExplode",
    "fullName": "OnTimedExplosiveExplode",
    "category": "Weapon",
    "parameters": [
      {
        "name": "timedExplosive",
        "type": "TimedExplosive, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void Explode()\r\n{\r\n\tExplode(PivotPoint());\r\n}\r\n",
    "targetName": "TimedExplosive",
    "methodName": "Explode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFlameExplosion",
    "fullName": "OnFlameExplosion",
    "category": "Weapon",
    "parameters": [
      {
        "name": "flameExplosive",
        "type": "FlameExplosive, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local1",
        "type": "UnityEngine.Collider, UnityEngine.PhysicsModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void FlameExplode(UnityEngine.Vector3 surfaceNormal)\r\n{\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tUnityEngine.Vector3 position = base.transform.position;\r\n\tif (blockCreateUnderwater && WaterLevel.Test(position, waves: true, volumes: false))\r\n\t{\r\n\t\tbase.Explode();\r\n\t\treturn;\r\n\t}\r\n\tUnityEngine.Collider component = GetComponent<UnityEngine.Collider>();\r\n\tif ((bool)component)\r\n\t{\r\n\t\tcomponent.enabled = false;\r\n\t}\r\n\tfor (int i = 0; (float)i < numToCreate; i++)\r\n\t{\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tfloat num = (float)i / numToCreate;\r\n\t\t\tUnityEngine.Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);\r\n\t\t\tfloat y = UnityEngine.Random.Range(0f, 360f);\r\n\t\t\tUnityEngine.Quaternion rotation = UnityEngine.Quaternion.Euler(0f, y, 0f);\r\n\t\t\tbaseEntity.transform.SetPositionAndRotation(position, rotation);\r\n\t\t\tbaseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tUnityEngine.Vector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * UnityEngine.Random.Range(1f, 1.1f));\r\n\t\t\tFireBall component2 = baseEntity.GetComponent<FireBall>();\r\n\t\t\tif (component2 != null)\r\n\t\t\t{\r\n\t\t\t\tcomponent2.SetDelayedVelocity(vector);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbaseEntity.SetVelocity(vector);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tbase.Explode();\r\n}\r\n",
    "targetName": "FlameExplosive",
    "methodName": "FlameExplode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnImpactEffectCreate",
    "fullName": "OnImpactEffectCreate",
    "category": "Weapon",
    "parameters": [
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "customEffect",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "Effect+server",
    "methodName": "ImpactEffect",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "CanFireLiquidWeapon",
    "fullName": "CanFireLiquidWeapon",
    "category": "Weapon",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "liquidWeapon",
        "type": "LiquidWeapon, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CanFire(BasePlayer player)\r\n{\r\n\tif (RequiresPumping && pressure < PressureLossPerTick)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (player == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (HasFlag(BaseEntity.Flags.Open))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (AmountHeld() <= 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!player.CanInteract())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!player.CanAttack() || player.IsRunning())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tItem item = GetItem();\r\n\tif (item == null || item.contents == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "LiquidWeapon",
    "methodName": "CanFire",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnLiquidWeaponFired",
    "fullName": "OnLiquidWeaponFired",
    "category": "Weapon",
    "parameters": [
      {
        "name": "liquidWeapon",
        "type": "LiquidWeapon, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "local0",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void StartFiring(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (OnCooldown())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!RequiresPumping)\r\n\t{\r\n\t\tpressure = MaxPressure;\r\n\t}\r\n\tif (CanFire(player))\r\n\t{\r\n\t\tCancelInvoke(FireTick);\r\n\t\tInvokeRepeating(FireTick, 0f, FireRate);\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\tStartCooldown(FireRate);\r\n\t\tif (base.isServer)\r\n\t\t{\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "LiquidWeapon",
    "methodName": "StartFiring",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnLiquidWeaponFiringStopped",
    "fullName": "OnLiquidWeaponFiringStopped",
    "category": "Weapon",
    "parameters": [
      {
        "name": "liquidWeapon",
        "type": "LiquidWeapon, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void StopFiring()\r\n{\r\n\tCancelInvoke(FireTick);\r\n\tif (!RequiresPumping)\r\n\t{\r\n\t\tpressure = MaxPressure;\r\n\t}\r\n\tSetFlag(BaseEntity.Flags.On, b: false);\r\n\tif (base.isServer)\r\n\t{\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "LiquidWeapon",
    "methodName": "StopFiring",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanBeHomingTargeted",
    "fullName": "CanBeHomingTargeted [BaseHelicopter]",
    "category": "Weapon",
    "parameters": [
      {
        "name": "baseHelicopter",
        "type": "BaseHelicopter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool IsValidHomingTarget()\r\n{\r\n\treturn true;\r\n}\r\n",
    "targetName": "BaseHelicopter",
    "methodName": "IsValidHomingTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeHomingTargeted",
    "fullName": "CanBeHomingTargeted [CH47Helicopter]",
    "category": "Weapon",
    "parameters": [
      {
        "name": "cH47Helicopter",
        "type": "CH47Helicopter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool IsValidHomingTarget()\r\n{\r\n\treturn false;\r\n}\r\n",
    "targetName": "CH47Helicopter",
    "methodName": "IsValidHomingTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeHomingTargeted",
    "fullName": "CanBeHomingTargeted [PlayerHelicopter]",
    "category": "Weapon",
    "parameters": [
      {
        "name": "playerHelicopter",
        "type": "PlayerHelicopter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override bool IsValidHomingTarget()\r\n{\r\n\treturn IsOn();\r\n}\r\n",
    "targetName": "PlayerHelicopter",
    "methodName": "IsValidHomingTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeHomingTargeted",
    "fullName": "CanBeHomingTargeted [PatrolHelicopter]",
    "category": "Weapon",
    "parameters": [
      {
        "name": "patrolHelicopter",
        "type": "PatrolHelicopter, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool IsValidHomingTarget()\r\n{\r\n\treturn true;\r\n}\r\n",
    "targetName": "PatrolHelicopter",
    "methodName": "IsValidHomingTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeHomingTargeted",
    "fullName": "CanBeHomingTargeted [AttackHeliPilotFlare]",
    "category": "Weapon",
    "parameters": [
      {
        "name": "attackHeliPilotFlare",
        "type": "AttackHeliPilotFlare, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool IsValidHomingTarget()\r\n{\r\n\treturn true;\r\n}\r\n",
    "targetName": "AttackHeliPilotFlare",
    "methodName": "IsValidHomingTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanBeHomingTargeted",
    "fullName": "CanBeHomingTargeted [RoadFlare]",
    "category": "Weapon",
    "parameters": [
      {
        "name": "roadFlare",
        "type": "RoadFlare, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool IsValidHomingTarget()\r\n{\r\n\treturn true;\r\n}\r\n",
    "targetName": "RoadFlare",
    "methodName": "IsValidHomingTarget",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnExplosiveDud",
    "fullName": "OnExplosiveDud",
    "category": "Weapon",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void Explode()\r\n{\r\n\tif (creatorEntity != null && creatorEntity.IsNpc)\r\n\t{\r\n\t\tbase.Explode();\r\n\t}\r\n\telse if (UnityEngine.Random.Range(0f, 1f) < dudChance)\r\n\t{\r\n\t\tBecomeDud();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tbase.Explode();\r\n\t}\r\n}\r\n",
    "targetName": "DudTimedExplosive",
    "methodName": "Explode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnTerrainInitialized",
    "fullName": "OnTerrainInitialized",
    "category": "World",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void PostSetupComponents()\r\n{\r\n\tTerrainExtension[] components = GetComponents<TerrainExtension>();\r\n\tfor (int i = 0; i < components.Length; i++)\r\n\t{\r\n\t\tcomponents[i].PostSetup();\r\n\t}\r\n}\r\n",
    "targetName": "TerrainMeta",
    "methodName": "PostSetupComponents",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnWorldPrefabSpawned",
    "fullName": "OnWorldPrefabSpawned",
    "category": "World",
    "parameters": [
      {
        "name": "local0",
        "type": "UnityEngine.GameObject, UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "category",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void SpawnPrefab(string category, Prefab prefab, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Vector3 scale)\r\n{\r\n\tif (prefab != null && (bool)prefab.Object)\r\n\t{\r\n\t\tspawnTimer.Restart();\r\n\t\tif (!Cached)\r\n\t\t{\r\n\t\t\tprefab.ApplyTerrainPlacements(position, rotation, scale);\r\n\t\t\tprefab.ApplyTerrainModifiers(position, rotation, scale);\r\n\t\t}\r\n\t\tUnityEngine.GameObject gameObject = prefab.Spawn(position, rotation, scale);\r\n\t\tif ((bool)gameObject)\r\n\t\t{\r\n\t\t\tUnityEngine.GameObjectEx.SetHierarchyGroup(gameObject, category);\r\n\t\t}\r\n\t\tspawnTimer.Stop();\r\n\t\tspawnTimings.Add(new World.SpawnTiming\r\n\t\t{\r\n\t\t\tcategory = category,\r\n\t\t\tprefab = prefab,\r\n\t\t\tposition = position,\r\n\t\t\trotation = rotation,\r\n\t\t\tscale = scale,\r\n\t\t\ttime = spawnTimer.Elapsed\r\n\t\t});\r\n\t}\r\n}\r\n",
    "targetName": "World",
    "methodName": "SpawnPrefab",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnTerrainCreate",
    "fullName": "OnTerrainCreate",
    "category": "World",
    "parameters": [
      {
        "name": "terrainGenerator",
        "type": "TerrainGenerator, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public UnityEngine.GameObject CreateTerrain()\r\n{\r\n\treturn CreateTerrain(GetHeightMapRes(), GetSplatMapRes());\r\n}\r\n",
    "targetName": "TerrainGenerator",
    "methodName": "CreateTerrain",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "OnRconConnection [exp, patch]",
    "fullName": "OnRconConnection [exp, patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "Facepunch.RCon+RConListener",
    "methodName": "ProcessConnections",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLootEntity [patch]",
    "fullName": "OnLootEntity [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "#define UNITY_ASSERTIONS\r\npublic bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)\r\n{\r\n\tClear();\r\n\tif (!targetEntity)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!targetEntity.OnStartBeingLooted(base.baseEntity))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tUnityEngine.Assertions.Assert.IsTrue(targetEntity.isServer, \"Assure is server\");\r\n\tPositionChecks = doPositionChecks;\r\n\tentitySource = targetEntity;\r\n\titemSource = null;\r\n\tMarkDirty();\r\n\tif (targetEntity is ILootableEntity lootableEntity)\r\n\t{\r\n\t\tlootableEntity.LastLootedBy = base.baseEntity.userID;\r\n\t\tlootableEntity.LastLootedByPlayer = base.baseEntity;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "PlayerLoot",
    "methodName": "StartLootingEntity",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnLootItem [patch]",
    "fullName": "OnLootItem [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void StartLootingItem(Item item)\r\n{\r\n\tClear();\r\n\tif (item != null && item.contents != null)\r\n\t{\r\n\t\tPositionChecks = true;\r\n\t\tcontainers.Add(item.contents);\r\n\t\titem.contents.onDirty += MarkDirty;\r\n\t\titemSource = item;\r\n\t\tentitySource = item.GetWorldEntity();\r\n\t\tMarkDirty();\r\n\t}\r\n}\r\n",
    "targetName": "PlayerLoot",
    "methodName": "StartLootingItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnPlayerAttack [melee, patch]",
    "fullName": "OnPlayerAttack [melee, patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void DoAttackShared(HitInfo info)\r\n{\r\n\tGetAttackStats(info);\r\n\tif (info.HitEntity != null)\r\n\t{\r\n\t\tusing (TimeWarning.New(\"OnAttacked\", 50))\r\n\t\t{\r\n\t\t\tinfo.HitEntity.OnAttacked(info);\r\n\t\t}\r\n\t}\r\n\tif (info.DoHitEffects)\r\n\t{\r\n\t\tif (base.isServer)\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\"ImpactEffect\", 20))\r\n\t\t\t{\r\n\t\t\t\tEffect.server.ImpactEffect(info);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\"ImpactEffect\", 20))\r\n\t\t\t{\r\n\t\t\t\tEffect.client.ImpactEffect(info);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (base.isServer && !base.IsDestroyed)\r\n\t{\r\n\t\tusing (TimeWarning.New(\"UpdateItemCondition\", 50))\r\n\t\t{\r\n\t\t\tUpdateItemCondition(info);\r\n\t\t}\r\n\t\tStartAttackCooldown(repeatDelay);\r\n\t}\r\n}\r\n",
    "targetName": "BaseMelee",
    "methodName": "DoAttackShared",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnStructureDemolish [false, patch]",
    "fullName": "OnStructureDemolish [false, patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void DoDemolish(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && CanDemolish(msg.player))\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\r\n\t\tKill(BaseNetworkable.DestroyMode.Gib);\r\n\t}\r\n}\r\n",
    "targetName": "StabilityEntity",
    "methodName": "DoDemolish",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnStructureDemolish [true, patch]",
    "fullName": "OnStructureDemolish [true, patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void DoImmediateDemolish(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (msg.player.CanInteract() && msg.player.IsAdmin)\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\r\n\t\tKill(BaseNetworkable.DestroyMode.Gib);\r\n\t}\r\n}\r\n",
    "targetName": "StabilityEntity",
    "methodName": "DoImmediateDemolish",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "SetMaxHealthBasePlayer [patch]",
    "fullName": "SetMaxHealthBasePlayer [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override float MaxHealth()\r\n{\r\n\treturn 100f * (1f + ((modifiers != null) ? modifiers.GetValue(Modifier.ModifierType.Max_Health) : 0f));\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "MaxHealth",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "LimitNetworkingNoEffect [patch 3]",
    "fullName": "LimitNetworkingNoEffect [patch 3]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnAttacked(HitInfo info)\r\n{\r\n\tfloat oldHealth = base.health;\r\n\tif (InSafeZone() && !IsHostile() && info.Initiator != null && info.Initiator != this)\r\n\t{\r\n\t\tinfo.damageTypes.ScaleAll(0f);\r\n\t}\r\n\tif (base.isServer)\r\n\t{\r\n\t\tHitArea boneArea = info.boneArea;\r\n\t\tif (boneArea != (HitArea)(-1))\r\n\t\t{\r\n\t\t\tSystem.Collections.Generic.List<Item> obj = Facepunch.Pool.Get<System.Collections.Generic.List<Item>>();\r\n\t\t\tobj.AddRange(inventory.containerWear.itemList);\r\n\t\t\tfor (int i = 0; i < obj.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tItem item = obj[i];\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tItemModWearable component = item.info.GetComponent<ItemModWearable>();\r\n\t\t\t\t\tif (!(component == null) && component.ProtectsArea(boneArea))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titem.OnAttacked(info);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tFacepunch.Pool.Free(ref obj, freeElements: false);\r\n\t\t\tinventory.ServerUpdate(0f);\r\n\t\t}\r\n\t}\r\n\tbase.OnAttacked(info);\r\n\tif (base.isServer && base.isServer && info.hasDamage)\r\n\t{\r\n\t\tif (!info.damageTypes.Has(Rust.DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortalTo(info))\r\n\t\t{\r\n\t\t\tfloat num = ((modifiers != null) ? UnityEngine.Mathf.Clamp01(1f - modifiers.GetValue(Modifier.ModifierType.Clotting)) : 1f);\r\n\t\t\tmetabolism.bleeding.Add(info.damageTypes.Total() * 0.2f * num);\r\n\t\t}\r\n\t\tif (isMounted)\r\n\t\t{\r\n\t\t\tGetMounted().MounteeTookDamage(this, info);\r\n\t\t}\r\n\t\tCheckDeathCondition(info);\r\n\t\tif (net != null && net.connection != null)\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.Player(\"TakeDamageHit\", this));\r\n\t\t}\r\n\t\tstring text = StringPool.Get(info.HitBone);\r\n\t\tbool flag = UnityEngine.Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) > 0.4f;\r\n\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\r\n\t\tif ((bool)initiatorPlayer && !info.damageTypes.IsMeleeType())\r\n\t\t{\r\n\t\t\tinitiatorPlayer.LifeStoryShotHit(info.Weapon);\r\n\t\t}\r\n\t\tif (info.isHeadshot)\r\n\t\t{\r\n\t\t\tif (flag)\r\n\t\t\t{\r\n\t\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_RearHead, string.Empty);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_Head, string.Empty);\r\n\t\t\t}\r\n\t\t\tEffect.server.Run(\"assets/bundled/prefabs/fx/headshot.prefab\", this, 0u, new UnityEngine.Vector3(0f, 2f, 0f), UnityEngine.Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);\r\n\t\t\tif ((bool)initiatorPlayer)\r\n\t\t\t{\r\n\t\t\t\tinitiatorPlayer.stats.Add(\"headshot\", 1, (Stats)5);\r\n\t\t\t\tif (initiatorPlayer.IsBeingSpectated)\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (BaseEntity child in initiatorPlayer.children)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (child is BasePlayer basePlayer)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbasePlayer.ClientRPC(RpcTarget.Player(\"SpectatedPlayerHeadshot\", basePlayer));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (flag)\r\n\t\t{\r\n\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_RearTorso, string.Empty);\r\n\t\t}\r\n\t\telse if (text == \"spine\" || text == \"spine2\")\r\n\t\t{\r\n\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_Stomach, string.Empty);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSignalBroadcast(BaseEntity.Signal.Flinch_Chest, string.Empty);\r\n\t\t}\r\n\t}\r\n\tif (stats != null)\r\n\t{\r\n\t\tif (IsWounded())\r\n\t\t{\r\n\t\t\tstats.combat.LogAttack(info, \"wounded\", oldHealth);\r\n\t\t}\r\n\t\telse if (IsDead())\r\n\t\t{\r\n\t\t\tstats.combat.LogAttack(info, \"killed\", oldHealth);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstats.combat.LogAttack(info, \"\", oldHealth);\r\n\t\t}\r\n\t}\r\n\tif (ConVar.Global.cinematicGingerbreadCorpses)\r\n\t{\r\n\t\tinfo.HitMaterial = ConVar.Global.GingerbreadMaterialID();\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnAttacked",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "IncapacitatedFalseRespawn [patch]",
    "fullName": "IncapacitatedFalseRespawn [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void RespawnAt(UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, BaseEntity spawnPointEntity = null)\r\n{\r\n\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\r\n\tif ((bool)activeGameMode && !activeGameMode.CanPlayerRespawn(this))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Wounded, b: false);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Unused2, b: false);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.Unused1, b: false);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\r\n\tSetPlayerFlag(BasePlayer.PlayerFlags.DisplaySash, b: false);\r\n\trespawnId = System.Guid.NewGuid().ToString(\"N\");\r\n\tServerPerformance.spawns++;\r\n\tSetParent(null, worldPositionStays: true);\r\n\tbase.transform.SetPositionAndRotation(position, rotation);\r\n\ttickInterpolator.Reset(position);\r\n\ttickHistory.Reset(position);\r\n\teyeHistory.Clear();\r\n\testimatedVelocity = UnityEngine.Vector3.zero;\r\n\testimatedSpeed = 0f;\r\n\testimatedSpeed2D = 0f;\r\n\tlastTickTime = 0f;\r\n\tStopWounded();\r\n\tResetWoundingVars();\r\n\tStopSpectating();\r\n\tUpdateNetworkGroup();\r\n\tEnablePlayerCollider();\r\n\tRemovePlayerRigidbody();\r\n\tStartSleeping();\r\n\tLifeStoryStart();\r\n\tmetabolism.Reset();\r\n\tif (modifiers != null)\r\n\t{\r\n\t\tmodifiers.RemoveAll();\r\n\t}\r\n\tInitializeHealth(StartHealth(), StartMaxHealth());\r\n\tbool flag = false;\r\n\tif (ConVar.Server.respawnWithLoadout)\r\n\t{\r\n\t\tstring infoString = GetInfoString(\"client.respawnloadout\", string.Empty);\r\n\t\tif (!string.IsNullOrEmpty(infoString) && ConVar.Inventory.LoadLoadout(infoString, out var so))\r\n\t\t{\r\n\t\t\tso.LoadItemsOnTo(this);\r\n\t\t\tflag = true;\r\n\t\t}\r\n\t}\r\n\tif (!flag)\r\n\t{\r\n\t\tinventory.GiveDefaultItems();\r\n\t}\r\n\tSendNetworkUpdateImmediate();\r\n\tClientRPC(RpcTarget.Player(\"StartLoading\", this));\r\n\tFacepunch.Rust.Analytics.Azure.OnPlayerRespawned(this, spawnPointEntity);\r\n\tif ((bool)activeGameMode)\r\n\t{\r\n\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);\r\n\t}\r\n\tif (IsConnected)\r\n\t{\r\n\t\tEACServer.OnStartLoading(net.connection);\r\n\t}\r\n\tProcessMissionEvent(BaseMission.MissionEventType.RESPAWN, 0, 0f);\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "RespawnAt",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnFeedbackReported",
    "fullName": "OnFeedbackReported [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(1uL)]\r\npublic void OnFeedbackReport(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (ConVar.Server.printReportsToConsole || !string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))\r\n\t{\r\n\t\tstring text = msg.read.String();\r\n\t\tstring text2 = msg.read.StringMultiLine();\r\n\t\tFacepunch.Models.ReportType reportType = (Facepunch.Models.ReportType)UnityEngine.Mathf.Clamp(msg.read.Int32(), 0, 5);\r\n\t\tif (ConVar.Server.printReportsToConsole)\r\n\t\t{\r\n\t\t\tUnityEngine.DebugEx.Log($\"[FeedbackReport] {this} reported {reportType} - \\\"{text}\\\" \\\"{text2}\\\"\");\r\n\t\t\tFacepunch.RCon.Broadcast(Facepunch.RCon.LogType.Report, new\r\n\t\t\t{\r\n\t\t\t\tPlayerId = UserIDString,\r\n\t\t\t\tPlayerName = displayName,\r\n\t\t\t\tSubject = text,\r\n\t\t\t\tMessage = text2,\r\n\t\t\t\tType = reportType\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint) && reportType != Facepunch.Models.ReportType.BreakingServerRules)\r\n\t\t{\r\n\t\t\tstring image = msg.read.StringMultiLine(60000);\r\n\t\t\tFacepunch.Models.Feedback feedback = default(Facepunch.Models.Feedback);\r\n\t\t\tfeedback.Type = reportType;\r\n\t\t\tfeedback.Message = text2;\r\n\t\t\tfeedback.Subject = text;\r\n\t\t\tFacepunch.Models.Feedback feedback2 = feedback;\r\n\t\t\tfeedback2.AppInfo.Image = image;\r\n\t\t\tFacepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, userID, ConVar.Server.reportsServerEndpointKey, feedback2);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "OnFeedbackReport",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "NoLimboGroupForPlayers [patch]",
    "fullName": "NoLimboGroupForPlayers [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "#define UNITY_ASSERTIONS\r\npublic override void UpdateNetworkGroup()\r\n{\r\n\tUnityEngine.Assertions.Assert.IsTrue(base.isServer, \"UpdateNetworkGroup called on clientside entity!\");\r\n\tisCallingUpdateNetworkGroup = false;\r\n\tif (net == null || Network.Net.sv == null || Network.Net.sv.visibility == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"UpdateNetworkGroup\"))\r\n\t{\r\n\t\tif (globalBroadcast)\r\n\t\t{\r\n\t\t\tif (net.SwitchGroup(BaseNetworkable.GlobalNetworkGroup))\r\n\t\t\t{\r\n\t\t\t\tSendNetworkGroupChange();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (ShouldInheritNetworkGroup() && parentEntity.IsSet())\r\n\t\t{\r\n\t\t\tBaseEntity baseEntity = GetParentEntity();\r\n\t\t\tif (!baseEntity.IsValid())\r\n\t\t\t{\r\n\t\t\t\tif (!Rust.Application.isLoadingSave)\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Debug.LogWarning(\"UpdateNetworkGroup: Missing parent entity \" + parentEntity.uid.ToString());\r\n\t\t\t\t\tInvoke(UpdateNetworkGroup, 2f);\r\n\t\t\t\t\tisCallingUpdateNetworkGroup = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (baseEntity != null)\r\n\t\t\t{\r\n\t\t\t\tif (net.SwitchGroup(baseEntity.net.group))\r\n\t\t\t\t{\r\n\t\t\t\t\tSendNetworkGroupChange();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(base.gameObject?.ToString() + \": has parent id - but couldn't find parent! \" + parentEntity);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (base.limitNetworking)\r\n\t\t{\r\n\t\t\tif (net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))\r\n\t\t\t{\r\n\t\t\t\tSendNetworkGroupChange();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbase.UpdateNetworkGroup();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseEntity",
    "methodName": "UpdateNetworkGroup",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "FixItemKeyId [patch]",
    "fullName": "FixItemKeyId [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)\r\n{\r\n\tif (owner != null && owner.IsTransferring())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!CanCraft(bp, amount, free))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\ttaskUID++;\r\n\tItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();\r\n\titemCraftTask.blueprint = bp;\r\n\tif (!free)\r\n\t{\r\n\t\tCollectIngredients(bp, itemCraftTask, amount, owner);\r\n\t}\r\n\titemCraftTask.endTime = 0f;\r\n\titemCraftTask.taskUID = taskUID;\r\n\titemCraftTask.instanceData = instanceData;\r\n\tif (itemCraftTask.instanceData != null)\r\n\t{\r\n\t\titemCraftTask.instanceData.ShouldPool = false;\r\n\t}\r\n\titemCraftTask.amount = amount;\r\n\titemCraftTask.skinID = skinID;\r\n\tif (fromTempBlueprint != null && itemCraftTask.takenItems != null)\r\n\t{\r\n\t\tfromTempBlueprint.RemoveFromContainer();\r\n\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\r\n\t\titemCraftTask.conditionScale = 0.5f;\r\n\t}\r\n\tqueue.AddLast(itemCraftTask);\r\n\tif (owner != null)\r\n\t{\r\n\t\towner.Command(\"note.craft_add\", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "ItemCrafter",
    "methodName": "CraftItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCargoPlaneSignaled [Patch]",
    "fullName": "OnCargoPlaneSignaled [Patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void Explode()\r\n{\r\n\tBaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);\r\n\tif ((bool)baseEntity)\r\n\t{\r\n\t\tUnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\r\n\t\tbaseEntity.SendMessage(\"InitDropPosition\", base.transform.position + vector, UnityEngine.SendMessageOptions.DontRequireReceiver);\r\n\t\tbaseEntity.Spawn();\r\n\t}\r\n\tInvoke(FinishUp, 210f);\r\n\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\tSendNetworkUpdateImmediate();\r\n}\r\n",
    "targetName": "SupplySignal",
    "methodName": "Explode",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSupplyDropDropped [patch 1]",
    "fullName": "OnSupplyDropDropped [patch 1]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Update()\r\n{\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tsecondsTaken += UnityEngine.Time.deltaTime;\r\n\tfloat num = UnityEngine.Mathf.InverseLerp(0f, secondsToTake, secondsTaken);\r\n\tif (!dropped && num >= 0.5f)\r\n\t{\r\n\t\tdropped = true;\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t}\r\n\tbase.transform.position = UnityEngine.Vector3.Lerp(startPos, endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n\tif (num >= 1f)\r\n\t{\r\n\t\tKill();\r\n\t}\r\n}\r\n",
    "targetName": "CargoPlane",
    "methodName": "Update",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSupplyDropDropped [patch 2]",
    "fullName": "OnSupplyDropDropped [patch 2]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Update()\r\n{\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tsecondsTaken += UnityEngine.Time.deltaTime;\r\n\tfloat num = UnityEngine.Mathf.InverseLerp(0f, secondsToTake, secondsTaken);\r\n\tif (!dropped && num >= 0.5f)\r\n\t{\r\n\t\tdropped = true;\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t}\r\n\tbase.transform.position = UnityEngine.Vector3.Lerp(startPos, endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n\tif (num >= 1f)\r\n\t{\r\n\t\tKill();\r\n\t}\r\n}\r\n",
    "targetName": "CargoPlane",
    "methodName": "Update",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnSupplyDropDropped [patch 3]",
    "fullName": "OnSupplyDropDropped [patch 3]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void Update()\r\n{\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tsecondsTaken += UnityEngine.Time.deltaTime;\r\n\tfloat num = UnityEngine.Mathf.InverseLerp(0f, secondsToTake, secondsTaken);\r\n\tif (!dropped && num >= 0.5f)\r\n\t{\r\n\t\tdropped = true;\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);\r\n\t\tif ((bool)baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t}\r\n\tbase.transform.position = UnityEngine.Vector3.Lerp(startPos, endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n\tif (num >= 1f)\r\n\t{\r\n\t\tKill();\r\n\t}\r\n}\r\n",
    "targetName": "CargoPlane",
    "methodName": "Update",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "LimitNetworkingNoEffect [patch 1]",
    "fullName": "LimitNetworkingNoEffect [patch 1]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "Effect+server",
    "methodName": "ImpactEffect",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "LimitNetworkingNoEffect [patch 2]",
    "fullName": "LimitNetworkingNoEffect [patch 2]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.FromOwner(false)]\r\n[BaseEntity.RPC_Server.IsActiveItem]\r\npublic void CLProject(BaseEntity.RPCMessage msg)\r\n{\r\n\tBasePlayer player = msg.player;\r\n\tif (!VerifyClientAttack(player))\r\n\t{\r\n\t\tSendNetworkUpdate();\r\n\t\treturn;\r\n\t}\r\n\tif (reloadFinished && HasReloadCooldown())\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Reloading (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"reload_cooldown\");\r\n\t\treturn;\r\n\t}\r\n\treloadStarted = false;\r\n\treloadFinished = false;\r\n\tif (primaryMagazine.contents <= 0 && !base.UsingInfiniteAmmoCheat)\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Magazine empty (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"ammo_missing\");\r\n\t\treturn;\r\n\t}\r\n\tItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;\r\n\tProtoBuf.ProjectileShoot projectileShoot = ProtoBuf.ProjectileShoot.Deserialize(msg.read);\r\n\tif (primaryMagazineAmmo.itemid != projectileShoot.ammoType)\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Ammo mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"ammo_mismatch\");\r\n\t\treturn;\r\n\t}\r\n\tif (!base.UsingInfiniteAmmoCheat)\r\n\t{\r\n\t\tModifyAmmoCount(-1);\r\n\t}\r\n\tItemModProjectile component = primaryMagazineAmmo.GetComponent<ItemModProjectile>();\r\n\tif (component == null)\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Item mod not found (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"mod_missing\");\r\n\t}\r\n\telse if (projectileShoot.projectiles.Count > component.numProjectiles)\r\n\t{\r\n\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Count mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"count_mismatch\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (player.InGesture)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSignalBroadcast(BaseEntity.Signal.Attack, string.Empty, msg.connection, GetAttackEffect());\r\n\t\tplayer.CleanupExpiredProjectiles();\r\n\t\tSystem.Guid projectileGroupId = System.Guid.NewGuid();\r\n\t\tforeach (ProtoBuf.ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\r\n\t\t{\r\n\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\r\n\t\t\t{\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \"Duplicate ID (\" + projectile.projectileID + \")\");\r\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \"duplicate_id\");\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tUnityEngine.Vector3 positionOffset = UnityEngine.Vector3.zero;\r\n\t\t\tif (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))\r\n\t\t\t{\r\n\t\t\t\tif (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tUnityEngine.Vector3 position = player.eyes.position;\r\n\t\t\t\tpositionOffset = position - projectile.startPos;\r\n\t\t\t\tprojectile.startPos = position;\r\n\t\t\t}\r\n\t\t\telse if (!ValidateEyePos(player, projectile.startPos))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo, projectileGroupId, positionOffset);\r\n\t\t\tCreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());\r\n\t\t}\r\n\t\tplayer.MakeNoise(player.transform.position, BaseCombatEntity.ActionVolume.Loud);\r\n\t\tSingletonComponent<NpcNoiseManager>.Instance.OnWeaponShot(player, this);\r\n\t\tplayer.stats.Add(component.category + \"_fired\", System.Linq.Enumerable.Count(projectileShoot.projectiles), (Stats)5);\r\n\t\tplayer.LifeStoryShotFired(this);\r\n\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);\r\n\t\tplayer.MarkHostileFor();\r\n\t\tUpdateItemCondition();\r\n\t\tDidAttackServerside();\r\n\t\tBaseMountable mounted = player.GetMounted();\r\n\t\tif (mounted != null)\r\n\t\t{\r\n\t\t\tmounted.OnWeaponFired(this);\r\n\t\t}\r\n\t\tEACServer.LogPlayerUseWeapon(player, this);\r\n\t}\r\n}\r\n",
    "targetName": "BaseProjectile",
    "methodName": "CLProject",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "FixAIBrainTryThinkNRE [patch]",
    "fullName": "FixAIBrainTryThinkNRE [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void TryThink()\r\n{\r\n\tif (brain != null && brain.ShouldServerThink())\r\n\t{\r\n\t\tbrain.DoThink();\r\n\t}\r\n\telse if (brain == null && (float)lastBrainError > 10f)\r\n\t{\r\n\t\tlastBrainError = 0f;\r\n\t\tUnityEngine.Debug.LogWarning(base.gameObject.name + \" is missing a brain\");\r\n\t}\r\n}\r\n",
    "targetName": "BaseAnimalNPC",
    "methodName": "TryThink",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "ContinueTargetScan [patch]",
    "fullName": "ContinueTargetScan [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void TargetScan()\r\n{\r\n\tif (!target.IsRealNull() && (target == null || target.IsDead() || UnityEngine.Time.realtimeSinceStartup - lastTargetSeenTime > 3f || UnityEngine.Vector3.Distance(base.transform.position, target.transform.position) > sightRange || (PeacekeeperMode() && !IsEntityHostile(target))))\r\n\t{\r\n\t\tSetTarget(null);\r\n\t}\r\n\tif (!authDirty && !hasPotentialUnauthedTarget)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (HasInterference())\r\n\t{\r\n\t\tif (HasTarget())\r\n\t\t{\r\n\t\t\tSetTarget(null);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\thasPotentialUnauthedTarget = false;\r\n\tauthDirty = false;\r\n\tif (HasTarget() || IsOffline() || IsBeingControlled)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (targetTrigger.entityContents != null)\r\n\t{\r\n\t\tforeach (BaseEntity entityContent in targetTrigger.entityContents)\r\n\t\t{\r\n\t\t\tBaseCombatEntity baseCombatEntity = entityContent as BaseCombatEntity;\r\n\t\t\tif (baseCombatEntity == null)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (!ConVar.Sentry.targetall)\r\n\t\t\t{\r\n\t\t\t\tBasePlayer basePlayer = baseCombatEntity as BasePlayer;\r\n\t\t\t\tif (basePlayer != null && (IsAuthed(basePlayer) || Ignore(basePlayer)))\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!hasPotentialUnauthedTarget)\r\n\t\t\t{\r\n\t\t\t\thasPotentialUnauthedTarget = true;\r\n\t\t\t}\r\n\t\t\tif ((!PeacekeeperMode() || IsEntityHostile(baseCombatEntity)) && baseCombatEntity.IsAlive() && ShouldTarget(baseCombatEntity) && InFiringArc(baseCombatEntity) && ObjectVisible(baseCombatEntity))\r\n\t\t\t{\r\n\t\t\t\tSetTarget(baseCombatEntity);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (PeacekeeperMode() && target == null)\r\n\t{\r\n\t\tnextShotTime = UnityEngine.Time.time + 1f;\r\n\t}\r\n}\r\n",
    "targetName": "AutoTurret",
    "methodName": "TargetScan",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "LimitNetworkingAcquaintances [patch]",
    "fullName": "LimitNetworkingAcquaintances [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void UpdateAcquaintancesFor(BasePlayer player, float deltaSeconds)\r\n{\r\n\tRelationshipManager.PlayerRelationships playerRelationships = GetRelationships(player.userID);\r\n\tSystem.Collections.Generic.List<BasePlayer> obj = Facepunch.Pool.Get<System.Collections.Generic.List<BasePlayer>>();\r\n\tBaseNetworkable.GetCloseConnections(player.transform.position, GetAcquaintanceMaxDist(), obj);\r\n\tforeach (BasePlayer item in obj)\r\n\t{\r\n\t\tif (item == player || item.isClient || !item.IsAlive() || item.IsSleeping())\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tRelationshipManager.PlayerRelationshipInfo relations = playerRelationships.GetRelations(item.userID);\r\n\t\tif (!(UnityEngine.Vector3.Distance(player.transform.position, item.transform.position) <= GetAcquaintanceMaxDist()))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\trelations.lastSeenTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\tif ((relations.type == RelationshipManager.RelationshipType.NONE || relations.type == RelationshipManager.RelationshipType.Acquaintance) && player.IsPlayerVisibleToUs(item, UnityEngine.Vector3.zero, 1218519041))\r\n\t\t{\r\n\t\t\tint num = UnityEngine.Mathf.CeilToInt(deltaSeconds);\r\n\t\t\tif (player.InSafeZone() || item.InSafeZone())\r\n\t\t\t{\r\n\t\t\t\tnum = 0;\r\n\t\t\t}\r\n\t\t\tif (relations.type != RelationshipManager.RelationshipType.Acquaintance || (relations.weight < 60 && num > 0))\r\n\t\t\t{\r\n\t\t\t\tSetRelationship(player, item, RelationshipManager.RelationshipType.Acquaintance, num);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n}\r\n",
    "targetName": "RelationshipManager",
    "methodName": "UpdateAcquaintancesFor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "FixAIBrainThinkNRE [patch]",
    "fullName": "FixAIBrainThinkNRE [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void Think(float delta)\r\n{\r\n\tif (!ConVar.AI.think)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tlastThinkTime = UnityEngine.Time.time;\r\n\tif (sleeping || disabled)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tAge += delta;\r\n\tif (UseAIDesign)\r\n\t{\r\n\t\tSenses.Update();\r\n\t\tUpdateGroup();\r\n\t}\r\n\tif (CurrentState != null)\r\n\t{\r\n\t\tUpdateAgressionTimer(delta);\r\n\t\tStateStatus stateStatus = CurrentState.StateThink(delta, this, GetBaseEntity());\r\n\t\tif (Events != null)\r\n\t\t{\r\n\t\t\tEvents.Tick(delta, stateStatus);\r\n\t\t}\r\n\t}\r\n\tif (UseAIDesign || (CurrentState != null && !CurrentState.CanLeave()))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 0f;\r\n\tBaseAIBrain.BasicAIState basicAIState = null;\r\n\tforeach (BaseAIBrain.BasicAIState value in states.Values)\r\n\t{\r\n\t\tif (value != null && value.CanEnter())\r\n\t\t{\r\n\t\t\tfloat weight = value.GetWeight();\r\n\t\t\tif (weight > num)\r\n\t\t\t{\r\n\t\t\t\tnum = weight;\r\n\t\t\t\tbasicAIState = value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (basicAIState != CurrentState)\r\n\t{\r\n\t\tSwitchToState(basicAIState);\r\n\t}\r\n}\r\n",
    "targetName": "BaseAIBrain",
    "methodName": "Think",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "AllowNpcNonAdminHeliUse [patch]",
    "fullName": "AllowNpcNonAdminHeliUse [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void AttemptMount(BasePlayer player, bool doMountChecks = true)\r\n{\r\n\tif (player.IsNpc || player.IsAdmin)\r\n\t{\r\n\t\tbase.AttemptMount(player, doMountChecks);\r\n\t}\r\n}\r\n",
    "targetName": "CH47HelicopterAIController",
    "methodName": "AttemptMount",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OwnerID ConstructableEntity [patch]",
    "fullName": "OwnerID ConstructableEntity [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public override void OnRepairFinished()\r\n{\r\n\tbase.OnRepairFinished();\r\n\tKill();\r\n\tGameManager.server.CreateEntity(entityToSpawn.resourcePath, base.transform.position, base.transform.rotation).Spawn();\r\n\tif (spawnEffect.isValid)\r\n\t{\r\n\t\tEffect.server.Run(spawnEffect.resourcePath, base.transform.position, UnityEngine.Vector3.up);\r\n\t}\r\n}\r\n",
    "targetName": "ConstructableEntity",
    "methodName": "OnRepairFinished",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OwnerID SiegeTowerDoor [patch]",
    "fullName": "OwnerID SiegeTowerDoor [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void SetupDoor(SiegeTowerDoor door)\r\n{\r\n\tdoor.SetupDoor(this);\r\n\tdoor.SetMaxHealth(MaxHealth());\r\n\tdoor.SetHealth(MaxHealth());\r\n\tdoor.startHealth = MaxHealth();\r\n}\r\n",
    "targetName": "SiegeTower",
    "methodName": "SetupDoor",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "SingleCharCmdPrefix [patch]",
    "fullName": "SingleCharCmdPrefix [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "ConsoleSystem+Arg",
    "methodName": "BuildCommand",
    "assemblyName": "Facepunch.Console",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "SingleCharCmdSuffix [patch]",
    "fullName": "SingleCharCmdSuffix [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "",
    "targetName": "ConsoleSystem+Arg",
    "methodName": "BuildCommand",
    "assemblyName": "Facepunch.Console",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "System.Object"
  },
  {
    "name": "NoPragmaColumnExists",
    "fullName": "NoPragmaColumnExists [patch]",
    "category": "_Patches",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public bool ColumnExists(string tableName, string columnName)\r\n{\r\n\treturn Query<int, string, string>(\"select count(name) from pragma_table_info(?) where name=?;\", tableName, columnName) > 0;\r\n}\r\n",
    "targetName": "Facepunch.Sqlite.Database",
    "methodName": "ColumnExists",
    "assemblyName": "Facepunch.Sqlite",
    "hooksAssemblyName": "Carbon.Hooks.Oxide",
    "returnTypeName": "void"
  },
  {
    "name": "CanUseUI",
    "fullName": "CanUseUI",
    "category": "CUI",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "json",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool AddUi(BasePlayer player, string json)\r\n{\r\n\t//IL_0041: Unknown result type (might be due to invalid IL or missing references)\r\n\tif ((Object)(object)player == (Object)null || ((BaseNetworkable)player).net == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (Carbon.HookCaller.CallStaticHook(1307002116u, player, json) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\t((BaseEntity)CommunityEntity.ServerInstance).ClientRPC<string>(RpcTarget.Player(\"AddUI\", player), json);\r\n\treturn true;\r\n}\r\n",
    "targetName": "Oxide.Game.Rust.Cui.CuiHelper",
    "methodName": "AddUi",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnDestroyUI",
    "fullName": "OnDestroyUI",
    "category": "CUI",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "name",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool DestroyUi(BasePlayer player, string name)\r\n{\r\n\t//IL_0047: Unknown result type (might be due to invalid IL or missing references)\r\n\tif (((BaseNetworkable)(player?)).net != null)\r\n\t{\r\n\t\tSystem.Collections.Generic.HashSet<string> activePanelList = GetActivePanelList(player);\r\n\t\tif (activePanelList.Contains(name))\r\n\t\t{\r\n\t\t\tactivePanelList.Remove(name);\r\n\t\t}\r\n\t\tCarbon.HookCaller.CallStaticHook(503981600u, player, name);\r\n\t\t((BaseEntity)CommunityEntity.ServerInstance).ClientRPC<string>(RpcTarget.Player(\"DestroyUI\", player), name);\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "Oxide.Game.Rust.Cui.CuiHelper",
    "methodName": "DestroyUi",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnCompilationFail",
    "fullName": "OnCompilationFail",
    "category": "Engine",
    "parameters": [
      {
        "name": "file",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "result",
        "type": "Carbon.Core.ModLoader+CompilationResult, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Carbon.Managers.ScriptLoader.<Compile>d__51))]\r\npublic System.Collections.IEnumerator Compile()\r\n{\r\n\t//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()\r\n\treturn new Carbon.Managers.ScriptLoader.<Compile>d__51(0)\r\n\t{\r\n\t\t<>4__this = this\r\n\t};\r\n}\r\n",
    "targetName": "Carbon.Managers.ScriptLoader",
    "methodName": "Compile",
    "assemblyName": "Carbon",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnConstructorFail",
    "fullName": "OnConstructorFail",
    "category": "Engine",
    "parameters": [
      {
        "name": "plugin",
        "type": "Oxide.Plugins.RustPlugin, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "exception",
        "type": "System.Exception, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public static Oxide.Plugins.RustPlugin InitializePlugin(System.Reflection.Assembly assembly, Carbon.Core.ModLoader.Package package = default(Carbon.Core.ModLoader.Package), System.Action<Oxide.Plugins.RustPlugin> preInit = null, bool precompiled = false)\r\n{\r\n\tSystem.Type[] types = assembly.GetTypes();\r\n\tforeach (System.Type type in types)\r\n\t{\r\n\t\tif (!(type.BaseType == null) && IsValidPlugin(type.BaseType, recursive: false) && InitializePlugin(type, out var plugin, package, preInit, precompiled))\r\n\t\t{\r\n\t\t\treturn plugin;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n",
    "targetName": "Carbon.Core.ModLoader",
    "methodName": "InitializePlugin",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnPluginLoaded",
    "fullName": "OnPluginLoaded",
    "category": "Engine",
    "parameters": [
      {
        "name": "plugin",
        "type": "Oxide.Plugins.RustPlugin, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": null,
    "methodName": null,
    "assemblyName": null,
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnPluginUnloaded",
    "fullName": "OnPluginUnloaded",
    "category": "Engine",
    "parameters": [
      {
        "name": "plugin",
        "type": "Oxide.Plugins.RustPlugin, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static bool UninitializePlugin(Oxide.Plugins.RustPlugin plugin, bool premature = false, bool unloadDependantPlugins = true)\r\n{\r\n\tif (!premature && !plugin.IsLoaded)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tplugin.UnapplyOrderedPatches(Oxide.Core.Plugins.AutoPatchAttribute.Orders.Delayed);\r\n\tplugin.UnapplyOrderedPatches(Oxide.Core.Plugins.AutoPatchAttribute.Orders.AfterOnServerInitialized);\r\n\tplugin.UnapplyOrderedPatches(Oxide.Core.Plugins.AutoPatchAttribute.Orders.AfterPluginLoad);\r\n\tplugin.UnapplyOrderedPatches(Oxide.Core.Plugins.AutoPatchAttribute.Orders.AfterPluginInit);\r\n\tif (unloadDependantPlugins)\r\n\t{\r\n\t\tplugin.IUnloadDependantPlugins();\r\n\t}\r\n\tif (!premature)\r\n\t{\r\n\t\tplugin.CallHook(\"Unload\");\r\n\t}\r\n\tRemoveCommands(plugin);\r\n\tplugin.IUnload();\r\n\tif (!premature)\r\n\t{\r\n\t\tCarbon.HookCaller.CallStaticHook(1250294368u, plugin);\r\n\t}\r\n\tplugin.Dispose();\r\n\tif (!premature)\r\n\t{\r\n\t\tCarbon.Logger.Log(\"Unloaded plugin \" + plugin.ToPrettyString());\r\n\t\tOxide.Core.Interface.Oxide.RootPluginManager.RemovePlugin(plugin);\r\n\t\tOxide.Core.Plugins.Plugin.InternalApplyAllPluginReferences();\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "Carbon.Core.ModLoader",
    "methodName": "UninitializePlugin",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnGroupCreated",
    "fullName": "OnGroupCreated",
    "category": "Permissions",
    "parameters": [
      {
        "name": "group",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "title",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "rank",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool CreateGroup(string group, string title, int rank)\r\n{\r\n\tif (string.IsNullOrEmpty(group) || GroupExists(group))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tOxide.Core.Libraries.GroupData value = new Oxide.Core.Libraries.GroupData\r\n\t{\r\n\t\tTitle = title,\r\n\t\tRank = rank\r\n\t};\r\n\tif (!StringEx.IsLower(group))\r\n\t{\r\n\t\tgroup = group.ToLower();\r\n\t}\r\n\tgroupdata.Add(group, value);\r\n\tCarbon.HookCaller.CallStaticHook(1889097028u, group, title, rank);\r\n\treturn true;\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "CreateGroup",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnGroupDeleted",
    "fullName": "OnGroupDeleted",
    "category": "Permissions",
    "parameters": [
      {
        "name": "group",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool RemoveGroup(string group)\r\n{\r\n\tif (!GroupExists(group))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!StringEx.IsLower(group))\r\n\t{\r\n\t\tgroup = group.ToLower();\r\n\t}\r\n\tbool flag = groupdata.Remove(group);\r\n\tif (flag)\r\n\t{\r\n\t\tforeach (Oxide.Core.Libraries.GroupData item in System.Linq.Enumerable.Where(groupdata.Values, (Oxide.Core.Libraries.GroupData groupData) => groupData.ParentGroup == group))\r\n\t\t{\r\n\t\t\titem.ParentGroup = string.Empty;\r\n\t\t}\r\n\t}\r\n\tif (System.Linq.Enumerable.Aggregate(userdata.Values, seed: false, (bool current, Oxide.Core.Libraries.UserData userData) => current | userData.Groups.Remove(group)))\r\n\t{\r\n\t\tSaveUsers();\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tCarbon.HookCaller.CallStaticHook(3702696305u, group);\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "RemoveGroup",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnGroupParentSet",
    "fullName": "OnGroupParentSet",
    "category": "Permissions",
    "parameters": [
      {
        "name": "group",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "parentGroup",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool SetGroupParent(string group, string parent)\r\n{\r\n\tif (!GroupExists(group))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!StringEx.IsLower(group))\r\n\t{\r\n\t\tgroup = group.ToLower();\r\n\t}\r\n\tif (!groupdata.TryGetValue(group, out var value))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (string.IsNullOrEmpty(parent))\r\n\t{\r\n\t\tvalue.ParentGroup = null;\r\n\t\treturn true;\r\n\t}\r\n\tif (!StringEx.IsLower(parent))\r\n\t{\r\n\t\tparent = parent.ToLower();\r\n\t}\r\n\tif (!GroupExists(parent) || group.Equals(parent))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parent))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (HasCircularParent(group, parent))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tvalue.ParentGroup = parent;\r\n\tCarbon.HookCaller.CallStaticHook(3763369361u, group, parent);\r\n\treturn true;\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "SetGroupParent",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnGroupPermissionGranted",
    "fullName": "OnGroupPermissionGranted",
    "category": "Permissions",
    "parameters": [
      {
        "name": "group",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "permission",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool GrantGroupPermission(string name, string perm, Carbon.Base.BaseHookable owner)\r\n{\r\n\tif (!PermissionExists(perm, owner) || !GroupExists(name))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!StringEx.IsLower(name))\r\n\t{\r\n\t\tname = name.ToLower();\r\n\t}\r\n\tif (!groupdata.TryGetValue(name, out var data))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!StringEx.IsLower(perm))\r\n\t{\r\n\t\tperm = perm.ToLower();\r\n\t}\r\n\tif (perm.EndsWith(StarStr))\r\n\t{\r\n\t\tSystem.Collections.Generic.HashSet<string> value;\r\n\t\tif (owner == null)\r\n\t\t{\r\n\t\t\tvalue = new System.Collections.Generic.HashSet<string>(System.Linq.Enumerable.SelectMany(permset.Values, (System.Collections.Generic.HashSet<string> v) => v));\r\n\t\t}\r\n\t\telse if (!permset.TryGetValue(owner, out value))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (perm.Equals(StarStr))\r\n\t\t{\r\n\t\t\treturn System.Linq.Enumerable.Aggregate(value, seed: false, delegate(bool c, string s)\r\n\t\t\t{\r\n\t\t\t\tif (!(c | data.Perms.Add(s)))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tCarbon.HookCaller.CallStaticHook(2479711677u, name, perm);\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\t\tperm = perm.TrimEnd(Star).ToLower();\r\n\t\treturn System.Linq.Enumerable.Aggregate(System.Linq.Enumerable.Where(value, (string s) => s.StartsWith(perm)), seed: false, delegate(bool c, string s)\r\n\t\t{\r\n\t\t\tif (!(c | data.Perms.Add(s)))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tCarbon.HookCaller.CallStaticHook(2479711677u, name, perm);\r\n\t\t\treturn true;\r\n\t\t});\r\n\t}\r\n\tif (!data.Perms.Add(perm))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tCarbon.HookCaller.CallStaticHook(2479711677u, name, perm);\r\n\treturn true;\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "GrantGroupPermission",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnGroupPermissionRevoked",
    "fullName": "OnGroupPermissionRevoked",
    "category": "Permissions",
    "parameters": [
      {
        "name": "group",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "permission",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool RevokeGroupPermission(string name, string perm)\r\n{\r\n\tif (!GroupExists(name) || string.IsNullOrEmpty(perm))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!StringEx.IsLower(name))\r\n\t{\r\n\t\tname = name.ToLower();\r\n\t}\r\n\tif (!groupdata.TryGetValue(name, out var value))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!StringEx.IsLower(perm))\r\n\t{\r\n\t\tperm = perm.ToLower();\r\n\t}\r\n\tif (perm.EndsWith(StarStr))\r\n\t{\r\n\t\tif (!perm.Equals(StarStr))\r\n\t\t{\r\n\t\t\tperm = perm.TrimEnd(Star).ToLower();\r\n\t\t\treturn value.Perms.RemoveWhere(delegate(string s)\r\n\t\t\t{\r\n\t\t\t\tif (!s.StartsWith(perm))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tCarbon.HookCaller.CallStaticHook(3443835039u, name, s);\r\n\t\t\t\treturn true;\r\n\t\t\t}) > 0;\r\n\t\t}\r\n\t\tif (value.Perms.Count <= 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tforeach (string perm2 in value.Perms)\r\n\t\t{\r\n\t\t\tCarbon.HookCaller.CallStaticHook(3443835039u, name, perm2);\r\n\t\t}\r\n\t\tvalue.Perms.Clear();\r\n\t\treturn true;\r\n\t}\r\n\tif (!value.Perms.Remove(perm))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tCarbon.HookCaller.CallStaticHook(3443835039u, name, perm);\r\n\treturn true;\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "RevokeGroupPermission",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnGroupRankSet",
    "fullName": "OnGroupRankSet",
    "category": "Permissions",
    "parameters": [
      {
        "name": "group",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "rank",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool SetGroupRank(string group, int rank)\r\n{\r\n\tif (!GroupExists(group))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!StringEx.IsLower(group))\r\n\t{\r\n\t\tgroup = group.ToLower();\r\n\t}\r\n\tif (!groupdata.TryGetValue(group, out var value))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (value.Rank == rank)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tvalue.Rank = rank;\r\n\tCarbon.HookCaller.CallStaticHook(407332709u, group, rank);\r\n\treturn true;\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "SetGroupRank",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnGroupTitleSet",
    "fullName": "OnGroupTitleSet",
    "category": "Permissions",
    "parameters": [
      {
        "name": "group",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "title",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual bool SetGroupTitle(string group, string title)\r\n{\r\n\tif (!GroupExists(group))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (!StringEx.IsLower(group))\r\n\t{\r\n\t\tgroup = group.ToLower();\r\n\t}\r\n\tif (!groupdata.TryGetValue(group, out var value))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (value.Title == title)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tvalue.Title = title;\r\n\tCarbon.HookCaller.CallStaticHook(1035562059u, group, title);\r\n\treturn true;\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "SetGroupTitle",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnPermissionRegistered",
    "fullName": "OnPermissionRegistered",
    "category": "Permissions",
    "parameters": [
      {
        "name": "permission",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "plugin",
        "type": "Oxide.Core.Plugins.Plugin, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void RegisterPermission(string name, Carbon.Base.BaseHookable owner)\r\n{\r\n\tif (string.IsNullOrEmpty(name))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!StringEx.IsLower(name))\r\n\t{\r\n\t\tname = name.ToLower();\r\n\t}\r\n\tif (PermissionExists(name, owner))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (PermissionExists(name))\r\n\t{\r\n\t\tCarbon.Logger.Warn(\"Trying to register permission '\" + name + \"' but already used by another plugin. (Requestee plugin '\" + owner.Name + \"')\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!permset.TryGetValue(owner, out var value))\r\n\t\t{\r\n\t\t\tvalue = new System.Collections.Generic.HashSet<string>();\r\n\t\t\tpermset.Add(owner, value);\r\n\t\t}\r\n\t\tvalue.Add(name);\r\n\t\tCarbon.HookCaller.CallStaticHook(4257240972u, name, owner);\r\n\t}\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "RegisterPermission",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnPermissionsUnregistered",
    "fullName": "OnPermissionsUnregistered",
    "category": "Permissions",
    "parameters": [
      {
        "name": "plugin",
        "type": "Oxide.Core.Plugins.Plugin, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void UnregisterPermissions(Carbon.Base.BaseHookable owner)\r\n{\r\n\tif (owner != null && permset.TryGetValue(owner, out var value))\r\n\t{\r\n\t\tvalue.Clear();\r\n\t\tpermset.Remove(owner);\r\n\t\tCarbon.HookCaller.CallStaticHook(2952085131u, owner);\r\n\t}\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "UnregisterPermissions",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserGroupAdded",
    "fullName": "OnUserGroupAdded",
    "category": "Permissions",
    "parameters": [
      {
        "name": "playerId",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "group",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void AddUserGroup(string id, string name)\r\n{\r\n\tif (GroupExists(name) && GetUserData(id).Groups.Add(name.ToLower()))\r\n\t{\r\n\t\tCarbon.HookCaller.CallStaticHook(3116013984u, id, name);\r\n\t}\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "AddUserGroup",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserGroupRemoved",
    "fullName": "OnUserGroupRemoved",
    "category": "Permissions",
    "parameters": [
      {
        "name": "playerId",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "group",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void RemoveUserGroup(string id, string name)\r\n{\r\n\tif (!GroupExists(name))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tOxide.Core.Libraries.UserData userData = GetUserData(id);\r\n\tif (name.Equals(StarStr))\r\n\t{\r\n\t\tif (userData.Groups.Count <= 0)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tforeach (string group in userData.Groups)\r\n\t\t{\r\n\t\t\tCarbon.HookCaller.CallStaticHook(1018697706u, id, group);\r\n\t\t}\r\n\t\tuserData.Groups.Clear();\r\n\t}\r\n\telse if (userData.Groups.Remove(name.ToLower()))\r\n\t{\r\n\t\tCarbon.HookCaller.CallStaticHook(1018697706u, id, name);\r\n\t}\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "RemoveUserGroup",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserNameUpdated",
    "fullName": "OnUserNameUpdated",
    "category": "Permissions",
    "parameters": [
      {
        "name": "id",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "oldName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "newName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public virtual void UpdateNickname(string id, string nickname)\r\n{\r\n\tif (UserExists(id))\r\n\t{\r\n\t\tOxide.Core.Libraries.UserData userData = GetUserData(id);\r\n\t\tstring lastSeenNickname = userData.LastSeenNickname;\r\n\t\tuserData.LastSeenNickname = nickname.Sanitize();\r\n\t\tCarbon.HookCaller.CallStaticHook(4255507790u, id, lastSeenNickname, userData.LastSeenNickname);\r\n\t}\r\n}\r\n",
    "targetName": "Oxide.Core.Libraries.Permission",
    "methodName": "UpdateNickname",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "CanPatrolHeliSeePlayer",
    "fullName": "CanPatrolHeliSeePlayer",
    "category": "Global",
    "parameters": [
      {
        "name": "heli",
        "type": "PatrolHelicopterAI, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public bool PlayerVisible(BasePlayer ply)\r\n{\r\n\tusing (TimeWarning.New(\"PatrolHelicoperAI.PlayerVisible\"))\r\n\t{\r\n\t\tUnityEngine.Vector3 position = ply.eyes.position;\r\n\t\tif (ply.eyes.position.y < WaterSystem.OceanLevel && UnityEngine.Mathf.Abs(WaterSystem.OceanLevel - ply.eyes.position.y) > oceanDepthTargetCutoff)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (TOD_Sky.Instance.IsNight && UnityEngine.Vector3.Distance(position, interestZoneOrigin) > 40f)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tUnityEngine.Vector3 vector = base.transform.position - UnityEngine.Vector3.up * 6f;\r\n\t\tfloat num = UnityEngine.Vector3.Distance(position, vector);\r\n\t\tUnityEngine.Vector3 normalized = (position - vector).normalized;\r\n\t\tif (GamePhysics.Trace(new UnityEngine.Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && UnityEngine.GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n",
    "targetName": "PatrolHelicopterAI",
    "methodName": "PlayerVisible",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanPickupAllFromRack",
    "fullName": "CanPickupAllFromRack",
    "category": "Global",
    "parameters": [
      {
        "name": "rack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "mountSlotIndex",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void GivePlayerAllWeapons(BasePlayer player, int mountSlotIndex)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\r\n\tif (weaponAtIndex != null)\r\n\t{\r\n\t\tGivePlayerWeapon(player, weaponAtIndex.GridSlotIndex);\r\n\t}\r\n\tfor (int num = gridSlots.Length - 1; num >= 0; num--)\r\n\t{\r\n\t\tWeaponRackSlot weaponRackSlot = gridSlots[num];\r\n\t\tif (weaponRackSlot.Used)\r\n\t\t{\r\n\t\t\tGivePlayerWeapon(player, weaponRackSlot.GridSlotIndex, -1, tryHold: false);\r\n\t\t}\r\n\t}\r\n\tItemManager.DoRemoves();\r\n\tSendNetworkUpdateImmediate();\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "GivePlayerAllWeapons",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanPickupFromRack",
    "fullName": "CanPickupFromRack",
    "category": "Global",
    "parameters": [
      {
        "name": "rack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "mountSlotIndex",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "playerBeltIndex",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "tryHold",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\r\n\tif (weaponAtIndex == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tClearSlot(weaponAtIndex);\r\n\tbool flag = false;\r\n\tbool flag2 = true;\r\n\tif (slot.IsBackpack())\r\n\t{\r\n\t\tflag2 = false;\r\n\t\tif (slot.info.GetComponent<ItemModBackpack>() != null && player.inventory.GetAnyBackpack() == null)\r\n\t\t{\r\n\t\t\tflag = slot.MoveToContainer(player.inventory.containerWear);\r\n\t\t}\r\n\t}\r\n\tif (!flag)\r\n\t{\r\n\t\tflag = slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex);\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tif (flag2 && ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1))\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.Player(\"SetActiveBeltSlot\", player), slot.position, slot.uid);\r\n\t\t}\r\n\t\tClientRPC(RpcTarget.Player(\"PlayGrabSound\", player), slot.info.itemid);\r\n\t}\r\n\telse if (!slot.MoveToContainer(player.inventory.containerMain))\r\n\t{\r\n\t\tslot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\r\n\t}\r\n\tif (sendUpdate)\r\n\t{\r\n\t\tItemManager.DoRemoves();\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "GivePlayerWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanPlaceOnRack",
    "fullName": "CanPlaceOnRack",
    "category": "Global",
    "parameters": [
      {
        "name": "rack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "gridCellIndex",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "rotation",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void MountWeapon(BasePlayer player, int gridCellIndex, int rotation)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tHeldEntity heldEntity = player.GetHeldEntity();\r\n\tif (!(heldEntity == null))\r\n\t{\r\n\t\tItem item = heldEntity.GetItem();\r\n\t\tif (item != null)\r\n\t\t{\r\n\t\t\tMountWeapon(item, player, gridCellIndex, rotation);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "MountWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPickupFromRack",
    "fullName": "OnPickupFromRack",
    "category": "Global",
    "parameters": [
      {
        "name": "rack",
        "type": "WeaponRack, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "mountSlotIndex",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "playerBeltIndex",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "tryHold",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)\r\n{\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tWeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);\r\n\tif (weaponAtIndex == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tItem slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tClearSlot(weaponAtIndex);\r\n\tbool flag = false;\r\n\tbool flag2 = true;\r\n\tif (slot.IsBackpack())\r\n\t{\r\n\t\tflag2 = false;\r\n\t\tif (slot.info.GetComponent<ItemModBackpack>() != null && player.inventory.GetAnyBackpack() == null)\r\n\t\t{\r\n\t\t\tflag = slot.MoveToContainer(player.inventory.containerWear);\r\n\t\t}\r\n\t}\r\n\tif (!flag)\r\n\t{\r\n\t\tflag = slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex);\r\n\t}\r\n\tif (flag)\r\n\t{\r\n\t\tif (flag2 && ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1))\r\n\t\t{\r\n\t\t\tClientRPC(RpcTarget.Player(\"SetActiveBeltSlot\", player), slot.position, slot.uid);\r\n\t\t}\r\n\t\tClientRPC(RpcTarget.Player(\"PlayGrabSound\", player), slot.info.itemid);\r\n\t}\r\n\telse if (!slot.MoveToContainer(player.inventory.containerMain))\r\n\t{\r\n\t\tslot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\r\n\t}\r\n\tif (sendUpdate)\r\n\t{\r\n\t\tItemManager.DoRemoves();\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "WeaponRack",
    "methodName": "GivePlayerWeapon",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnChairComfort",
    "fullName": "OnChairComfort",
    "category": "Global",
    "parameters": [
      {
        "name": "chair",
        "type": "BaseChair, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public override float GetComfort()\r\n{\r\n\treturn 1f;\r\n}\r\n",
    "targetName": "BaseChair",
    "methodName": "GetComfort",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Single"
  },
  {
    "name": "OnEntitySpawn",
    "fullName": "OnEntitySpawn",
    "category": "Global",
    "parameters": [
      {
        "name": "networkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public virtual void Spawn()\r\n{\r\n\tFacepunch.Rust.Profiling.EntityProfiler.spawned++;\r\n\tif (Facepunch.Rust.Profiling.EntityProfiler.mode >= 2)\r\n\t{\r\n\t\tFacepunch.Rust.Profiling.EntityProfiler.OnSpawned(this);\r\n\t}\r\n\tSpawnShared();\r\n\tif (net == null)\r\n\t{\r\n\t\tnet = Network.Net.sv.CreateNetworkable();\r\n\t}\r\n\tcreationFrame = UnityEngine.Time.frameCount;\r\n\tPreInitShared();\r\n\tInitShared();\r\n\tServerInit();\r\n\tPostInitShared();\r\n\tUpdateNetworkGroup();\r\n\tServerInitPostNetworkGroupAssign();\r\n\tisSpawned = true;\r\n\tSendNetworkUpdateImmediate(justCreated: true);\r\n\tInvoke(SendGlobalNetworkUpdate, 0f);\r\n\tif (Rust.Application.isLoading && !Rust.Application.isLoadingSave)\r\n\t{\r\n\t\tbase.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);\r\n\t}\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "Spawn",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnEntityTakeDamage",
    "fullName": "OnEntityTakeDamage",
    "category": "Entity",
    "parameters": [
      {
        "name": "entity",
        "type": "BaseCombatEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "HitInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnChickenScared",
    "fullName": "OnChickenScared",
    "category": "Global",
    "parameters": [
      {
        "name": "chicken",
        "type": "Chicken, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "threat",
        "type": "BaseEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "",
    "targetName": "AnimalBrain+FleeState",
    "methodName": "StateEnter",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "CanAcceptBackpackItem",
    "fullName": "CanAcceptBackpackItem",
    "category": "Global",
    "parameters": [
      {
        "name": "backpack",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public bool CanAcceptItem(Item backpack, Item item, int slot)\r\n{\r\n\tif (backpack.parent == null)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tif (backpack.parent.HasFlag(ItemContainer.Flag.Clothing))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "ItemModBackpack",
    "methodName": "CanAcceptItem",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnJackieChan",
    "fullName": "OnJackieChan",
    "category": "Global",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void PlayerInit(Network.Connection c)\r\n{\r\n\tusing (TimeWarning.New(\"PlayerInit\", 10))\r\n\t{\r\n\t\tCancelInvoke(base.KillMessage);\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.Connected, b: true);\r\n\t\tactivePlayerList.Add(this);\r\n\t\tbots.Remove(this);\r\n\t\tuserID = c.userid;\r\n\t\tUserIDString = userID.Get().ToString();\r\n\t\tdisplayName = c.username;\r\n\t\tc.player = this;\r\n\t\tsecondsConnected = 0;\r\n\t\tcurrentTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userID)?.teamID ?? 0;\r\n\t\tSingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(userID, displayName);\r\n\t\ttickInterpolator.Reset(base.transform.position);\r\n\t\ttickHistory.Reset(base.transform.position);\r\n\t\teyeHistory.Clear();\r\n\t\tlastTickTime = 0f;\r\n\t\tlastInputTime = 0f;\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\r\n\t\tstats.Init();\r\n\t\tInvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));\r\n\t\tpreviousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, c.authLevel != 0);\r\n\t\tSetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));\r\n\t\tif (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))\r\n\t\t{\r\n\t\t\tSendNetworkGroupChange();\r\n\t\t}\r\n\t\tnet.OnConnected(c);\r\n\t\tnet.StartSubscriber();\r\n\t\tSendAsSnapshot(net.connection);\r\n\t\tGlobalNetworkHandler.server.StartSendingSnapshot(this);\r\n\t\tClientRPC(RpcTarget.Player(\"StartLoading\", this));\r\n\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\r\n\t\t{\r\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);\r\n\t\t}\r\n\t\tif (net != null)\r\n\t\t{\r\n\t\t\tEACServer.OnStartLoading(net.connection);\r\n\t\t}\r\n\t\tif (IsAdmin)\r\n\t\t{\r\n\t\t\tif (ConVar.AntiHack.noclip_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.noclip_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.speedhack_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.speedhack_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.flyhack_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.flyhack_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.projectile_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.projectile_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.melee_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.melee_protection is disabled!\");\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.eye_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tChatMessage(\"antihack.eye_protection is disabled!\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tinventory.crafting.SendToOwner();\r\n\t\tif (TerrainMeta.Path != null && TerrainMeta.Path.OceanPatrolFar != null)\r\n\t\t{\r\n\t\t\tSendCargoPatrolPath();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "PlayerInit",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "CanClientLogin",
    "fullName": "CanClientLogin",
    "category": "Player",
    "parameters": [
      {
        "name": "connection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "CanUserLogin",
    "fullName": "CanUserLogin",
    "category": "Player",
    "parameters": [
      {
        "name": "username",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "userid",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "ip",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnPlayerBanned",
    "fullName": "OnPlayerBanned",
    "category": "Player",
    "parameters": [
      {
        "name": "connection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "reason",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerChat",
    "fullName": "OnPlayerChat",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "message",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "channel",
        "type": "ConVar.Chat+ChatChannel, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static object IOnPlayerChat(ulong playerId, string playerName, string message, ChatChannel channel, BasePlayer basePlayer)\r\n{\r\n\t//IL_0065: Unknown result type (might be due to invalid IL or missing references)\r\n\t//IL_004f: Unknown result type (might be due to invalid IL or missing references)\r\n\tif (string.IsNullOrEmpty(message) || message.Equals(\"text\"))\r\n\t{\r\n\t\treturn Carbon.Cache.True;\r\n\t}\r\n\tif ((Object)(object)basePlayer == (Object)null || !basePlayer.IsConnected)\r\n\t{\r\n\t\treturn Carbon.HookCaller.CallStaticHook(4068177051u, playerId, playerName, message, channel);\r\n\t}\r\n\tobject obj = Carbon.HookCaller.CallStaticHook(2032160890u, basePlayer, message, channel);\r\n\tobject obj2 = Carbon.HookCaller.CallStaticHook(2894159933u, basePlayer.AsIPlayer(), message);\r\n\treturn obj ?? obj2;\r\n}\r\n",
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": "IOnPlayerChat",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerConnected",
    "fullName": "OnPlayerConnected",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnPlayerOfflineChat",
    "fullName": "OnPlayerOfflineChat",
    "category": "Player",
    "parameters": [
      {
        "name": "playerid",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "username",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "message",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "channel",
        "type": "ConVar.Chat+ChatChannel, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserApprove",
    "fullName": "OnUserApprove",
    "category": "Player",
    "parameters": [
      {
        "name": "connection",
        "type": "Network.Connection, Facepunch.Network, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserApproved",
    "fullName": "OnUserApproved",
    "category": "Player",
    "parameters": [
      {
        "name": "username",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "userid",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "ip",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserChat",
    "fullName": "OnUserChat",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "Oxide.Core.Libraries.Covalence.IPlayer, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "message",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static object IOnPlayerChat(ulong playerId, string playerName, string message, ChatChannel channel, BasePlayer basePlayer)\r\n{\r\n\t//IL_0065: Unknown result type (might be due to invalid IL or missing references)\r\n\t//IL_004f: Unknown result type (might be due to invalid IL or missing references)\r\n\tif (string.IsNullOrEmpty(message) || message.Equals(\"text\"))\r\n\t{\r\n\t\treturn Carbon.Cache.True;\r\n\t}\r\n\tif ((Object)(object)basePlayer == (Object)null || !basePlayer.IsConnected)\r\n\t{\r\n\t\treturn Carbon.HookCaller.CallStaticHook(4068177051u, playerId, playerName, message, channel);\r\n\t}\r\n\tobject obj = Carbon.HookCaller.CallStaticHook(2032160890u, basePlayer, message, channel);\r\n\tobject obj2 = Carbon.HookCaller.CallStaticHook(2894159933u, basePlayer.AsIPlayer(), message);\r\n\treturn obj ?? obj2;\r\n}\r\n",
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": "IOnPlayerChat",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserConnected",
    "fullName": "OnUserConnected",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "Oxide.Core.Libraries.Covalence.IPlayer, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserKicked",
    "fullName": "OnUserKicked",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "Oxide.Core.Libraries.Covalence.IPlayer, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "reason",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserRespawn",
    "fullName": "OnUserRespawn",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "Oxide.Core.Libraries.Covalence.IPlayer, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnUserRespawned",
    "fullName": "OnUserRespawned",
    "category": "Player",
    "parameters": [
      {
        "name": "player",
        "type": "Oxide.Core.Libraries.Covalence.IPlayer, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "CanPlayerInheritNetworkGroup",
    "fullName": "CanPlayerInheritNetworkGroup",
    "category": "Global",
    "parameters": [
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public override bool ShouldInheritNetworkGroup()\r\n{\r\n\treturn IsSpectating();\r\n}\r\n",
    "targetName": "BasePlayer",
    "methodName": "ShouldInheritNetworkGroup",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnGrowableUpdate",
    "fullName": "OnGrowableUpdate",
    "category": "Global",
    "parameters": [
      {
        "name": "growable",
        "type": "GrowableEntity, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void RunUpdate()\r\n{\r\n\tif (!IsDead())\r\n\t{\r\n\t\tCalculateQualities(firstTime: false);\r\n\t\tfloat overallQuality = CalculateOverallQuality();\r\n\t\tfloat actualStageAgeIncrease = UpdateAge(overallQuality);\r\n\t\tUpdateHealthAndYield(overallQuality, actualStageAgeIncrease);\r\n\t\tif (base.health <= 0f)\r\n\t\t{\r\n\t\t\tTellPlanter();\r\n\t\t\tDie();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tUpdateState();\r\n\t\t\tConsumeWater();\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "GrowableEntity",
    "methodName": "RunUpdate",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "void"
  },
  {
    "name": "OnServerCommand",
    "fullName": "OnServerCommand",
    "category": "Server",
    "parameters": [
      {
        "name": "arg",
        "type": "ConsoleSystem+Arg, Facepunch.Console, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnCupboardAssign",
    "fullName": "OnCupboardAssign",
    "category": "Structure",
    "parameters": [
      {
        "name": "priv",
        "type": "BuildingPrivlidge, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "targetId",
        "type": "System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnCupboardAuthorize",
    "fullName": "OnCupboardAuthorize",
    "category": "Structure",
    "parameters": [
      {
        "name": "priv",
        "type": "BuildingPrivlidge, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Object"
  },
  {
    "name": "OnMarketplaceTerminalPurchase",
    "fullName": "OnMarketplaceTerminalPurchase",
    "category": "Vending",
    "parameters": [
      {
        "name": "terminal",
        "type": "MarketTerminal, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "vending",
        "type": "VendingMachine, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "player",
        "type": "BasePlayer, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "sellOrderIndex",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "amount",
        "type": "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\n[BaseEntity.RPC_Server.CallsPerSecond(10uL)]\r\npublic void Server_Purchase(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (!CanPlayerInteract(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!_marketplace.IsValid(serverside: true))\r\n\t{\r\n\t\tUnityEngine.Debug.LogError(\"Marketplace is not set\", this);\r\n\t\treturn;\r\n\t}\r\n\tNetworkableId networkableId = msg.read.EntityID();\r\n\tint num = msg.read.Int32();\r\n\tint num2 = msg.read.Int32();\r\n\tVendingMachine vendingMachine = BaseNetworkable.serverEntities.Find(networkableId) as VendingMachine;\r\n\tif (vendingMachine == null || !vendingMachine.IsValid() || num < 0 || num >= vendingMachine.sellOrders.sellOrders.Count || num2 <= 0 || base.inventory.IsFull())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tGetDeliveryEligibleVendingMachines(null);\r\n\tif (_deliveryEligible == null || !_deliveryEligible.Contains(networkableId))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttry\r\n\t{\r\n\t\t_transactionActive = true;\r\n\t\tint num3 = deliveryFeeAmount;\r\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = vendingMachine.sellOrders.sellOrders[num];\r\n\t\tif (!CanPlayerAffordOrderAndDeliveryFee(msg.player, sellOrder, num2))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint num4 = msg.player.inventory.Take(null, deliveryFeeCurrency.itemid, num3);\r\n\t\tif (num4 != num3)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError($\"Took an incorrect number of items for the delivery fee (took {num4}, should have taken {num3})\");\r\n\t\t}\r\n\t\tClientRPC(RpcTarget.Player(\"Client_ShowItemNotice\", msg.player), deliveryFeeCurrency.itemid, -num3, arg3: false);\r\n\t\tif (!vendingMachine.DoTransaction(msg.player, num, num2, base.inventory, _onCurrencyRemovedCached, _onItemPurchasedCached, this))\r\n\t\t{\r\n\t\t\tItem item = ItemManager.CreateByItemID(deliveryFeeCurrency.itemid, num3, 0uL);\r\n\t\t\tif (!msg.player.inventory.GiveItem(item))\r\n\t\t\t{\r\n\t\t\t\titem.Drop(msg.player.inventory.containerMain.dropPosition, msg.player.inventory.containerMain.dropVelocity);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tRestrictToPlayer(msg.player);\r\n\t\t\tRegisterOrder(msg.player, vendingMachine);\r\n\t\t}\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\t_transactionActive = false;\r\n\t}\r\n}\r\n",
    "targetName": "MarketTerminal",
    "methodName": "Server_Purchase",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Community",
    "returnTypeName": "System.Boolean"
  },
  {
    "name": "OnEntitySaved",
    "fullName": "OnEntitySaved",
    "category": "Global",
    "parameters": [
      {
        "name": "networkable",
        "type": "BaseNetworkable, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "info",
        "type": "BaseNetworkable+SaveInfo, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void ToStream(System.IO.Stream stream, BaseNetworkable.SaveInfo saveInfo)\r\n{\r\n\tusing (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())\r\n\t{\r\n\t\tSave(saveInfo);\r\n\t\tif (saveInfo.msg.baseEntity == null)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(this?.ToString() + \": ToStream - no BaseEntity!?\");\r\n\t\t}\r\n\t\tif (saveInfo.msg.baseNetworkable == null)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(this?.ToString() + \": ToStream - no baseNetworkable!?\");\r\n\t\t}\r\n\t\tsaveInfo.msg.ToProto(stream);\r\n\t\tPostSave(saveInfo);\r\n\t}\r\n}\r\n",
    "targetName": "BaseNetworkable",
    "methodName": "ToStream",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IDelFix",
    "fullName": "IDelFix",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "[ServerVar]\r\npublic static void del(ConsoleSystem.Arg args)\r\n{\r\n\tif (!args.HasArgs())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.IEnumerable<UnityEngine.Transform> enumerable = System.Linq.Enumerable.Where(GetCurrent(), (UnityEngine.Transform x) => x.name.ToLower() == args.FullString.ToLower());\r\n\tif (System.Linq.Enumerable.Count(enumerable) == 0)\r\n\t{\r\n\t\tenumerable = System.Linq.Enumerable.Where(GetCurrent(), (UnityEngine.Transform x) => x.name.StartsWith(args.FullString, System.StringComparison.CurrentCultureIgnoreCase));\r\n\t}\r\n\tif (System.Linq.Enumerable.Count(enumerable) == 0)\r\n\t{\r\n\t\targs.ReplyWith(\"Couldn't find  \" + args.FullString);\r\n\t\treturn;\r\n\t}\r\n\tforeach (UnityEngine.Transform item in enumerable)\r\n\t{\r\n\t\tBaseEntity baseEntity = UnityEngine.GameObjectEx.ToBaseEntity(item.gameObject);\r\n\t\tif (baseEntity.IsValid())\r\n\t\t{\r\n\t\t\tif (baseEntity.isServer)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity.Kill();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tGameManager.Destroy(item.gameObject);\r\n\t\t}\r\n\t}\r\n\targs.ReplyWith(\"Deleted \" + System.Linq.Enumerable.Count(enumerable) + \" objects\");\r\n}\r\n",
    "targetName": "ConVar.Hierarchy",
    "methodName": "del",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IFixCarsFix",
    "fullName": "IFixCarsFix",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "[ServerVar]\r\npublic static void fixcars(ConsoleSystem.Arg arg)\r\n{\r\n\tBasePlayer basePlayer = UnityEngine.ArgEx.Player(arg);\r\n\tif (basePlayer == null)\r\n\t{\r\n\t\targ.ReplyWith(\"Null player.\");\r\n\t\treturn;\r\n\t}\r\n\tif (!basePlayer.IsAdmin)\r\n\t{\r\n\t\targ.ReplyWith(\"Must be an admin to use fixcars.\");\r\n\t\treturn;\r\n\t}\r\n\tint @int = arg.GetInt(0, 2);\r\n\t@int = UnityEngine.Mathf.Clamp(@int, 1, 3);\r\n\tBaseVehicle[] array = BaseEntity.Util.FindAll<BaseVehicle>();\r\n\tint num = 0;\r\n\tBaseVehicle[] array2 = array;\r\n\tforeach (BaseVehicle baseVehicle in array2)\r\n\t{\r\n\t\tif (baseVehicle.isServer && UnityEngine.Vector3.Distance(baseVehicle.transform.position, basePlayer.transform.position) <= 10f && baseVehicle.AdminFixUp(@int))\r\n\t\t{\r\n\t\t\tnum++;\r\n\t\t}\r\n\t}\r\n\tMLRS[] array3 = BaseEntity.Util.FindAll<MLRS>();\r\n\tforeach (MLRS mLRS in array3)\r\n\t{\r\n\t\tif (mLRS.isServer && UnityEngine.Vector3.Distance(mLRS.transform.position, basePlayer.transform.position) <= 10f && mLRS.AdminFixUp())\r\n\t\t{\r\n\t\t\tnum++;\r\n\t\t}\r\n\t}\r\n\tDiverPropulsionVehicle[] array4 = BaseEntity.Util.FindAll<DiverPropulsionVehicle>();\r\n\tforeach (DiverPropulsionVehicle diverPropulsionVehicle in array4)\r\n\t{\r\n\t\tif (diverPropulsionVehicle.isServer && UnityEngine.Vector3.Distance(diverPropulsionVehicle.transform.position, basePlayer.transform.position) <= 10f && diverPropulsionVehicle.AdminFixUp())\r\n\t\t{\r\n\t\t\tnum++;\r\n\t\t}\r\n\t}\r\n\targ.ReplyWith($\"Fixed up {num} vehicles.\");\r\n}\r\n",
    "targetName": "ConVar.vehicle",
    "methodName": "fixcars",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "ICraftDurationMultiplier",
    "fullName": "ICraftDurationMultiplier",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public static float GetScaledDuration(ItemBlueprint bp, float workbenchLevel, bool isInTutorial)\r\n{\r\n\tfloat num = workbenchLevel - (float)bp.GetWorkbenchLevel();\r\n\tif (isInTutorial)\r\n\t{\r\n\t\treturn bp.GetCraftTime() * 0.25f;\r\n\t}\r\n\tif (num == 1f)\r\n\t{\r\n\t\treturn bp.GetCraftTime() * 0.5f;\r\n\t}\r\n\tif (num >= 2f)\r\n\t{\r\n\t\treturn bp.GetCraftTime() * 0.25f;\r\n\t}\r\n\treturn bp.GetCraftTime();\r\n}\r\n",
    "targetName": "ItemCrafter",
    "methodName": "GetScaledDuration",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IOvenSmeltSpeedMultiplier",
    "fullName": "IOvenSmeltSpeedMultiplier",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public virtual void StartCooking()\r\n{\r\n\tif (FindBurnable() != null || CanRunWithNoFuel)\r\n\t{\r\n\t\tbase.inventory.temperature = cookingTemperature;\r\n\t\tUpdateAttachmentTemperature();\r\n\t\tInvokeRepeating(Cook, 0.5f, 0.5f);\r\n\t\tif (visualFood)\r\n\t\t{\r\n\t\t\tInvokeRepeating(CookVisuals, 0f, 0.05f);\r\n\t\t}\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\tif (hasOpenFlame)\r\n\t\t{\r\n\t\t\tSingletonComponent<NpcFireManager>.Instance.Add(this);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "BaseOven",
    "methodName": "StartCooking",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IMixingSpeedMultiplier",
    "fullName": "IMixingSpeedMultiplier",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void StartMixing(BasePlayer player)\r\n{\r\n\tif (IsOn() || !CanStartMixing(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tMixStartingPlayer = player;\r\n\tbool itemsAreContiguous;\r\n\tSystem.Collections.Generic.List<Item> orderedContainerItems = GetOrderedContainerItems(base.inventory, out itemsAreContiguous);\r\n\tcurrentRecipe = RecipeDictionary.GetMatchingRecipeAndQuantity(Recipes, orderedContainerItems, out var quantity);\r\n\tcurrentQuantity = quantity;\r\n\tif (!(currentRecipe == null) && itemsAreContiguous && (!currentRecipe.RequiresBlueprint || !(currentRecipe.ProducedItem != null) || player.blueprints.HasUnlocked(currentRecipe.ProducedItem)))\r\n\t{\r\n\t\tif (base.isServer)\r\n\t\t{\r\n\t\t\tlastTickTimestamp = UnityEngine.Time.realtimeSinceStartup;\r\n\t\t}\r\n\t\tRemainingMixTime = currentRecipe.MixingDuration * (float)currentQuantity;\r\n\t\tTotalMixTime = RemainingMixTime;\r\n\t\tReturnExcessItems(orderedContainerItems, player);\r\n\t\tif (RemainingMixTime == 0f)\r\n\t\t{\r\n\t\t\tProduceItem(currentRecipe, currentQuantity);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tInvokeRepeating(TickMix, 1f, 1f);\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true, recursive: false, networkupdate: false);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t}\r\n}\r\n",
    "targetName": "MixingTable",
    "methodName": "StartMixing",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IOnExcavatorInit",
    "fullName": "IOnExcavatorInit",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void Init()\r\n{\r\n\tpendingResources = new ItemAmount[resourcesToMine.Length];\r\n\tfor (int i = 0; i < resourcesToMine.Length; i++)\r\n\t{\r\n\t\tpendingResources[i] = new ItemAmount(resourcesToMine[i].itemDef);\r\n\t}\r\n\tSystem.Collections.Generic.List<ExcavatorOutputPile> obj = Facepunch.Pool.Get<System.Collections.Generic.List<ExcavatorOutputPile>>();\r\n\tVis.Entities(base.transform.position, 200f, obj, 512);\r\n\toutputPiles = new System.Collections.Generic.List<ExcavatorOutputPile>();\r\n\tforeach (ExcavatorOutputPile item in obj)\r\n\t{\r\n\t\tif (!item.isClient)\r\n\t\t{\r\n\t\t\toutputPiles.Add(item);\r\n\t\t}\r\n\t}\r\n\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n}\r\n",
    "targetName": "ExcavatorArm",
    "methodName": "Init",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IRecyclerThinkSpeed",
    "fullName": "IRecyclerThinkSpeed",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public float GetRecycleThinkDuration()\r\n{\r\n\tif (IsSafezoneRecycler())\r\n\t{\r\n\t\treturn 8f;\r\n\t}\r\n\treturn 5f;\r\n}\r\n",
    "targetName": "Recycler",
    "methodName": "GetRecycleThinkDuration",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IResearchDuration",
    "fullName": "IResearchDuration",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "[BaseEntity.RPC_Server]\r\n[BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void DoResearch(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (IsResearching())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer player = msg.player;\r\n\tItem targetItem = GetTargetItem();\r\n\tif (targetItem != null && targetItem.amount <= 1 && IsItemResearchable(targetItem))\r\n\t{\r\n\t\ttargetItem.CollectedForCrafting(player);\r\n\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;\r\n\t\tInvoke(ResearchAttemptFinished, researchDuration);\r\n\t\tbase.inventory.SetLocked(isLocked: true);\r\n\t\tint scrapCost = ScrapForResearch(targetItem);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);\r\n\t\tSetFlag(BaseEntity.Flags.On, b: true);\r\n\t\tSendNetworkUpdate();\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tif (researchStartEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\r\n\t\t}\r\n\t\tmsg.player.GiveAchievement(\"RESEARCH_ITEM\");\r\n\t}\r\n}\r\n",
    "targetName": "ResearchTable",
    "methodName": "DoResearch",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IVendingBuyDuration",
    "fullName": "IVendingBuyDuration",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public virtual float GetBuyDuration()\r\n{\r\n\treturn 2.5f;\r\n}\r\n",
    "targetName": "VendingMachine",
    "methodName": "GetBuyDuration",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IVendingBuyDuration",
    "fullName": "IVendingBuyDuration [1]",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public override float GetBuyDuration()\r\n{\r\n\treturn 0.5f;\r\n}\r\n",
    "targetName": "InvisibleVendingMachine",
    "methodName": "GetBuyDuration",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "OnLoseCondition",
    "fullName": "OnLoseCondition",
    "category": "Global",
    "parameters": [
      {
        "name": "item",
        "type": "Item, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "amount",
        "type": "System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": null,
    "targetName": "Carbon.Core.CorePlugin",
    "methodName": null,
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IOnPlayerChat",
    "fullName": "IOnPlayerChat",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static async System.Threading.Tasks.ValueTask<bool> sayAs(ConVar.Chat.ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)\r\n{\r\n\tif (!player)\r\n\t{\r\n\t\tplayer = null;\r\n\t}\r\n\tif (!enabled)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (player != null && player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif ((ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None) == ServerUsers.UserGroup.Banned)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tstring strChatText = message.Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Trim();\r\n\tif (strChatText.Length > 128)\r\n\t{\r\n\t\tstrChatText = strChatText.Substring(0, 128);\r\n\t}\r\n\tif (strChatText.Length <= 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (strChatText.StartsWith(\"/\") || strChatText.StartsWith(\"\\\\\"))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tstrChatText = UnityEngine.StringEx.EscapeRichText(strChatText);\r\n\tif (ConVar.Server.emojiOwnershipCheck)\r\n\t{\r\n\t\tSystem.Collections.Generic.List<(TmProEmojiRedirector.EmojiSub, int)> obj = Facepunch.Pool.Get<System.Collections.Generic.List<(TmProEmojiRedirector.EmojiSub, int)>>();\r\n\t\tTmProEmojiRedirector.FindEmojiSubstitutions(strChatText, RustEmojiLibrary.Instance, obj, richText: false, isServer: true);\r\n\t\tbool flag = true;\r\n\t\tforeach (var item in obj)\r\n\t\t{\r\n\t\t\tif (!item.Item1.targetEmojiResult.CanBeUsedBy(player))\r\n\t\t\t{\r\n\t\t\t\tflag = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj);\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.Log(\"player tried to use emoji they don't own, reject!\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\tif (serverlog)\r\n\t{\r\n\t\tServerConsole.PrintColoured(System.ConsoleColor.DarkYellow, \"[\" + targetChannel.ToString() + \"] \" + username + \": \", System.ConsoleColor.DarkGreen, strChatText);\r\n\t\tstring text = player?.ToString() ?? $\"{username}[{userId}]\";\r\n\t\tswitch (targetChannel)\r\n\t\t{\r\n\t\tcase ConVar.Chat.ChatChannel.Team:\r\n\t\t\tUnityEngine.DebugEx.Log(\"[TEAM CHAT] \" + text + \" : \" + strChatText);\r\n\t\t\tbreak;\r\n\t\tcase ConVar.Chat.ChatChannel.Cards:\r\n\t\t\tUnityEngine.DebugEx.Log(\"[CARDS CHAT] \" + text + \" : \" + strChatText);\r\n\t\t\tbreak;\r\n\t\tcase ConVar.Chat.ChatChannel.Clan:\r\n\t\t\tUnityEngine.DebugEx.Log(\"[CLAN CHAT] \" + text + \" : \" + strChatText);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tUnityEngine.DebugEx.Log(\"[CHAT] \" + text + \" : \" + strChatText);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tstring strName = UnityEngine.StringEx.EscapeRichText(username);\r\n\tstring nameColor = GetNameColor(userId, player);\r\n\tConVar.Chat.ChatEntry ce = default(ConVar.Chat.ChatEntry);\r\n\tce.Channel = targetChannel;\r\n\tce.Message = strChatText;\r\n\tce.UserId = ((player != null) ? player.UserIDString : userId.ToString());\r\n\tce.Username = username;\r\n\tce.Color = nameColor;\r\n\tce.Time = Facepunch.Math.Epoch.Current;\r\n\tRecord(ce);\r\n\tswitch (targetChannel)\r\n\t{\r\n\tcase ConVar.Chat.ChatChannel.Cards:\r\n\t{\r\n\t\tif (player == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (!player.isMounted)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tBaseCardGameEntity baseCardGameEntity = player.GetMountedVehicle() as BaseCardGameEntity;\r\n\t\tif (baseCardGameEntity == null || !(baseCardGameEntity.GameController?.IsAtTable(player) ?? false))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tSystem.Collections.Generic.List<Network.Connection> obj2 = Facepunch.Pool.Get<System.Collections.Generic.List<Network.Connection>>();\r\n\t\tbaseCardGameEntity.GameController?.GetConnectionsInGame(obj2);\r\n\t\tif (obj2.Count > 0)\r\n\t\t{\r\n\t\t\tConsoleNetwork.SendClientCommand(obj2, \"chat.add2\", 3, userId, strChatText, strName, nameColor, 1f);\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeUnmanaged(ref obj2);\r\n\t\treturn true;\r\n\t}\r\n\tcase ConVar.Chat.ChatChannel.Global:\r\n\t\tConsoleNetwork.BroadcastToAllClients(\"chat.add2\", 0, userId, strChatText, strName, nameColor, 1f);\r\n\t\treturn true;\r\n\tcase ConVar.Chat.ChatChannel.Local:\r\n\t{\r\n\t\tif (!(player != null))\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tfloat num = localChatRange * localChatRange;\r\n\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\r\n\t\t{\r\n\t\t\tfloat sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;\r\n\t\t\tif (!(sqrMagnitude > num))\r\n\t\t\t{\r\n\t\t\t\tConsoleNetwork.SendClientCommand(activePlayer.net.connection, \"chat.add2\", 4, userId, strChatText, strName, nameColor, UnityEngine.Mathf.Clamp01(sqrMagnitude / num + 0.2f));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tcase ConVar.Chat.ChatChannel.Team:\r\n\t{\r\n\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userId);\r\n\t\tif (playerTeam == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tSystem.Collections.Generic.List<Network.Connection> onlineMemberConnections = playerTeam.GetOnlineMemberConnections();\r\n\t\tif (onlineMemberConnections != null)\r\n\t\t{\r\n\t\t\tConsoleNetwork.SendClientCommand(onlineMemberConnections, \"chat.add2\", 1, userId, strChatText, strName, nameColor, 1f);\r\n\t\t}\r\n\t\tCompanionServer.Util.BroadcastTeamChat(playerTeam, userId, strName, strChatText, nameColor);\r\n\t\treturn true;\r\n\t}\r\n\tcase ConVar.Chat.ChatChannel.Clan:\r\n\t{\r\n\t\tClanManager serverInstance = ClanManager.ServerInstance;\r\n\t\tif (serverInstance == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (player != null && player.clanId == 0L)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\tClanValueResult<IClan> clanValueResult = ((!(player != null) || player.clanId == 0L) ? (await serverInstance.Backend.GetByMember(userId)) : (await serverInstance.Backend.Get(player.clanId)));\r\n\t\t\tClanValueResult<IClan> clanValueResult2 = clanValueResult;\r\n\t\t\tif (!clanValueResult2.IsSuccess)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (await clanValueResult2.Value.SendChatMessage(strName, strChatText, userId) != ClanResult.Success)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch (System.Exception message2)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogError(message2);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "targetName": "ConVar.Chat",
    "methodName": "sayAs",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "Init",
    "fullName": "Init [Instance]",
    "category": "Plugin",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static Oxide.Plugins.RustPlugin InitializePlugin(System.Reflection.Assembly assembly, Carbon.Core.ModLoader.Package package = default(Carbon.Core.ModLoader.Package), System.Action<Oxide.Plugins.RustPlugin> preInit = null, bool precompiled = false)\r\n{\r\n\tSystem.Type[] types = assembly.GetTypes();\r\n\tforeach (System.Type type in types)\r\n\t{\r\n\t\tif (!(type.BaseType == null) && IsValidPlugin(type.BaseType, recursive: false) && InitializePlugin(type, out var plugin, package, preInit, precompiled))\r\n\t\t{\r\n\t\t\treturn plugin;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n",
    "targetName": "Carbon.Core.ModLoader",
    "methodName": "InitializePlugin",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "LoadDefaultMessages",
    "fullName": "LoadDefaultMessages [Instance]",
    "category": "Plugin",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static Oxide.Plugins.RustPlugin InitializePlugin(System.Reflection.Assembly assembly, Carbon.Core.ModLoader.Package package = default(Carbon.Core.ModLoader.Package), System.Action<Oxide.Plugins.RustPlugin> preInit = null, bool precompiled = false)\r\n{\r\n\tSystem.Type[] types = assembly.GetTypes();\r\n\tforeach (System.Type type in types)\r\n\t{\r\n\t\tif (!(type.BaseType == null) && IsValidPlugin(type.BaseType, recursive: false) && InitializePlugin(type, out var plugin, package, preInit, precompiled))\r\n\t\t{\r\n\t\t\treturn plugin;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n",
    "targetName": "Carbon.Core.ModLoader",
    "methodName": "InitializePlugin",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "Loaded",
    "fullName": "Loaded [Instance]",
    "category": "Plugin",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static Oxide.Plugins.RustPlugin InitializePlugin(System.Reflection.Assembly assembly, Carbon.Core.ModLoader.Package package = default(Carbon.Core.ModLoader.Package), System.Action<Oxide.Plugins.RustPlugin> preInit = null, bool precompiled = false)\r\n{\r\n\tSystem.Type[] types = assembly.GetTypes();\r\n\tforeach (System.Type type in types)\r\n\t{\r\n\t\tif (!(type.BaseType == null) && IsValidPlugin(type.BaseType, recursive: false) && InitializePlugin(type, out var plugin, package, preInit, precompiled))\r\n\t\t{\r\n\t\t\treturn plugin;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n",
    "targetName": "Carbon.Core.ModLoader",
    "methodName": "InitializePlugin",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "OnLoaded",
    "fullName": "OnLoaded [Instance]",
    "category": "Plugin",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static Oxide.Plugins.RustPlugin InitializePlugin(System.Reflection.Assembly assembly, Carbon.Core.ModLoader.Package package = default(Carbon.Core.ModLoader.Package), System.Action<Oxide.Plugins.RustPlugin> preInit = null, bool precompiled = false)\r\n{\r\n\tSystem.Type[] types = assembly.GetTypes();\r\n\tforeach (System.Type type in types)\r\n\t{\r\n\t\tif (!(type.BaseType == null) && IsValidPlugin(type.BaseType, recursive: false) && InitializePlugin(type, out var plugin, package, preInit, precompiled))\r\n\t\t{\r\n\t\t\treturn plugin;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n",
    "targetName": "Carbon.Core.ModLoader",
    "methodName": "InitializePlugin",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "OnPluginOutdated",
    "fullName": "OnPluginOutdated",
    "category": "Plugin",
    "parameters": [
      {
        "name": "pluginName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "currentVersion",
        "type": "Oxide.Core.VersionNumber, Carbon.SDK, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "newVersion",
        "type": "Oxide.Core.VersionNumber, Carbon.SDK, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "plugin",
        "type": "Oxide.Core.Plugins.Plugin, Carbon.Common, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      },
      {
        "name": "vendorName",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": null,
    "targetName": null,
    "methodName": null,
    "assemblyName": null,
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "Unload",
    "fullName": "Unload [Instance]",
    "category": "Plugin",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static Oxide.Plugins.RustPlugin InitializePlugin(System.Reflection.Assembly assembly, Carbon.Core.ModLoader.Package package = default(Carbon.Core.ModLoader.Package), System.Action<Oxide.Plugins.RustPlugin> preInit = null, bool precompiled = false)\r\n{\r\n\tSystem.Type[] types = assembly.GetTypes();\r\n\tforeach (System.Type type in types)\r\n\t{\r\n\t\tif (!(type.BaseType == null) && IsValidPlugin(type.BaseType, recursive: false) && InitializePlugin(type, out var plugin, package, preInit, precompiled))\r\n\t\t{\r\n\t\t\treturn plugin;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n",
    "targetName": "Carbon.Core.ModLoader",
    "methodName": "InitializePlugin",
    "assemblyName": "Carbon.Common",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IBroadcastOverride",
    "fullName": "IBroadcastOverride",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public static void Broadcast(string message, string username = \"SERVER\", string color = \"#eee\", ulong userid = 0uL)\r\n{\r\n\tstring text = UnityEngine.StringEx.EscapeRichText(username);\r\n\tConsoleNetwork.BroadcastToAllClients(\"chat.add\", 2, 0, \"<color=\" + color + \">\" + text + \"</color> \" + message);\r\n\tConVar.Chat.ChatEntry ce = default(ConVar.Chat.ChatEntry);\r\n\tce.Channel = ConVar.Chat.ChatChannel.Server;\r\n\tce.Message = message;\r\n\tce.UserId = userid.ToString();\r\n\tce.Username = username;\r\n\tce.Color = color;\r\n\tce.Time = Facepunch.Math.Epoch.Current;\r\n\tRecord(ce);\r\n}\r\n",
    "targetName": "ConVar.Chat",
    "methodName": "Broadcast",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IConsoleEnter",
    "fullName": "IConsoleEnter",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void OnEnter()\r\n{\r\n\tClearLine(statusText.Length);\r\n\tSystem.Console.ForegroundColor = System.ConsoleColor.Green;\r\n\tSystem.Console.WriteLine(\"> \" + inputString);\r\n\tstring obj = inputString;\r\n\tinputString = \"\";\r\n\tif (this.OnInputText != null)\r\n\t{\r\n\t\tthis.OnInputText(obj);\r\n\t}\r\n\tRedrawInputLine();\r\n}\r\n",
    "targetName": "Windows.ConsoleInput",
    "methodName": "OnEnter",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IConsoleUpdate",
    "fullName": "IConsoleUpdate",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void Update()\r\n{\r\n\tif (!valid)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (nextUpdate < UnityEngine.Time.realtimeSinceStartup)\r\n\t{\r\n\t\tRedrawInputLine();\r\n\t\tnextUpdate = UnityEngine.Time.realtimeSinceStartup + 0.5f;\r\n\t}\r\n\ttry\r\n\t{\r\n\t\tif (!System.Console.KeyAvailable)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tcatch (System.Exception)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.ConsoleKeyInfo consoleKeyInfo = System.Console.ReadKey();\r\n\tif (consoleKeyInfo.Key == System.ConsoleKey.Enter)\r\n\t{\r\n\t\tOnEnter();\r\n\t}\r\n\telse if (consoleKeyInfo.Key == System.ConsoleKey.Backspace)\r\n\t{\r\n\t\tOnBackspace();\r\n\t}\r\n\telse if (consoleKeyInfo.Key == System.ConsoleKey.Escape)\r\n\t{\r\n\t\tOnEscape();\r\n\t}\r\n\telse if (consoleKeyInfo.KeyChar != 0)\r\n\t{\r\n\t\tinputString += consoleKeyInfo.KeyChar;\r\n\t\tRedrawInputLine();\r\n\t}\r\n}\r\n",
    "targetName": "Windows.ConsoleInput",
    "methodName": "Update",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "OnConsoleCommand",
    "fullName": "OnConsoleCommand",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public static string Run(ConsoleSystem.Option options, string strCommand, params object[] args)\r\n{\r\n\tLastError = null;\r\n\tstring text = BuildCommand(strCommand, args);\r\n\tConsoleSystem.Arg arg = new ConsoleSystem.Arg(options, text);\r\n\tbool flag = arg.HasPermission();\r\n\tif (!arg.Invalid && flag)\r\n\t{\r\n\t\tConsoleSystem.Arg currentArgs = CurrentArgs;\r\n\t\tCurrentArgs = arg;\r\n\t\tbool flag2 = Internal(arg);\r\n\t\tCurrentArgs = currentArgs;\r\n\t\tif (options.PrintOutput && flag2 && arg.Reply != null && arg.Reply.Length > 0)\r\n\t\t{\r\n\t\t\tUnityEngine.DebugEx.Log(arg.Reply);\r\n\t\t}\r\n\t\treturn arg.Reply;\r\n\t}\r\n\tLastError = \"Command not found\";\r\n\tif (!flag)\r\n\t{\r\n\t\tLastError = \"Permission denied\";\r\n\t}\r\n\tif (!options.IsServer && (!options.ForwardtoServerOnMissing || !SendToServer(text)))\r\n\t{\r\n\t\tLastError = \"Command '\" + strCommand + \"' not found\";\r\n\t\tif (options.PrintOutput && !ignoredCommands.Contains(strCommand))\r\n\t\t{\r\n\t\t\tUnityEngine.DebugEx.Log(LastError);\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\tif (options.IsServer && options.PrintOutput)\r\n\t{\r\n\t\tLastError = \"Command '\" + strCommand + \"' not found\";\r\n\t\tif (!ignoredCommands.Contains(strCommand))\r\n\t\t{\r\n\t\t\tUnityEngine.DebugEx.Log(LastError);\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n",
    "targetName": "ConsoleSystem",
    "methodName": "Run",
    "assemblyName": "Facepunch.Console",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "OnRconCommand",
    "fullName": "OnRconCommand",
    "category": "Global",
    "parameters": [
      {
        "name": "ip",
        "type": "System.Net.IPAddress, System.Net.Primitives, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
        "optional": false
      },
      {
        "name": "command",
        "type": "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      },
      {
        "name": "arguments",
        "type": "System.String[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public static void OnCommand(Facepunch.RCon.Command cmd)\r\n{\r\n\ttry\r\n\t{\r\n\t\tresponseIdentifier = cmd.Identifier;\r\n\t\tresponseConnection = cmd.ConnectionId;\r\n\t\tisInput = true;\r\n\t\tif (Print)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.Log(\"[rcon] \" + cmd.Ip?.ToString() + \": \" + cmd.Message);\r\n\t\t}\r\n\t\tisInput = false;\r\n\t\ttimer.Restart();\r\n\t\tstring text = ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet().WithRconId(cmd.ConnectionId), cmd.Message);\r\n\t\ttimer.Stop();\r\n\t\tSystem.TimeSpan elapsed = timer.Elapsed;\r\n\t\tif (Facepunch.Rust.Profiling.RconProfiler.mode > 0)\r\n\t\t{\r\n\t\t\tFacepunch.Rust.Profiling.RconProfiler.ExecutionTime += elapsed;\r\n\t\t}\r\n\t\tif (elapsed > Facepunch.Rust.Profiling.RuntimeProfiler.RconCommandWarningThreshold)\r\n\t\t{\r\n\t\t\tFacepunch.Rust.Profiling.LagSpikeProfiler.RconCommand(timer.Elapsed, cmd.Message);\r\n\t\t}\r\n\t\tif (text != null)\r\n\t\t{\r\n\t\t\tOnMessage(text, string.Empty, UnityEngine.LogType.Log);\r\n\t\t}\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\tresponseIdentifier = 0;\r\n\t\tresponseConnection = -1;\r\n\t}\r\n}\r\n",
    "targetName": "Facepunch.RCon",
    "methodName": "OnCommand",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "OnServerInitialized",
    "fullName": "OnServerInitialized",
    "category": "Global",
    "parameters": [
      {
        "name": "initialLoad",
        "type": "System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
        "optional": true
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": true,
    "methodSource": "public void OpenConnection(bool useSteamServer = true)\r\n{\r\n\tif (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)\r\n\t{\r\n\t\tConVar.Server.queryport = System.Math.Max(ConVar.Server.port, Facepunch.RCon.Port) + 1;\r\n\t}\r\n\tNetwork.Net.sv.ip = ConVar.Server.ip;\r\n\tNetwork.Net.sv.port = ConVar.Server.port;\r\n\tif (useSteamServer)\r\n\t{\r\n\t\tStartSteamServer();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tPlatformService.Instance.Initialize(RustPlatformHooks.Instance);\r\n\t}\r\n\tif (!Network.Net.sv.Start(this))\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Couldn't Start Server.\");\r\n\t\tCloseConnection();\r\n\t\treturn;\r\n\t}\r\n\tNetwork.Net.sv.cryptography = new NetworkCryptographyServer();\r\n\tEACServer.DoStartup();\r\n\tInvokeRepeating(\"DoTick\", 1f, 1f / (float)ConVar.Server.tickrate);\r\n\tInvokeRepeating(\"DoHeartbeat\", 1f, 1f);\r\n\trunFrameUpdate = true;\r\n\tConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;\r\n\tif (ConVar.Server.autoUploadMap)\r\n\t{\r\n\t\tMapUploader.UploadMap();\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "OpenConnection",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IServerAsyncShutdown",
    "fullName": "IServerAsyncShutdown",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "[ClientVar]\r\n[ServerVar]\r\npublic static void quit(ConsoleSystem.Arg args)\r\n{\r\n\tif (args != null && args.HasArgs())\r\n\t{\r\n\t\targs.ReplyWith(\"Invalid quit command, quit only works if provided with no arguments.\");\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Application.isEditor)\r\n\t{\r\n\t\tUnityEngine.Debug.LogWarning(\"Aborting quit because we're in the editor\");\r\n\t\treturn;\r\n\t}\r\n\tif (SingletonComponent<ServerMgr>.Instance != null)\r\n\t{\r\n\t\tSingletonComponent<ServerMgr>.Instance.Shutdown();\r\n\t}\r\n\tRust.Application.isQuitting = true;\r\n\tNetwork.Net.sv?.Stop(\"quit\");\r\n\tSystem.Diagnostics.Process.GetCurrentProcess().Kill();\r\n\tUnityEngine.Debug.Log(\"Quitting\");\r\n\tRust.Application.Quit();\r\n}\r\n",
    "targetName": "ConVar.Global",
    "methodName": "quit",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IServerInfoUpdate",
    "fullName": "IServerInfoUpdate",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void UpdateServerInformation()\r\n{\r\n\tif (!Steamworks.SteamServer.IsValid)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"UpdateServerInformation\"))\r\n\t{\r\n\t\tSteamworks.SteamServer.ServerName = ConVar.Server.hostname;\r\n\t\tSteamworks.SteamServer.MaxPlayers = ConVar.Server.maxplayers;\r\n\t\tSteamworks.SteamServer.Passworded = false;\r\n\t\tSteamworks.SteamServer.MapName = World.GetServerBrowserMapName();\r\n\t\tstring value = \"stok\";\r\n\t\tif (Restarting)\r\n\t\t{\r\n\t\t\tvalue = \"strst\";\r\n\t\t}\r\n\t\tstring text = $\"born{Facepunch.Math.Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}\";\r\n\t\tstring text2 = $\"gm{GamemodeName()}\";\r\n\t\tstring text3 = (ConVar.Server.pve ? \",pve\" : string.Empty);\r\n\t\tstring text4 = ConVar.Server.tags?.Trim(',') ?? \"\";\r\n\t\tstring text5 = ((!string.IsNullOrWhiteSpace(text4)) ? (\",\" + text4) : \"\");\r\n\t\tstring text6 = Facepunch.BuildInfo.Current?.Scm?.ChangeId ?? \"0\";\r\n\t\tstring text7 = (ConVar.Server.premium ? \",premium\" : \"\");\r\n\t\tstring text8 = Facepunch.Ping.PingEstimater.GetCachedClosestRegion().Code;\r\n\t\tif (!string.IsNullOrEmpty(ConVar.Server.ping_region_code_override))\r\n\t\t{\r\n\t\t\ttext8 = ConVar.Server.ping_region_code_override;\r\n\t\t}\r\n\t\tSteamworks.SteamServer.GameTags = ServerTagCompressor.CompressTags($\"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},$r{text8},v{2583}{text3}{text5},{text},{text2},cs{text6}{text7}\");\r\n\t\tif (ConVar.Server.description != null && ConVar.Server.description.Length > 100)\r\n\t\t{\r\n\t\t\tstring[] array = System.Linq.Enumerable.ToArray(UnityEngine.StringEx.SplitToChunks(ConVar.Server.description, 100));\r\n\t\t\tfor (int i = 0; i < 16; i++)\r\n\t\t\t{\r\n\t\t\t\tif (i < array.Length)\r\n\t\t\t\t{\r\n\t\t\t\t\tSteamworks.SteamServer.SetKey($\"description_{i:00}\", array[i]);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tSteamworks.SteamServer.SetKey($\"description_{i:00}\", string.Empty);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSteamworks.SteamServer.SetKey(\"description_0\", ConVar.Server.description);\r\n\t\t\tfor (int j = 1; j < 16; j++)\r\n\t\t\t{\r\n\t\t\t\tSteamworks.SteamServer.SetKey($\"description_{j:00}\", string.Empty);\r\n\t\t\t}\r\n\t\t}\r\n\t\tSteamworks.SteamServer.SetKey(\"hash\", AssemblyHash);\r\n\t\tSteamworks.SteamServer.SetKey(\"status\", value);\r\n\t\tstring value2 = World.Seed.ToString();\r\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\r\n\t\tif (activeGameMode != null && !activeGameMode.ingameMap)\r\n\t\t{\r\n\t\t\tvalue2 = \"0\";\r\n\t\t}\r\n\t\tSteamworks.SteamServer.SetKey(\"world.seed\", value2);\r\n\t\tSteamworks.SteamServer.SetKey(\"world.size\", World.Size.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"pve\", ConVar.Server.pve.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"headerimage\", ConVar.Server.headerimage);\r\n\t\tSteamworks.SteamServer.SetKey(\"logoimage\", ConVar.Server.logoimage);\r\n\t\tSteamworks.SteamServer.SetKey(\"url\", ConVar.Server.url);\r\n\t\tif (!string.IsNullOrWhiteSpace(ConVar.Server.favoritesEndpoint))\r\n\t\t{\r\n\t\t\tSteamworks.SteamServer.SetKey(\"favendpoint\", ConVar.Server.favoritesEndpoint);\r\n\t\t}\r\n\t\tSteamworks.SteamServer.SetKey(\"gmn\", GamemodeName());\r\n\t\tSteamworks.SteamServer.SetKey(\"gmt\", GamemodeTitle());\r\n\t\tSteamworks.SteamServer.SetKey(\"uptime\", ((int)UnityEngine.Time.realtimeSinceStartup).ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"gc_mb\", Performance.report.memoryAllocations.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"gc_cl\", Performance.report.memoryCollections.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"ram_sys\", (Performance.report.memoryUsageSystem / 1000000).ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"fps\", Performance.report.frameRate.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"fps_avg\", Performance.report.frameRateAverage.ToString(\"0.00\"));\r\n\t\tSteamworks.SteamServer.SetKey(\"ent_cnt\", BaseNetworkable.serverEntities.Count.ToString());\r\n\t\tSteamworks.SteamServer.SetKey(\"build\", Facepunch.BuildInfo.Current.Scm.ChangeId);\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "UpdateServerInformation",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "IServerMgrOnRPCMessage",
    "fullName": "IServerMgrOnRPCMessage",
    "category": "Global",
    "parameters": [],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "public void OnRPCMessage(Network.Message packet)\r\n{\r\n\ttimer.Restart();\r\n\tNetworkableId uid = packet.read.EntityID();\r\n\tuint num = packet.read.UInt32();\r\n\tif (ConVar.Server.rpclog_enabled)\r\n\t{\r\n\t\trpcHistory.Increment(num);\r\n\t}\r\n\tBaseEntity baseEntity = BaseNetworkable.serverEntities.Find(uid) as BaseEntity;\r\n\tif (!(baseEntity == null))\r\n\t{\r\n\t\tbaseEntity.SendDemoTransientEntity();\r\n\t\tbaseEntity.SV_RPCMessage(num, packet);\r\n\t\tif (timer.Elapsed > Facepunch.Rust.Profiling.RuntimeProfiler.RpcWarningThreshold)\r\n\t\t{\r\n\t\t\tFacepunch.Rust.Profiling.LagSpikeProfiler.RPC(timer.Elapsed, packet, baseEntity, num);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "targetName": "ServerMgr",
    "methodName": "OnRPCMessage",
    "assemblyName": "Assembly-CSharp",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "void"
  },
  {
    "name": "OnNativeCommandHasPermission",
    "fullName": "OnNativeCommandHasPermission",
    "category": "Global",
    "parameters": [
      {
        "name": "arg",
        "type": "ConsoleSystem+Arg, Facepunch.Console, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
        "optional": false
      }
    ],
    "carbonCompatible": true,
    "oxideCompatible": false,
    "methodSource": "",
    "targetName": "ConsoleSystem+Arg",
    "methodName": "HasPermission",
    "assemblyName": "Facepunch.Console",
    "hooksAssemblyName": "Carbon.Hooks.Base",
    "returnTypeName": "System.Boolean"
  }
]